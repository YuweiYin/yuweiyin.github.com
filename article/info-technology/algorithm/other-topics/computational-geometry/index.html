<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Computational Geometry | YuweiYin</title>
    <meta name="description" content="Homepage of YuweiYin">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/YuweiYin.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.2d4b740c.css" as="style"><link rel="preload" href="/assets/js/app.889edd9f.js" as="script"><link rel="preload" href="/assets/js/2.db22a8ef.js" as="script"><link rel="preload" href="/assets/js/71.12750d3a.js" as="script"><link rel="prefetch" href="/assets/js/10.38f130d5.js"><link rel="prefetch" href="/assets/js/100.df3718af.js"><link rel="prefetch" href="/assets/js/101.e4573b4b.js"><link rel="prefetch" href="/assets/js/102.7cc6e0cb.js"><link rel="prefetch" href="/assets/js/103.9529c8c4.js"><link rel="prefetch" href="/assets/js/104.a08b9031.js"><link rel="prefetch" href="/assets/js/105.70268c0d.js"><link rel="prefetch" href="/assets/js/106.278d4171.js"><link rel="prefetch" href="/assets/js/107.9359e93b.js"><link rel="prefetch" href="/assets/js/108.e61de7c2.js"><link rel="prefetch" href="/assets/js/109.572fe929.js"><link rel="prefetch" href="/assets/js/11.6c4c1478.js"><link rel="prefetch" href="/assets/js/110.40bc4e44.js"><link rel="prefetch" href="/assets/js/111.d525589b.js"><link rel="prefetch" href="/assets/js/112.9793479f.js"><link rel="prefetch" href="/assets/js/113.d95ddea5.js"><link rel="prefetch" href="/assets/js/114.35035de0.js"><link rel="prefetch" href="/assets/js/115.311f4756.js"><link rel="prefetch" href="/assets/js/116.cab06e98.js"><link rel="prefetch" href="/assets/js/117.7680462e.js"><link rel="prefetch" href="/assets/js/118.873a428a.js"><link rel="prefetch" href="/assets/js/119.aa3b5480.js"><link rel="prefetch" href="/assets/js/12.1501fed1.js"><link rel="prefetch" href="/assets/js/120.6a2d0e6c.js"><link rel="prefetch" href="/assets/js/121.32fcbc34.js"><link rel="prefetch" href="/assets/js/122.0077e15e.js"><link rel="prefetch" href="/assets/js/123.9c26a4d7.js"><link rel="prefetch" href="/assets/js/124.01a6eed8.js"><link rel="prefetch" href="/assets/js/125.c02e1e76.js"><link rel="prefetch" href="/assets/js/126.639a16fe.js"><link rel="prefetch" href="/assets/js/127.c4ba634b.js"><link rel="prefetch" href="/assets/js/128.5d5e2a9d.js"><link rel="prefetch" href="/assets/js/129.6e999c69.js"><link rel="prefetch" href="/assets/js/13.d461b617.js"><link rel="prefetch" href="/assets/js/130.d3432f4c.js"><link rel="prefetch" href="/assets/js/131.9827c460.js"><link rel="prefetch" href="/assets/js/132.fc146c9f.js"><link rel="prefetch" href="/assets/js/133.11993abd.js"><link rel="prefetch" href="/assets/js/134.3060aea4.js"><link rel="prefetch" href="/assets/js/135.830f08b9.js"><link rel="prefetch" href="/assets/js/136.424c4625.js"><link rel="prefetch" href="/assets/js/137.7199f86a.js"><link rel="prefetch" href="/assets/js/138.7e76f8e6.js"><link rel="prefetch" href="/assets/js/139.0942955e.js"><link rel="prefetch" href="/assets/js/14.2eb76f33.js"><link rel="prefetch" href="/assets/js/140.0be8a3ee.js"><link rel="prefetch" href="/assets/js/141.bad6b22e.js"><link rel="prefetch" href="/assets/js/142.b4f0acd4.js"><link rel="prefetch" href="/assets/js/143.689a2747.js"><link rel="prefetch" href="/assets/js/144.01942a8e.js"><link rel="prefetch" href="/assets/js/145.fed84658.js"><link rel="prefetch" href="/assets/js/146.6e88f670.js"><link rel="prefetch" href="/assets/js/147.7264f183.js"><link rel="prefetch" href="/assets/js/148.a2bd57c5.js"><link rel="prefetch" href="/assets/js/149.b3195c06.js"><link rel="prefetch" href="/assets/js/15.c1afa11d.js"><link rel="prefetch" href="/assets/js/150.c89119f8.js"><link rel="prefetch" href="/assets/js/151.b2060dd4.js"><link rel="prefetch" href="/assets/js/152.911e236e.js"><link rel="prefetch" href="/assets/js/153.d14240ce.js"><link rel="prefetch" href="/assets/js/154.abf5af2c.js"><link rel="prefetch" href="/assets/js/155.d813ee8e.js"><link rel="prefetch" href="/assets/js/156.796de07e.js"><link rel="prefetch" href="/assets/js/157.f4c9d37c.js"><link rel="prefetch" href="/assets/js/158.b9b6607c.js"><link rel="prefetch" href="/assets/js/159.b7144b27.js"><link rel="prefetch" href="/assets/js/16.e21db34b.js"><link rel="prefetch" href="/assets/js/160.e5c8fb4b.js"><link rel="prefetch" href="/assets/js/161.c3470b68.js"><link rel="prefetch" href="/assets/js/162.6a737186.js"><link rel="prefetch" href="/assets/js/163.aa758fdf.js"><link rel="prefetch" href="/assets/js/164.2c86e014.js"><link rel="prefetch" href="/assets/js/165.3314a9e1.js"><link rel="prefetch" href="/assets/js/166.dd805e0c.js"><link rel="prefetch" href="/assets/js/167.8f17ddcf.js"><link rel="prefetch" href="/assets/js/168.617676c0.js"><link rel="prefetch" href="/assets/js/169.79447ac4.js"><link rel="prefetch" href="/assets/js/17.ccecbd2b.js"><link rel="prefetch" href="/assets/js/170.37f6b0fa.js"><link rel="prefetch" href="/assets/js/171.2cc5b5fb.js"><link rel="prefetch" href="/assets/js/172.2b83eb70.js"><link rel="prefetch" href="/assets/js/173.fd24dd09.js"><link rel="prefetch" href="/assets/js/174.801fad5c.js"><link rel="prefetch" href="/assets/js/175.b59b6f6e.js"><link rel="prefetch" href="/assets/js/176.240f51e0.js"><link rel="prefetch" href="/assets/js/177.b62c94c3.js"><link rel="prefetch" href="/assets/js/178.13c02fb3.js"><link rel="prefetch" href="/assets/js/179.b3c0d173.js"><link rel="prefetch" href="/assets/js/18.94cc37a4.js"><link rel="prefetch" href="/assets/js/180.33fafeb6.js"><link rel="prefetch" href="/assets/js/181.13cb8860.js"><link rel="prefetch" href="/assets/js/182.028d2569.js"><link rel="prefetch" href="/assets/js/183.4b510873.js"><link rel="prefetch" href="/assets/js/184.5501d475.js"><link rel="prefetch" href="/assets/js/185.c32c6d9c.js"><link rel="prefetch" href="/assets/js/186.f1363842.js"><link rel="prefetch" href="/assets/js/187.e6c581ac.js"><link rel="prefetch" href="/assets/js/188.a9c0f1c7.js"><link rel="prefetch" href="/assets/js/189.14e74432.js"><link rel="prefetch" href="/assets/js/19.ffad74b8.js"><link rel="prefetch" href="/assets/js/190.55fa5bf4.js"><link rel="prefetch" href="/assets/js/191.a952564e.js"><link rel="prefetch" href="/assets/js/192.b273e561.js"><link rel="prefetch" href="/assets/js/193.34b70651.js"><link rel="prefetch" href="/assets/js/194.6f2e4646.js"><link rel="prefetch" href="/assets/js/195.42aaf82b.js"><link rel="prefetch" href="/assets/js/196.bb04f667.js"><link rel="prefetch" href="/assets/js/197.75fb9486.js"><link rel="prefetch" href="/assets/js/198.7b4e1836.js"><link rel="prefetch" href="/assets/js/199.d6bc8f46.js"><link rel="prefetch" href="/assets/js/20.a7b0d64a.js"><link rel="prefetch" href="/assets/js/200.4eefa36a.js"><link rel="prefetch" href="/assets/js/201.26c213db.js"><link rel="prefetch" href="/assets/js/202.4af393ed.js"><link rel="prefetch" href="/assets/js/203.04c8bfd4.js"><link rel="prefetch" href="/assets/js/204.04cc3124.js"><link rel="prefetch" href="/assets/js/205.23e88615.js"><link rel="prefetch" href="/assets/js/206.739a13b8.js"><link rel="prefetch" href="/assets/js/207.f5911a24.js"><link rel="prefetch" href="/assets/js/208.5ab804c7.js"><link rel="prefetch" href="/assets/js/209.4d13bb08.js"><link rel="prefetch" href="/assets/js/21.e5a244ec.js"><link rel="prefetch" href="/assets/js/210.2a4fb3b9.js"><link rel="prefetch" href="/assets/js/211.bc3b7cd2.js"><link rel="prefetch" href="/assets/js/212.ca2de8d8.js"><link rel="prefetch" href="/assets/js/213.0bb22f92.js"><link rel="prefetch" href="/assets/js/214.cce0fdf0.js"><link rel="prefetch" href="/assets/js/215.aa94fccf.js"><link rel="prefetch" href="/assets/js/216.2db0900e.js"><link rel="prefetch" href="/assets/js/217.65d56e78.js"><link rel="prefetch" href="/assets/js/218.34e35e2d.js"><link rel="prefetch" href="/assets/js/219.8d24e792.js"><link rel="prefetch" href="/assets/js/22.f9ed6134.js"><link rel="prefetch" href="/assets/js/220.fdc7e6ae.js"><link rel="prefetch" href="/assets/js/221.39a10820.js"><link rel="prefetch" href="/assets/js/222.7df1d499.js"><link rel="prefetch" href="/assets/js/223.7359e9f0.js"><link rel="prefetch" href="/assets/js/224.39d8cf2f.js"><link rel="prefetch" href="/assets/js/225.94ff811f.js"><link rel="prefetch" href="/assets/js/226.08da1b9b.js"><link rel="prefetch" href="/assets/js/227.20a97882.js"><link rel="prefetch" href="/assets/js/228.c7df5d60.js"><link rel="prefetch" href="/assets/js/229.2335366b.js"><link rel="prefetch" href="/assets/js/23.90ec9c00.js"><link rel="prefetch" href="/assets/js/230.ca8a2fd5.js"><link rel="prefetch" href="/assets/js/231.cf809810.js"><link rel="prefetch" href="/assets/js/232.737d55a4.js"><link rel="prefetch" href="/assets/js/233.e28709ca.js"><link rel="prefetch" href="/assets/js/234.fd7fd230.js"><link rel="prefetch" href="/assets/js/235.44a01c2a.js"><link rel="prefetch" href="/assets/js/236.7b859de4.js"><link rel="prefetch" href="/assets/js/237.959ec847.js"><link rel="prefetch" href="/assets/js/238.78ee1551.js"><link rel="prefetch" href="/assets/js/239.f516b314.js"><link rel="prefetch" href="/assets/js/24.fbde5e38.js"><link rel="prefetch" href="/assets/js/240.bb9d5584.js"><link rel="prefetch" href="/assets/js/241.ecbea0d8.js"><link rel="prefetch" href="/assets/js/242.8f678194.js"><link rel="prefetch" href="/assets/js/243.9b4594a2.js"><link rel="prefetch" href="/assets/js/244.f29f474c.js"><link rel="prefetch" href="/assets/js/245.5ca7b3cf.js"><link rel="prefetch" href="/assets/js/246.a4824922.js"><link rel="prefetch" href="/assets/js/247.6638f340.js"><link rel="prefetch" href="/assets/js/248.6bfdff66.js"><link rel="prefetch" href="/assets/js/249.0faad332.js"><link rel="prefetch" href="/assets/js/25.7b0a9adb.js"><link rel="prefetch" href="/assets/js/250.1e96b54b.js"><link rel="prefetch" href="/assets/js/251.d255db4c.js"><link rel="prefetch" href="/assets/js/252.0cac8fea.js"><link rel="prefetch" href="/assets/js/253.b2b59122.js"><link rel="prefetch" href="/assets/js/254.9373b351.js"><link rel="prefetch" href="/assets/js/255.bffa8c82.js"><link rel="prefetch" href="/assets/js/256.ac066df4.js"><link rel="prefetch" href="/assets/js/257.f4687940.js"><link rel="prefetch" href="/assets/js/258.0dab0c75.js"><link rel="prefetch" href="/assets/js/259.38d6535e.js"><link rel="prefetch" href="/assets/js/26.bfcdaea4.js"><link rel="prefetch" href="/assets/js/260.87e44c3e.js"><link rel="prefetch" href="/assets/js/261.a3bfd25a.js"><link rel="prefetch" href="/assets/js/262.bc7a67d2.js"><link rel="prefetch" href="/assets/js/263.ded7f599.js"><link rel="prefetch" href="/assets/js/264.efe7024a.js"><link rel="prefetch" href="/assets/js/265.606fe63b.js"><link rel="prefetch" href="/assets/js/266.aa723b37.js"><link rel="prefetch" href="/assets/js/267.841bdd62.js"><link rel="prefetch" href="/assets/js/268.4716b99d.js"><link rel="prefetch" href="/assets/js/269.25c9fc6e.js"><link rel="prefetch" href="/assets/js/27.f493e686.js"><link rel="prefetch" href="/assets/js/270.2d961cd6.js"><link rel="prefetch" href="/assets/js/271.a2ac98f1.js"><link rel="prefetch" href="/assets/js/272.2234abf7.js"><link rel="prefetch" href="/assets/js/273.31019e41.js"><link rel="prefetch" href="/assets/js/274.a470a332.js"><link rel="prefetch" href="/assets/js/275.4fd2d745.js"><link rel="prefetch" href="/assets/js/276.314ef973.js"><link rel="prefetch" href="/assets/js/277.99bfab23.js"><link rel="prefetch" href="/assets/js/278.778cf269.js"><link rel="prefetch" href="/assets/js/279.d4748ace.js"><link rel="prefetch" href="/assets/js/28.feda35ac.js"><link rel="prefetch" href="/assets/js/280.0cea46d1.js"><link rel="prefetch" href="/assets/js/281.5e41af15.js"><link rel="prefetch" href="/assets/js/282.fd739ffe.js"><link rel="prefetch" href="/assets/js/283.6d7654c5.js"><link rel="prefetch" href="/assets/js/284.aed2f5bb.js"><link rel="prefetch" href="/assets/js/285.03d862be.js"><link rel="prefetch" href="/assets/js/286.461c367a.js"><link rel="prefetch" href="/assets/js/287.8131719d.js"><link rel="prefetch" href="/assets/js/288.0d32bdba.js"><link rel="prefetch" href="/assets/js/289.79c15cda.js"><link rel="prefetch" href="/assets/js/29.673fd9ed.js"><link rel="prefetch" href="/assets/js/290.3093b965.js"><link rel="prefetch" href="/assets/js/291.176af5aa.js"><link rel="prefetch" href="/assets/js/292.1d9885ec.js"><link rel="prefetch" href="/assets/js/293.e4b0c8bd.js"><link rel="prefetch" href="/assets/js/294.417f1688.js"><link rel="prefetch" href="/assets/js/295.47bd8e22.js"><link rel="prefetch" href="/assets/js/296.3f07af38.js"><link rel="prefetch" href="/assets/js/297.f858c893.js"><link rel="prefetch" href="/assets/js/298.7b33449b.js"><link rel="prefetch" href="/assets/js/299.dd9d8527.js"><link rel="prefetch" href="/assets/js/3.1e3d1620.js"><link rel="prefetch" href="/assets/js/30.38fc703e.js"><link rel="prefetch" href="/assets/js/300.85240255.js"><link rel="prefetch" href="/assets/js/301.c6a5f9c8.js"><link rel="prefetch" href="/assets/js/302.ea412e24.js"><link rel="prefetch" href="/assets/js/303.380a9459.js"><link rel="prefetch" href="/assets/js/304.b63da2ff.js"><link rel="prefetch" href="/assets/js/305.6c3a2ee4.js"><link rel="prefetch" href="/assets/js/306.b9480447.js"><link rel="prefetch" href="/assets/js/307.aff5a14c.js"><link rel="prefetch" href="/assets/js/308.9e3be265.js"><link rel="prefetch" href="/assets/js/309.7f29f195.js"><link rel="prefetch" href="/assets/js/31.54473c58.js"><link rel="prefetch" href="/assets/js/310.6fe212fd.js"><link rel="prefetch" href="/assets/js/311.49325b3e.js"><link rel="prefetch" href="/assets/js/312.2ea0ab56.js"><link rel="prefetch" href="/assets/js/313.6c022f7d.js"><link rel="prefetch" href="/assets/js/314.375b1ab0.js"><link rel="prefetch" href="/assets/js/315.84e706be.js"><link rel="prefetch" href="/assets/js/316.e2a55273.js"><link rel="prefetch" href="/assets/js/317.92a6f201.js"><link rel="prefetch" href="/assets/js/318.f7f5dd19.js"><link rel="prefetch" href="/assets/js/319.15578211.js"><link rel="prefetch" href="/assets/js/32.292dd67c.js"><link rel="prefetch" href="/assets/js/320.cbe79dfd.js"><link rel="prefetch" href="/assets/js/321.e6735ef2.js"><link rel="prefetch" href="/assets/js/322.c0e7640f.js"><link rel="prefetch" href="/assets/js/323.3d9881d1.js"><link rel="prefetch" href="/assets/js/324.f076f869.js"><link rel="prefetch" href="/assets/js/325.a1857a7e.js"><link rel="prefetch" href="/assets/js/326.cad3e1d5.js"><link rel="prefetch" href="/assets/js/327.42179a0b.js"><link rel="prefetch" href="/assets/js/328.d6f540db.js"><link rel="prefetch" href="/assets/js/329.69b6c587.js"><link rel="prefetch" href="/assets/js/33.ea19fe02.js"><link rel="prefetch" href="/assets/js/330.de01fa8c.js"><link rel="prefetch" href="/assets/js/331.e454a860.js"><link rel="prefetch" href="/assets/js/332.4431fb51.js"><link rel="prefetch" href="/assets/js/333.ad4b095a.js"><link rel="prefetch" href="/assets/js/34.e2639cc6.js"><link rel="prefetch" href="/assets/js/35.d69925bb.js"><link rel="prefetch" href="/assets/js/36.4b4991e7.js"><link rel="prefetch" href="/assets/js/37.8b7dc39a.js"><link rel="prefetch" href="/assets/js/38.128f1778.js"><link rel="prefetch" href="/assets/js/39.b5d9cb9c.js"><link rel="prefetch" href="/assets/js/4.afea0107.js"><link rel="prefetch" href="/assets/js/40.6fdd0fa1.js"><link rel="prefetch" href="/assets/js/41.a9444389.js"><link rel="prefetch" href="/assets/js/42.9a4ecc39.js"><link rel="prefetch" href="/assets/js/43.4cd70a57.js"><link rel="prefetch" href="/assets/js/44.db096bf3.js"><link rel="prefetch" href="/assets/js/45.7db040b5.js"><link rel="prefetch" href="/assets/js/46.c5b4f033.js"><link rel="prefetch" href="/assets/js/47.6d5c895a.js"><link rel="prefetch" href="/assets/js/48.f31fffea.js"><link rel="prefetch" href="/assets/js/49.93f011d4.js"><link rel="prefetch" href="/assets/js/5.332429b6.js"><link rel="prefetch" href="/assets/js/50.a3a1de62.js"><link rel="prefetch" href="/assets/js/51.4a7aee2a.js"><link rel="prefetch" href="/assets/js/52.83230544.js"><link rel="prefetch" href="/assets/js/53.6641d85f.js"><link rel="prefetch" href="/assets/js/54.f495d2da.js"><link rel="prefetch" href="/assets/js/55.eb27d241.js"><link rel="prefetch" href="/assets/js/56.911e1dff.js"><link rel="prefetch" href="/assets/js/57.de691f0a.js"><link rel="prefetch" href="/assets/js/58.d09c2745.js"><link rel="prefetch" href="/assets/js/59.7fa24dc9.js"><link rel="prefetch" href="/assets/js/6.b2e2c0cc.js"><link rel="prefetch" href="/assets/js/60.e68ff9aa.js"><link rel="prefetch" href="/assets/js/61.d1dd1566.js"><link rel="prefetch" href="/assets/js/62.123fdc80.js"><link rel="prefetch" href="/assets/js/63.52a5ab4d.js"><link rel="prefetch" href="/assets/js/64.7bb1216a.js"><link rel="prefetch" href="/assets/js/65.31b0230d.js"><link rel="prefetch" href="/assets/js/66.465875e4.js"><link rel="prefetch" href="/assets/js/67.83b0efa1.js"><link rel="prefetch" href="/assets/js/68.60d03013.js"><link rel="prefetch" href="/assets/js/69.e0430d9d.js"><link rel="prefetch" href="/assets/js/7.d0762461.js"><link rel="prefetch" href="/assets/js/70.1b205099.js"><link rel="prefetch" href="/assets/js/72.aa8359cc.js"><link rel="prefetch" href="/assets/js/73.4f39bf66.js"><link rel="prefetch" href="/assets/js/74.730255b7.js"><link rel="prefetch" href="/assets/js/75.cb533b47.js"><link rel="prefetch" href="/assets/js/76.86045c1a.js"><link rel="prefetch" href="/assets/js/77.da075ad2.js"><link rel="prefetch" href="/assets/js/78.8926c2a3.js"><link rel="prefetch" href="/assets/js/79.21745c9b.js"><link rel="prefetch" href="/assets/js/8.a6e04fe3.js"><link rel="prefetch" href="/assets/js/80.37c038ef.js"><link rel="prefetch" href="/assets/js/81.7da6fd05.js"><link rel="prefetch" href="/assets/js/82.eabc71e8.js"><link rel="prefetch" href="/assets/js/83.f56d1848.js"><link rel="prefetch" href="/assets/js/84.e5b22a36.js"><link rel="prefetch" href="/assets/js/85.5abf1dff.js"><link rel="prefetch" href="/assets/js/86.a0661d92.js"><link rel="prefetch" href="/assets/js/87.b0d7b9ef.js"><link rel="prefetch" href="/assets/js/88.dd3d4ec5.js"><link rel="prefetch" href="/assets/js/89.5a66c7dc.js"><link rel="prefetch" href="/assets/js/9.9ffe3771.js"><link rel="prefetch" href="/assets/js/90.e06255de.js"><link rel="prefetch" href="/assets/js/91.3d0c8323.js"><link rel="prefetch" href="/assets/js/92.eec33077.js"><link rel="prefetch" href="/assets/js/93.0bae6840.js"><link rel="prefetch" href="/assets/js/94.08ed03d5.js"><link rel="prefetch" href="/assets/js/95.eb699b63.js"><link rel="prefetch" href="/assets/js/96.42113455.js"><link rel="prefetch" href="/assets/js/97.fe782e11.js"><link rel="prefetch" href="/assets/js/98.dc147f7c.js"><link rel="prefetch" href="/assets/js/99.da966128.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2d4b740c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YuweiYin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></li><li class="dropdown-item"><!----> <a href="/article/physics/" class="nav-link">
  物理宇宙
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/" class="nav-link router-link-active">
  信息技术
</a></li><li class="dropdown-item"><!----> <a href="/article/essay/" class="nav-link">
  见闻随笔
</a></li><li class="dropdown-item"><!----> <a href="/article/other/" class="nav-link">
  其它系列
</a></li><li class="dropdown-item"><!----> <a href="/article/reprint/" class="nav-link">
  转载文章
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></li><li class="dropdown-item"><!----> <a href="/article/physics/" class="nav-link">
  物理宇宙
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/" class="nav-link router-link-active">
  信息技术
</a></li><li class="dropdown-item"><!----> <a href="/article/essay/" class="nav-link">
  见闻随笔
</a></li><li class="dropdown-item"><!----> <a href="/article/other/" class="nav-link">
  其它系列
</a></li><li class="dropdown-item"><!----> <a href="/article/reprint/" class="nav-link">
  转载文章
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/article/info-technology/" class="sidebar-link">Information Technology</a></li><li><a href="/article/info-technology/computer-science/" class="sidebar-link">Computer Science</a></li><li><a href="/article/info-technology/algorithm/" class="sidebar-link">Algorithm</a></li><li><a href="/article/info-technology/artificial-intelligence/" class="sidebar-link">Artificial Intelligence</a></li><li><a href="/article/info-technology/web-crawler/" class="sidebar-link">Web Crawler</a></li><li><a href="/article/info-technology/web-frontend/" class="sidebar-link">Web Frontend</a></li><li><a href="/article/info-technology/web-backend/" class="sidebar-link">Web Backend</a></li><li><a href="/article/info-technology/web-security/" class="sidebar-link">Web Security</a></li><li><a href="/article/info-technology/system-management/" class="sidebar-link">System Management</a></li><li><a href="/article/info-technology/paper-notes/" class="sidebar-link">Paper Notes</a></li><li><a href="/article/info-technology/other/" class="sidebar-link">Other</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="algorithm-computational-geometry"><a href="#algorithm-computational-geometry" class="header-anchor">#</a> Algorithm - Computational Geometry</h1> <p>By <a href="https://yuweiyin.github.io/" target="_blank" rel="noopener noreferrer">YuweiYin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <ul><li>计算几何学 Computational Geometry
<ul><li>线段的性质</li> <li>确定任意一对线段是否相交</li> <li>寻找凸包</li> <li>寻找最近点对</li></ul></li></ul> <h2 id="_0-计算几何学"><a href="#_0-计算几何学" class="header-anchor">#</a> 0. 计算几何学</h2> <p>计算几何学是计算机科学的一个分支，专门研究那些用来解决<strong>几何问题</strong>的算法。在现代工程与数学界，计算几何学在不同的领域里有着广泛的应用，包括计算机图形学、机器人学、VLSI 电路设计、计算机辅助设计、分子建模、冶金学、制造业、纺织品设计学、林学和统计学等。计算几何学问题的<strong>输入</strong>通常是<strong>对几何对象集合的描述</strong>，如点集、线段集，或者一个多边形中按顺/逆时针顺序排列的顶点集合。而问题的<strong>输出</strong>通常是回答<strong>关于这些几何对象的查询</strong>，例如，<strong>直线是否相交</strong>；或者是否为一个新的几何对象，例如，点集的<strong>凸包问题</strong> (convex hull，即最小封闭凸多边形)。</p> <p>这里将研究<strong>欧式二维空间</strong>内(即平面上)的若干个计算几何算法。用点集 {p1, p2, p3, ...} 来表示每一个数输入对象，其中每个 pi = {xi, yi}, 且 $ xi, yi \in R $。例如，以顶点序列 <code>&lt;p_0, p_1, p_2, ..., p_{n-1}&gt;</code> 来表示一个含有 n 个顶点的多边形 P (polygon)，这些点以在 P 的边界上出现的顺序来排列。</p> <p>计算几何学也可以应用到三维，甚至更高维度的空间上，不过这样的问题及其解决方案较难可视化。而且 即便是在二维空间上，也能够充分展现计算几何学的精妙之处。</p> <h2 id="_1-线段的性质"><a href="#_1-线段的性质" class="header-anchor">#</a> 1. 线段的性质</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-1.png" alt="computational-geometry-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-2.png" alt="computational-geometry-2"></p> <h3 id="_1-1-叉积"><a href="#_1-1-叉积" class="header-anchor">#</a> 1.1. 叉积</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-3.png" alt="computational-geometry-3"></p> <p>事实上，二维向量的<strong>叉积</strong>是一个三维的概念。根据“右手法则”，它是一个与 p1 和 p2 都垂直的向量，其量值为 <code>| x1 y2 - x2 y1 |</code>。在这里，不考虑叉积作为一个向量的方向性，而仅考虑其模长。</p> <h3 id="_1-2-确定连续线段是向左转还是向右转"><a href="#_1-2-确定连续线段是向左转还是向右转" class="header-anchor">#</a> 1.2. 确定连续线段是向左转还是向右转</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-4.png" alt="computational-geometry-4"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-5.png" alt="computational-geometry-5"></p> <h3 id="_1-3-判定两条线段是否相交"><a href="#_1-3-判定两条线段是否相交" class="header-anchor">#</a> 1.3. 判定两条线段是否相交</h3> <p>为判定两条线段是否相交，需要检查每条线段是否<strong>跨越</strong>了包含另一条线段的直线。如果点 p1 位于某条直线的一边，而点 p2 位于该直线的另一边，则称线段 p1p2 跨越了这条直线。若 p1 或 p2 恰好落在直线上，则出现边界情况。两条线段相交当且仅当下面两个条件<strong>至少成立一个</strong>：</p> <ol><li>对于这两条线段，其中的每条线段都<strong>跨越</strong>了包含另一条线段的直线。</li> <li>一条线段的某个端点落在另一条线段上。（边界情况）</li></ol> <p>下面的过程实现了上述思想。如果线段 p1p2 和 p3p4 相交，那么 <code>SEGMENTS_INTERSECT</code> 返回 True，否则返回 False。它调用了子过程 <code>DIRECTION</code>，利用上述的叉积方法计算出线段的相应方向；另外还调用了子过程 <code>ON_SEGMENT</code> 来判断一个与线段共线的点 是否位于这条线段上（包含线段的端点）。</p> <div class="language- extra-class"><pre class="language-text"><code>SEGMENTS_INTERSECT(p1, p2, p3, p4)
1  d_1 = DIRECTION(p3, p4, p1)
2  d_2 = DIRECTION(p3, p4, p2)
3  d_3 = DIRECTION(p1, p2, p3)
4  d_4 = DIRECTION(p1, p2, p4)
5  if ((d_1 &gt; 0 and d_2 &lt; 0) or (d_1 &lt; 0 and d_2 &gt; 0) and
       (d_3 &gt; 0 and d_4 &lt; 0) or (d_3 &lt; 0 and d_4 &gt; 0))
6      return True
7  elif d_1 == 0 and ON_SEGMENT(p3, p4, p1)
8      return True
9  elif d_2 == 0 and ON_SEGMENT(p3, p4, p2)
10     return True
11 elif d_3 == 0 and ON_SEGMENT(p1, p2, p3)
12     return True
13 elif d_4 == 0 and ON_SEGMENT(p1, p2, p4)
14     return True
15 else
16     return False
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>DIRECTION(pi, pj, pk)
1  return (pk - pi) * (pj - pi)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>ON_SEGMENT(pi, pj, pk)
1  if min(xi, xj) &lt;= xk &lt;= max(xi, xj) and
       min(yi, yj) &lt;= yk &lt;= max(yi, yj)
2      return True
3  else
4      return False
</code></pre></div><p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-6.png" alt="computational-geometry-6"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-7.png" alt="computational-geometry-7"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-8.png" alt="computational-geometry-8"></p> <h3 id="_1-4-叉积的其它应用"><a href="#_1-4-叉积的其它应用" class="header-anchor">#</a> 1.4. 叉积的其它应用</h3> <p>当需要根据相对于给定原点的极角大小 对给定的点集进行排序时，可以使用叉积进行排序过程中的比较。另外，可以用红黑树来维护一个线段集合的垂直顺序。并不是显式地记录红黑树关键字值，而是通过计算叉积来确定 与同一个给定的垂直线相交的两条线段的相对位置。</p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-9.png" alt="computational-geometry-9"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-10.png" alt="computational-geometry-10"></p> <h2 id="_2-确定任意一对线段是否相交"><a href="#_2-确定任意一对线段是否相交" class="header-anchor">#</a> 2. 确定任意一对线段是否相交</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-1.png" alt="segment-intersect-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-2.png" alt="segment-intersect-2"></p> <h3 id="_2-1-线段排序"><a href="#_2-1-线段排序" class="header-anchor">#</a> 2.1. 线段排序</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-3.png" alt="segment-intersect-3"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-4.png" alt="segment-intersect-4"></p> <h3 id="_2-2-移动扫除线"><a href="#_2-2-移动扫除线" class="header-anchor">#</a> 2.2. 移动扫除线</h3> <p>典型的扫除 Sweeping 算法需要维护如下两组数据：</p> <ol><li><strong>扫除线状态</strong> (sweep-line status) 给出了与扫除线相交的物体之间的关系。</li> <li><strong>事件点调度</strong> (event-point schedule) 是一个按 x 坐标从左到右排列的事件点序列。随着扫除线从左到右行进，每当遇到事件点的 x 坐标时，扫除都会暂停 并处理该事件点，然后重新开始扫除。扫除线状态仅在事件点处改变。</li></ol> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-5.png" alt="segment-intersect-5"></p> <h3 id="_2-3-求线段交点的伪代码"><a href="#_2-3-求线段交点的伪代码" class="header-anchor">#</a> 2.3. 求线段交点的伪代码</h3> <p>下面的算法将一个由 n 条线段组成的集合 S 作为输入，如果 S 中存在一对线段相交，则返回 True，否则返回 False。完全前序 T 由一棵<a href="../../data-structure/red-black-tree">红黑树</a>来维护。</p> <div class="language- extra-class"><pre class="language-text"><code>ANY_SEGMENTS_INTERSECT(S)
1  T = \emptyset
2  sort the endpoints of the segments in S from left to right,
       breaking ties by putting left endpoints before right endpoints
       and breaking further ties by putting points with lower y-coordinates first
3  for each point p in the sorted list of endpoints
4      if p is the left endpoint of a segment s
5          INSERT(T, s)
6          if (ABOVE(T, s) exists and intersects s)
               or (BELOW(T, s) exists and intersects s)
7              return True
8      if p is the right endpoint of a segment s
9          if both ABOVE(T, s) and BELOW(T, s) exist
               and ABOVE(T, s) intersects BELOW(T, s)
10             return True
11         DELETE(T, s)
12 return False
</code></pre></div><p>下图 33-5 说明了此算法的执行过程。</p> <ol><li>第 1 行，初始化完全前序(扩展红黑树的动态集合) T 为空</li> <li>第 2 行，将 2n 个线段端点 由左到右排序，并按照前述方法处理多个点 x 坐标值相同的情况，从而确定事件点的调度次序。
<ul><li>执行第 2 行的一种方式是，在 (x, e, y) 上对端点按照字典序排序，其中 x 和 y 为通常对坐标，而 e = 0 表示左端点、e = 1 表示右端点。</li></ul></li> <li>在第 3～11 行的 for 循环中，每一次迭代都处理一个事件点 p。
<ul><li>如果事件点 p 是某线段 s 的左端点，那么第 5 行将 s 添加到完全前序 T 中。
<ul><li>如果 s 与(由经过 p 的扫除线所定义的)完全前序中的(与之连续的)两条连续线段 中的任一条相交，则第 6～7 行返回 True，表示存在相交的线段。</li> <li>如果 p 位于另一条线段 s' 上，则出现边界情况。此时，仅需要将 s 和 s' 连续地放入 T 中。</li></ul></li> <li>如果事件点 p 是某线段 s 的右端点，那么第 11 行会将 s 从完全前序 T 中删除。
<ul><li>考虑经过 p 的扫除线所定义的完全前序，如果 s 旁边(ABOVE 或者 BELOW)的线段有相交，那么第 9～10 行返回 True。</li> <li>如果这些线段不相交，则第 11 行就将 s 从完全前序 T 中删除。</li> <li>只要第 10 行的 return 语句没有阻碍第 11 行的执行，那么当 s 被删除后，s 旁边的线段就会在完全前序中变为连续。</li></ul></li></ul></li> <li>最后，如果在处理完全部 2n 个事件点后没发现存在线段相交，第 12 行就返回 False。</li></ol> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-6.png" alt="segment-intersect-6"></p> <h3 id="_2-4-求线段交点算法的正确性"><a href="#_2-4-求线段交点算法的正确性" class="header-anchor">#</a> 2.4. 求线段交点算法的正确性</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-7.png" alt="segment-intersect-7"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-8.png" alt="segment-intersect-8"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-9.png" alt="segment-intersect-9"></p> <h3 id="_2-5-求线段交点算法的运行时间"><a href="#_2-5-求线段交点算法的运行时间" class="header-anchor">#</a> 2.5. 求线段交点算法的运行时间</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-10.png" alt="segment-intersect-10"></p> <h3 id="_2-6-其它线段相交相关问题与性质"><a href="#_2-6-其它线段相交相关问题与性质" class="header-anchor">#</a> 2.6. 其它线段相交相关问题与性质</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-11.png" alt="segment-intersect-11"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-12.png" alt="segment-intersect-12"></p> <h2 id="_3-寻找凸包"><a href="#_3-寻找凸包" class="header-anchor">#</a> 3. 寻找凸包</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-1.png" alt="convex-hull-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-2.png" alt="convex-hull-2"></p> <p>因此，通过在 O(n log n) 时间内计算出 n 个输入点的凸包，然后再找出得到的凸多边形中的最远顶点对，就可以在 O(n log n) 时间内 找出任意 n 个点组成的集合中<strong>距离最远的点对</strong>。</p> <h3 id="_3-1-graham-扫描法"><a href="#_3-1-graham-扫描法" class="header-anchor">#</a> 3.1. Graham 扫描法</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-3.png" alt="convex-hull-3"></p> <div class="language- extra-class"><pre class="language-text"><code>GRAHAM_SCAN(Q)
1  let p_0 be the point in Q with the minimum y-coordinate,
       or the leftmost such point in case of a tie
2  let &lt;p_1, p_2, ..., p_m&gt; be the remaining points in Q,
       sorted by polar angle in counterclockwise order around p_0
       (if more than one point has the same angle, remove all but
       	the one that is farthest from p_0)
3  if m &lt; 2
4      return &quot;convex hull is empty&quot;
5  else
6      let S be an empty stack
7      PUSH(p_0, S)
8      PUSH(p_1, S)
9      PUSH(p_2, S)
10     for i = 3 to m
11         while the angle formed by points NEXT_TO_TOP(S), TOP(S), 
               and p_i makes a nonleft turn
12             POP(S)
13         PUSH(p_i, S)
14 return S
</code></pre></div><p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-4.png" alt="convex-hull-4"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-5.png" alt="convex-hull-5"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-6.png" alt="convex-hull-6"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-7.png" alt="convex-hull-7"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-8.png" alt="convex-hull-8"></p> <h3 id="_3-2-jarvis-步进法"><a href="#_3-2-jarvis-步进法" class="header-anchor">#</a> 3.2. Jarvis 步进法</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-9.png" alt="convex-hull-9"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-10.png" alt="convex-hull-10"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-11.png" alt="convex-hull-11"></p> <h3 id="_3-3-其它点集凸包相关问题与性质"><a href="#_3-3-其它点集凸包相关问题与性质" class="header-anchor">#</a> 3.3. 其它点集凸包相关问题与性质</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-12.png" alt="convex-hull-12"></p> <h2 id="_4-寻找最近点对"><a href="#_4-寻找最近点对" class="header-anchor">#</a> 4. 寻找最近点对</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-1.png" alt="nearest-pair-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-2.png" alt="nearest-pair-2"></p> <h3 id="_4-1-分治算法"><a href="#_4-1-分治算法" class="header-anchor">#</a> 4.1. 分治算法</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-3.png" alt="nearest-pair-3"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-4.png" alt="nearest-pair-4"></p> <h3 id="_4-2-算法的正确性"><a href="#_4-2-算法的正确性" class="header-anchor">#</a> 4.2. 算法的正确性</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-5.png" alt="nearest-pair-5"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-6.png" alt="nearest-pair-6"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-7.png" alt="nearest-pair-7"></p> <h3 id="_4-3-算法的实现与运行时间分析"><a href="#_4-3-算法的实现与运行时间分析" class="header-anchor">#</a> 4.3. 算法的实现与运行时间分析</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-8.png" alt="nearest-pair-8"></p> <div class="language- extra-class"><pre class="language-text"><code>1  let Y_L[1..Y.length] and Y_R[1..Y.length] be new arrays
2  Y_L.length = Y_R.length = 0
3  for i = 1 to Y.length
4      if Y[i] \in P_L
5          Y_L.length = Y_L.length + 1
6          Y_L[Y_L.length] = Y[i]
7      else
8          Y_R.length = Y_R.length + 1
9          Y_R[Y_R.length] = Y[i]
</code></pre></div><p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-9.png" alt="nearest-pair-9"></p> <h3 id="_4-4-其它最近点对相关问题与性质"><a href="#_4-4-其它最近点对相关问题与性质" class="header-anchor">#</a> 4.4. 其它最近点对相关问题与性质</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-10.png" alt="nearest-pair-10"></p> <h2 id="_5-其它计算几何学相关问题"><a href="#_5-其它计算几何学相关问题" class="header-anchor">#</a> 5. 其它计算几何学相关问题</h2> <h3 id="_5-1-凸层"><a href="#_5-1-凸层" class="header-anchor">#</a> 5.1. 凸层</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-1.png" alt="cg-other-questions-1"></p> <h3 id="_5-2-最大层"><a href="#_5-2-最大层" class="header-anchor">#</a> 5.2. 最大层</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-2.png" alt="cg-other-questions-2"></p> <h3 id="_5-3-巨人和鬼问题"><a href="#_5-3-巨人和鬼问题" class="header-anchor">#</a> 5.3. 巨人和鬼问题</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-3.png" alt="cg-other-questions-3"></p> <h3 id="_5-4-拾取棍子问题"><a href="#_5-4-拾取棍子问题" class="header-anchor">#</a> 5.4. 拾取棍子问题</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-4.png" alt="cg-other-questions-4"></p> <h3 id="_5-5-稀疏包分布"><a href="#_5-5-稀疏包分布" class="header-anchor">#</a> 5.5. 稀疏包分布</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-5.png" alt="cg-other-questions-5"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-6.png" alt="cg-other-questions-6"></p> <h2 id="代码范例"><a href="#代码范例" class="header-anchor">#</a> 代码范例</h2> <h3 id="python"><a href="#python" class="header-anchor">#</a> Python</h3> <p>Python 环境：Python 3.7</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment">#!/usr/bin/env python</span>
<span class="token comment"># -*- coding:utf-8 -*-</span>
<span class="token triple-quoted-string string">&quot;&quot;&quot;=================================================
@Project : algorithm/other-topics/computational-geometry
@File    : computational-geometry.py
@Author  : YuweiYin
@Date    : 2020-06-13
==================================================&quot;&quot;&quot;</span>

<span class="token keyword">import</span> sys
<span class="token keyword">import</span> time

<span class="token triple-quoted-string string">&quot;&quot;&quot;
- 计算几何学 Computational Geometry
    - (欧几里得空间)点和线段的构造
    - 给定两条线段，判断二者是否相交
    - 给定线段集合，判断其中是否存在相交线段
    - 给定点集，寻找该点集的凸包 convex hull
        - (可利用凸包求出该点集的最远点对)
    - 给定点集，寻找最近点对

参考资料：
Introduction to Algorithm (aka CLRS) Third Edition - Chapter 33
&quot;&quot;&quot;</span>


<span class="token comment"># (欧几里得空间)点结构体, 单点也可视作为向量 p_0 -&gt; p 其中 p_0 表示坐标系原点</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>vec <span class="token operator">=</span> vec  <span class="token comment"># 坐标(coordinate): dim 长度的列表</span>
        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim  <span class="token comment"># 维度，默认维度为 2-平面几何</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key  <span class="token comment"># 关键字</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val  <span class="token comment"># 值对象</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'key:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tval:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\tdim:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tvec:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>vec<span class="token punctuation">)</span>


<span class="token comment"># (欧几里得空间)线段结构体</span>
<span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> from_point<span class="token punctuation">,</span> to_point<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> is_directed<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>from_point <span class="token operator">=</span> from_point    <span class="token comment"># 线段的起点</span>
        self<span class="token punctuation">.</span>to_point <span class="token operator">=</span> to_point        <span class="token comment"># 线段的终点</span>
        self<span class="token punctuation">.</span>is_directed <span class="token operator">=</span> is_directed  <span class="token comment"># True 表示此线段是有向线段，否则为无向线段</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key  <span class="token comment"># 关键字</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val  <span class="token comment"># 值对象</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'key:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tval:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tis_directed:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>is_directed<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\nfrom:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>from_point<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\nto:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>to_point<span class="token punctuation">)</span>


<span class="token comment"># 线段端点结构体</span>
<span class="token keyword">class</span> <span class="token class-name">Endpoint</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> point<span class="token punctuation">,</span> seg<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key  <span class="token comment"># 关键字</span>
        self<span class="token punctuation">.</span>point <span class="token operator">=</span> point  <span class="token comment"># 此端点对应的点 Point 结构体</span>
        self<span class="token punctuation">.</span>seg <span class="token operator">=</span> seg  <span class="token comment"># 此端点所属的线段 Segment 结构体</span>
        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim  <span class="token comment"># 维度，默认维度为 2-平面几何</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'key:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tdim:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\npoint:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>point<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\nseg:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>seg<span class="token punctuation">)</span>


<span class="token comment"># (欧几里得空间)计算几何学算法</span>
<span class="token keyword">class</span> <span class="token class-name">ComputationalGeometry</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim  <span class="token comment"># 当前处理的欧氏空间维度，默认为 2-平面几何</span>

    <span class="token comment"># 对于两个向量，逐元素地操作 (例如：加减乘除等)</span>
    <span class="token comment"># func 须是 lambda 表达式。默认为加法</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">vector_operation_by_ele</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        res_vec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res_vec<span class="token punctuation">.</span>append<span class="token punctuation">(</span>func<span class="token punctuation">(</span>vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res_vec

    <span class="token comment"># 计算两向量(列表)的内积/点积</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">inner_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token comment"># 对应位置相乘 再求和</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res <span class="token operator">+=</span> vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res

    <span class="token comment"># 计算两向量(列表)的叉积</span>
    <span class="token comment"># 这里只考虑维度为 2 或者 3 的情况</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token keyword">if</span> dim <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token comment"># 对二维向量 a = &lt;a_0, a_1&gt; 和 b = &lt;b_0, b_1&gt; 而言，返回(可正可负可零的)数值</span>
            <span class="token comment"># a x b = |a|·|b|·sin&lt;a, b&gt; 或者 a x b = det{{a_0, a_1}, {b_0, b_1}} 行列式值</span>
            <span class="token comment"># 如果该数值为正，则表示两向量夹角(不考虑周期)属于开区间 (0, \pi)</span>
            <span class="token comment"># 如果该数值为负，则表示两向量夹角(不考虑周期)属于开区间 (\pi, 2 \pi)</span>
            <span class="token comment"># 如果该数值为零，则表示两向量夹角(不考虑周期)要么是 0 要么是 \pi，故两向量共线</span>
            <span class="token keyword">return</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">elif</span> dim <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token comment"># 对三维向量 a = &lt;a_0, a_1, a_2&gt; 和 b = &lt;b_0, b_1, b_2&gt; 而言，返回三维向量</span>
            <span class="token comment"># a x b = det{{i, j, k}, {a_0, a_1, a_2}, {b_0, b_1, b_2}} 行列式值</span>
            <span class="token comment"># 上式中的 i, j, k 分别为 x, y, z 轴方向的单位向量</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cross_product: 维度不为 2 或者 3'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># (二维欧氏空间中)给定线段 Segment 结构体 seg，以及 x 坐标，获得该点的 y 坐标</span>
    <span class="token comment"># 如果 x 坐标越出 seg 范围，则返回 None</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">segment_x2y</span><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 先根据 Segment 结构体获取其两个端点的 Point 结构体</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
        p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg<span class="token punctuation">.</span>to_point
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token comment"># 确定 x 坐标是否越界</span>
        <span class="token keyword">if</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> x <span class="token operator">&lt;=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 若线段垂直于 x 轴，则返回其低端点的 y 值</span>
            <span class="token keyword">if</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 否则根据平面几何公式计算 y 值</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                slope <span class="token operator">=</span> <span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 斜率</span>
                <span class="token keyword">return</span> slope <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 给定两条线段，判断二者是否相交</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token keyword">def</span> <span class="token function">segments_intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seg_1<span class="token punctuation">,</span> seg_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg_1<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg_2<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 获取两线段的四端点</span>
            p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_3<span class="token punctuation">,</span> p_4 <span class="token operator">=</span> seg_1<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg_1<span class="token punctuation">.</span>to_point<span class="token punctuation">,</span> seg_2<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg_2<span class="token punctuation">.</span>to_point
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_4<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token comment"># 判断转向</span>
            d_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_1<span class="token punctuation">)</span>
            d_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span>
            d_3 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_3<span class="token punctuation">)</span>
            d_4 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_4<span class="token punctuation">)</span>
            <span class="token comment"># 根据转向判断线段是否相交</span>
            <span class="token comment"># 如果 d_1 与 d_2 异号，表示从向量 p3p4 出发去往 p1 和 p2 是不同的转向，说明 p1 与 p2 分居线段 p3p4 的两侧</span>
            <span class="token comment"># 同理，如果 d_3 与 d_4 异号，说明 p3 与 p4 分居线段 p1p2 的两侧</span>
            <span class="token comment"># 上述两点同时满足的话，两线段必相交</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>d_1 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span> d_2 <span class="token keyword">or</span> d_1 <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&gt;</span> d_2<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>d_3 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span> d_4 <span class="token keyword">or</span> d_3 <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&gt;</span> d_4<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 如果 d_1 == 0，表示 p1 与线段 p3p4 共线</span>
            <span class="token comment"># 此时判断 p1 是否落在线段 p3p4 内，若是，则两线段至少有交点 p1。下同</span>
            <span class="token keyword">elif</span> d_1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_1<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> d_2 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> d_3 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_3<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> d_4 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_4<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 其它情况下，两线段不相交</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的线段参数不合法'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token comment"># 在二维空间中，对于首尾相接的两条有向线段 p0p1 和 p1p2</span>
    <span class="token comment"># 以 p0p1 的方向看过去，判断 p1p2 是向左 还是向右 还是不转向</span>
    <span class="token comment"># 只需计算 (p2 - p0) 和 (p1 - p0) 的叉积</span>
    <span class="token comment"># 如果结果为正值，表示向量 p0p2 在 p0p1 的顺时针方法，故在 p1 处需右转</span>
    <span class="token comment"># 如果结果为负值，表示向量 p0p2 在 p0p1 的逆时针方法，故在 p1 处需左转</span>
    <span class="token comment"># 如果结果为零，表示向量 p0p2 与 p0p1 共线，故在 p1 处不变方向 (或者反转 180 度)</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token keyword">def</span> <span class="token function">direction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> p_0<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>  <span class="token comment"># 仅考虑二维欧氏空间</span>
        vec_02 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        vec_01 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>vec_02<span class="token punctuation">,</span> vec_01<span class="token punctuation">)</span>

    <span class="token comment"># 假定点 p2 已经与线段 p0p1 共线</span>
    <span class="token comment"># 判断点 p2 是否位于线段 p0p1 上 (包含线段的端点)</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">on_segment</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> p_0<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>  <span class="token comment"># 仅考虑二维欧氏空间</span>
        <span class="token comment"># 仅需进行区间判断</span>
        <span class="token keyword">if</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">and</span> \
                <span class="token builtin">min</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token comment"># 给定线段集合 seg_list，确定其中是否存在相交线段</span>
    <span class="token comment"># 时间复杂度：O(n log n)</span>
    <span class="token keyword">def</span> <span class="token function">any_segments_intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seg_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 1. 初始化完全前序(扩展红黑树的动态集合) T 为空</span>
        seg_rbt <span class="token operator">=</span> SegmentRedBlackTree<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 2. 将 2n 个线段端点 由左到右排序，若多个点 x 坐标值相同，则优先取 y 值低的，从而确定事件点的调度次序</span>
        <span class="token comment"># 	 排序方式：以 (x, e, y) 作为多级关键字 进行排序，其中 x 和 y 为通常对坐标，而 e = 0 表示左端点、e = 1 表示右端点</span>
        <span class="token comment">#    如果某线段是竖直(垂直于时间轴)的，则将其底部端点当作左端点、顶部端点当作右端点即可</span>
        endpoint_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 先封装这 2n 个端点为 Endpoint 结构体，再进行排序。关键字 key 为元组 (x, e, y)</span>
        <span class="token keyword">for</span> seg <span class="token keyword">in</span> seg_list<span class="token punctuation">:</span>
            <span class="token comment"># 先根据 Segment 结构体获取其两个端点的 Point 结构体</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
            <span class="token comment"># 根据 (x, e, y) 多级关键字 顺序，将左端点设置为 seg.from_point、右端点设置为 seg.to_point</span>
            <span class="token comment"># 方便调用 self.direction、利用叉积来判断线段的次序</span>
            <span class="token keyword">if</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> seg<span class="token punctuation">.</span>to_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                temp <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point
                seg<span class="token punctuation">.</span>from_point <span class="token operator">=</span> seg<span class="token punctuation">.</span>to_point
                seg<span class="token punctuation">.</span>to_point <span class="token operator">=</span> temp
            <span class="token comment"># 若两端点的 x 坐标相同，表示此线段与 x (时间)轴垂直，则考虑 y 坐标</span>
            <span class="token comment"># 若两端点的 x、y 坐标均相同，则表示此线段退化成了一个点，则任取其一作为左端点均可</span>
            <span class="token keyword">elif</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> seg<span class="token punctuation">.</span>to_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 优先取 y 坐标较小的端点</span>
                <span class="token keyword">if</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> seg<span class="token punctuation">.</span>to_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    temp <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point
                    seg<span class="token punctuation">.</span>from_point <span class="token operator">=</span> seg<span class="token punctuation">.</span>to_point
                    seg<span class="token punctuation">.</span>to_point <span class="token operator">=</span> temp
            <span class="token comment"># 封装端点结构体</span>
            p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg<span class="token punctuation">.</span>to_point
            ep_1 <span class="token operator">=</span> Endpoint<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token operator">=</span>p_1<span class="token punctuation">,</span> seg<span class="token operator">=</span>seg<span class="token punctuation">)</span>
            ep_2 <span class="token operator">=</span> Endpoint<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token operator">=</span>p_2<span class="token punctuation">,</span> seg<span class="token operator">=</span>seg<span class="token punctuation">)</span>
            <span class="token comment"># 将当前线段的两端点封装好后，加入 endpoint_list 列表</span>
            endpoint_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ep_1<span class="token punctuation">)</span>
            endpoint_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ep_2<span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>sort_endpoints<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">)</span>

        <span class="token comment"># 3. 在 for 循环中，每一次迭代都处理一个(端点)事件点 ep</span>
        <span class="token keyword">for</span> ep <span class="token keyword">in</span> endpoint_list<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ep<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ep<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
            <span class="token comment"># 如果事件点 p 是某线段 s 的左端点，那么第 5 行将 s 添加到完全前序 T 中</span>
            <span class="token comment">#   如果 s 与(由经过 p 的扫除线所定义的)完全前序中的(与之连续的)两条连续线段 中的任一条相交，</span>
            <span class="token comment">#   则返回 True，表示存在相交的线段。</span>
            <span class="token comment">#   如果 p 位于另一条线段 s' 上，则出现边界情况。此时，仅需要将 s 和 s' 连续地放入 T 中</span>
            <span class="token keyword">if</span> ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token comment"># 将当前(线段)端点插入(红黑树)完全前序 T 中</span>
                seg_rbt<span class="token punctuation">.</span>rb_insert<span class="token punctuation">(</span>insert_ep<span class="token operator">=</span>ep<span class="token punctuation">)</span>
                <span class="token comment"># 获取当前端点对应线段的 TreeNode 树结点</span>
                <span class="token keyword">assert</span> ep<span class="token punctuation">.</span>seg <span class="token keyword">in</span> seg_rbt<span class="token punctuation">.</span>seg2node
                cur_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>seg2node<span class="token punctuation">[</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>cur_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token comment"># 如果前驱结点存在，判断两线段是否相交</span>
                above_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>above<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    above_seg <span class="token operator">=</span> above_node<span class="token punctuation">.</span>seg
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> above_seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type-1:'</span><span class="token punctuation">)</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'插入端点'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>point<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'时，线段'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'与其上方的线段'</span><span class="token punctuation">,</span> above_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'相交'</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
                <span class="token comment"># 如果后继结点存在，判断两线段是否相交</span>
                below_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>below<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    below_seg <span class="token operator">=</span> below_node<span class="token punctuation">.</span>seg
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> below_seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type-2:'</span><span class="token punctuation">)</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'插入端点'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>point<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'时，线段'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'与其下方的线段'</span><span class="token punctuation">,</span> below_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'相交'</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 如果事件点 p 是某线段 s 的右端点，那么会将 s 从完全前序 T 中删除</span>
            <span class="token comment">#   考虑经过 p 的扫除线所定义的完全前序，如果 s 旁边(ABOVE 或者 BELOW)的线段有相交，则返回 True</span>
            <span class="token comment">#   如果这些线段不相交，则第 11 行就将 s 从完全前序 T 中删除</span>
            <span class="token comment">#   当 s 被删除后，s 旁边的线段就会在完全前序中变为连续(即相邻)</span>
            <span class="token keyword">if</span> ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 获取当前端点对应线段的 TreeNode 树结点</span>
                <span class="token keyword">assert</span> ep<span class="token punctuation">.</span>seg <span class="token keyword">in</span> seg_rbt<span class="token punctuation">.</span>seg2node
                cur_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>seg2node<span class="token punctuation">[</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>cur_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token comment"># 如果前驱结点和后继结点均存在，且前驱和后继对应的线段相交，则返回 True</span>
                above_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>above<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                below_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>below<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span> <span class="token keyword">and</span> \
                        <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    above_seg <span class="token operator">=</span> above_node<span class="token punctuation">.</span>seg
                    below_seg <span class="token operator">=</span> below_node<span class="token punctuation">.</span>seg
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>above_seg<span class="token punctuation">,</span> below_seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type-3:'</span><span class="token punctuation">)</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'删除端点'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>point<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'时，线段'</span><span class="token punctuation">,</span> above_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'与其下方的线段'</span><span class="token punctuation">,</span> below_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'相交'</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
                <span class="token comment"># 将当前(线段)端点从(红黑树)完全前序 T 中删除</span>
                seg_rbt<span class="token punctuation">.</span>rb_delete<span class="token punctuation">(</span>seg_rbt<span class="token punctuation">.</span>bst<span class="token punctuation">,</span> delete_ep<span class="token operator">=</span>ep<span class="token punctuation">)</span>

        <span class="token comment"># 4. 最后，如果在处理完全部 2n 个事件点后没发现存在线段相交，则返回 False</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token comment"># 对端点集合进行二路归并排序</span>
    <span class="token keyword">def</span> <span class="token function">sort_endpoints</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> endpoint_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_merge_sort<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>endpoint_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment"># 归并排序</span>
    <span class="token keyword">def</span> <span class="token function">_merge_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 当待排序数组的左下标等于右下标时为基本情况：</span>
        <span class="token comment"># 该数组只有一个元素。这自然是已排好序的，无需处理</span>
        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>
            m <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 二路归并</span>
            self<span class="token punctuation">.</span>_merge_sort<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_merge_sort<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_merge<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span>

    <span class="token comment"># 合并</span>
    <span class="token comment"># 该过程假设子数组 endpoint_list[l..m] 和 endpoint_list[m+1..r] 都已排好序</span>
    <span class="token comment"># 合并上述两个子数组为一个排好序的较大数组 seg_list[l..r]</span>
    <span class="token comment"># 参数范围 l &lt;= m &lt; r</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">_merge</span><span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        len_sub1 <span class="token operator">=</span> m <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 左子数组的长度</span>
        len_sub2 <span class="token operator">=</span> r <span class="token operator">-</span> m      <span class="token comment"># 右子数组的长度</span>

        <span class="token comment"># 设置左辅助数组的前 len_sub1 项值为左子数组的值</span>
        aux_left <span class="token operator">=</span> endpoint_list<span class="token punctuation">[</span>l<span class="token punctuation">:</span> l <span class="token operator">+</span> len_sub1<span class="token punctuation">]</span>

        <span class="token comment"># 设置右辅助数组的前 len_sub2 项值为右子数组的值</span>
        aux_right <span class="token operator">=</span> endpoint_list<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> len_sub2<span class="token punctuation">]</span>

        <span class="token comment"># 升序排序(默认)，辅助数组末尾放置哨兵 inf 正无穷</span>
        inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 哨兵数字 inf，用于升序排序。需要比 seg_list 中的所有坐标值都大</span>
        inf_endpoint <span class="token operator">=</span> Endpoint<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token punctuation">(</span>inf<span class="token punctuation">,</span> inf<span class="token punctuation">,</span> inf<span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> seg<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
        aux_left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inf_endpoint<span class="token punctuation">)</span>
        aux_right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inf_endpoint<span class="token punctuation">)</span>

        <span class="token comment"># 两个有序数组的合并</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        j <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 获取当前端点</span>
            left_ep <span class="token operator">=</span> aux_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            right_ep <span class="token operator">=</span> aux_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>left_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>right_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>left_ep<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left_ep<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>right_ep<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right_ep<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
            <span class="token comment"># 先按 x 坐标升序排序</span>
            <span class="token keyword">if</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_ep
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_ep
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token comment"># 如果 x 坐标相等，则先考虑端点是左端点还是右端点 (让左端点在前面)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_ep
                    i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">elif</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_ep
                    j <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token comment"># 如果同是左端点、或同是右端点，那么再考虑 y 坐标，让 y 坐标小的在前面</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                        endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_ep
                        i <span class="token operator">+=</span> <span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_ep
                        j <span class="token operator">+=</span> <span class="token number">1</span>


<span class="token comment"># 红黑树的树结点</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seg<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>seg <span class="token operator">=</span> seg       <span class="token comment"># 线段 Segment 结构体，根据叉积判断次序</span>
        self<span class="token punctuation">.</span>color <span class="token operator">=</span> color   <span class="token comment"># 结点的颜色，True 代表红色(默认)，False 代表黑色</span>
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>     <span class="token comment"># 左孩子指针</span>
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 右孩子指针</span>
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>   <span class="token comment"># 父结点指针</span>


<span class="token comment"># 用于扫除线过程中维护线段高低序的 红黑树 Red-Black Tree</span>
<span class="token comment"># 将基于关键字 key 的比较替换为基于叉积的比较</span>
<span class="token keyword">class</span> <span class="token class-name">SegmentRedBlackTree</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造 红黑树 Red-Black Tree</span>
    <span class="token comment"># 时间复杂度 O(n log n)</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>bst <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>seg<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 二叉搜索树结构，树根。初始设置任意属性的 TreeNode</span>
        self<span class="token punctuation">.</span>is_bst_empty <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 标志着当前 BST 是否为空</span>
        self<span class="token punctuation">.</span>seg2node <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment"># Segment 对象到 TreeNode 的映射</span>

        self<span class="token punctuation">.</span>nil <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>seg<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 黑色的哨兵结点</span>
        self<span class="token punctuation">.</span>nil<span class="token punctuation">.</span>parent <span class="token operator">=</span> self<span class="token punctuation">.</span>nil   <span class="token comment"># 哨兵的父结点仍为自己</span>
        self<span class="token punctuation">.</span>nil<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil     <span class="token comment"># 哨兵的左孩子仍为自己</span>
        self<span class="token punctuation">.</span>nil<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil    <span class="token comment"># 哨兵的右孩子仍为自己</span>

    <span class="token comment"># 辅助操作：左旋。返回替代了 node 的新结点</span>
    <span class="token comment"># 时间复杂度 O(1)</span>
    <span class="token keyword">def</span> <span class="token function">_left_rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node_x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 对 x 进行左旋，即让 x 的右孩子 y (x.right) 成为 x 的父结点，且 x 等于 y.left。</span>
        <span class="token comment"># 而 y 结点原本的左孩子变为新 x 的右孩子</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果 x 是 BST 树根，那么树根要更换</span>
            <span class="token keyword">if</span> node_x <span class="token operator">==</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> node_x<span class="token punctuation">.</span>right

            <span class="token comment"># 调整树结构</span>
            node_y <span class="token operator">=</span> node_x<span class="token punctuation">.</span>right
            node_y<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x<span class="token punctuation">.</span>parent  <span class="token comment"># 设置 node_y 的父结点（互相关联）</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node_x <span class="token operator">==</span> node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node_y
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node_y

            node_x<span class="token punctuation">.</span>right <span class="token operator">=</span> node_y<span class="token punctuation">.</span>left  <span class="token comment"># y 结点原本的左孩子变为新 x 的右孩子</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_y<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node_y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x

            node_y<span class="token punctuation">.</span>left <span class="token operator">=</span> node_x
            node_x<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_y

            <span class="token comment"># 返回替代了 node 的结点 node_y</span>
            <span class="token keyword">return</span> node_y
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 辅助操作：右旋。返回替代了 node 的新结点</span>
    <span class="token comment"># 时间复杂度 O(1)</span>
    <span class="token keyword">def</span> <span class="token function">_right_rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node_x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 对 x 进行右旋，即让 x 的左孩子 y (x.left) 成为 x 的父结点，且 x 等于 y.right。</span>
        <span class="token comment"># 而 y 结点原本的右孩子变为新 x 的左孩子</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果 x 是 BST 树根，那么树根要更换</span>
            <span class="token keyword">if</span> node_x <span class="token operator">==</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> node_x<span class="token punctuation">.</span>left

            <span class="token comment"># 调整树结构</span>
            node_y <span class="token operator">=</span> node_x<span class="token punctuation">.</span>left
            node_y<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x<span class="token punctuation">.</span>parent  <span class="token comment"># 设置 node_y 的父结点（互相关联）</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node_x <span class="token operator">==</span> node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node_y
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node_y

            node_x<span class="token punctuation">.</span>left <span class="token operator">=</span> node_y<span class="token punctuation">.</span>right  <span class="token comment"># y 结点原本的右孩子变为新 x 的左孩子</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_y<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node_y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x

            node_y<span class="token punctuation">.</span>right <span class="token operator">=</span> node_x
            node_x<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_y

            <span class="token comment"># 返回替代了 node 的结点 node_y</span>
            <span class="token keyword">return</span> node_y
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 对于两个向量，逐元素地操作 (例如：加减乘除等)</span>
    <span class="token comment"># func 须是 lambda 表达式。默认为加法</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">vector_operation_by_ele</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        res_vec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res_vec<span class="token punctuation">.</span>append<span class="token punctuation">(</span>func<span class="token punctuation">(</span>vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res_vec

    <span class="token comment"># 计算两向量(列表)的内积/点积</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">inner_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token comment"># 对应位置相乘 再求和</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res <span class="token operator">+=</span> vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res

    <span class="token comment"># 计算两向量(列表)的叉积</span>
    <span class="token comment"># 这里只考虑维度为 2 或者 3 的情况</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token keyword">if</span> dim <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token comment"># 对二维向量 a = &lt;a_0, a_1&gt; 和 b = &lt;b_0, b_1&gt; 而言，返回(可正可负可零的)数值</span>
            <span class="token comment"># a x b = |a|·|b|·sin&lt;a, b&gt; 或者 a x b = det{{a_0, a_1}, {b_0, b_1}} 行列式值</span>
            <span class="token comment"># 如果该数值为正，则表示两向量夹角(不考虑周期)属于开区间 (0, \pi)</span>
            <span class="token comment"># 如果该数值为负，则表示两向量夹角(不考虑周期)属于开区间 (\pi, 2 \pi)</span>
            <span class="token comment"># 如果该数值为零，则表示两向量夹角(不考虑周期)要么是 0 要么是 \pi，故两向量共线</span>
            <span class="token keyword">return</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">elif</span> dim <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token comment"># 对三维向量 a = &lt;a_0, a_1, a_2&gt; 和 b = &lt;b_0, b_1, b_2&gt; 而言，返回三维向量</span>
            <span class="token comment"># a x b = det{{i, j, k}, {a_0, a_1, a_2}, {b_0, b_1, b_2}} 行列式值</span>
            <span class="token comment"># 上式中的 i, j, k 分别为 x, y, z 轴方向的单位向量</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cross_product: 维度不为 2 或者 3'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 在二维空间中，对于首尾相接的两条有向线段 p0p1 和 p1p2</span>
    <span class="token comment"># 以 p0p1 的方向看过去，判断 p1p2 是向左 还是向右 还是不转向</span>
    <span class="token comment"># 只需计算 (p2 - p0) 和 (p1 - p0) 的叉积</span>
    <span class="token comment"># 如果结果为正值，表示向量 p0p2 在 p0p1 的顺时针方法，故在 p1 处需右转</span>
    <span class="token comment"># 如果结果为负值，表示向量 p0p2 在 p0p1 的逆时针方法，故在 p1 处需左转</span>
    <span class="token comment"># 如果结果为零，表示向量 p0p2 与 p0p1 共线，故在 p1 处不变方向 (或者反转 180 度)</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token keyword">def</span> <span class="token function">direction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> p_0<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>  <span class="token comment"># 仅考虑二维欧氏空间</span>
        vec_02 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        vec_01 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>vec_02<span class="token punctuation">,</span> vec_01<span class="token punctuation">)</span>

    <span class="token comment"># 辅助操作：插入之后，逐级向上进行红黑性质维护</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token comment"># 根据当前结点的父结点、爷爷结点、叔叔结点的颜色，分 3 种情况，用旋转操作来调整平衡</span>
    <span class="token keyword">def</span> <span class="token function">_rb_insert_fixup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token comment"># 当前结点 node 为新插入的结点，是红色的</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                <span class="token comment"># node 的爷爷结点必为树结点 (红黑树性质)</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token comment"># node 的爷爷结点为 nil 结点，而且父结点存在</span>
                    <span class="token comment"># 这表示父结点为树根，且根是红色。只需要把根改为黑色即可</span>
                    <span class="token keyword">assert</span> node<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>bst
                    self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token comment"># node 的爷爷结点为树结点，且非 nil</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                        <span class="token comment"># 如果 node 的父结点是 node 爷爷结点的左孩子</span>
                        uncle <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>uncle<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> uncle<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 1: 父结点为红色、父结点是爷爷结点的左孩子、叔叔结点也为红色</span>
                            <span class="token comment"># 这种情况可以直接处理掉</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置父结点的颜色为黑色</span>
                            uncle<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置叔叔结点的颜色为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 置爷爷结点颜色为红色</span>
                            node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其爷爷结点</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 此时：父结点为红色、父结点是爷爷结点的左孩子、叔叔结点不存在或者为黑色</span>
                            <span class="token keyword">if</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                <span class="token comment"># case 2: 父结点为红色、父结点是爷爷结点的左孩子、</span>
                                <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的右孩子</span>
                                <span class="token comment"># 这种情况先转换成 case 3，然后再处理掉</span>
                                node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其父（旋转后会降下来）</span>
                                self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">)</span>  <span class="token comment"># 左旋，&quot;拉直&quot; 呈 LL 型</span>
                            <span class="token comment"># case 3: 父结点为红色、父结点是爷爷结点的左孩子、</span>
                            <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的左孩子</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改父结点为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改爷爷结点为红色</span>
                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>  <span class="token comment"># 右旋爷爷结点</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 如果 node 的父结点是 node 爷爷结点的右孩子（与前述操作呈镜像处理，减少注释）</span>
                        uncle <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left
                        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>uncle<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> uncle<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 1': 父结点为红色、父结点是爷爷结点的右孩子、叔叔结点也为红色</span>
                            <span class="token comment"># 这种情况可以直接处理掉</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置父结点的颜色为黑色</span>
                            uncle<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置叔叔结点的颜色为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 置爷爷结点颜色为红色</span>
                            node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其爷爷结点</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 此时：父结点为红色、父结点是爷爷结点的右孩子、叔叔结点不存在或者为黑色</span>
                            <span class="token keyword">if</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                <span class="token comment"># case 2': 父结点为红色、父结点是爷爷结点的右孩子、</span>
                                <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的左孩子</span>
                                <span class="token comment"># 这种情况先转换成 case 3，然后再处理掉</span>
                                node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其父（旋转后会降下来）</span>
                                self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">)</span>  <span class="token comment"># 右旋，&quot;拉直&quot; 呈 RR 型</span>
                            <span class="token comment"># case 3': 父结点为红色、父结点是爷爷结点的右孩子、</span>
                            <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的右孩子</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改父结点为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改爷爷结点为红色</span>
                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>  <span class="token comment"># 左旋爷爷结点</span>

            <span class="token comment"># while 循环结束、处理完毕，如果此时树根存在，则置为黑色</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>bst<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>bst <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token comment"># 辅助操作：新建树结点</span>
    <span class="token keyword">def</span> <span class="token function">_create_new_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_seg<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        new_node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>new_seg<span class="token punctuation">,</span> color<span class="token operator">=</span>color<span class="token punctuation">)</span>
        new_node<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
        new_node<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
        self<span class="token punctuation">.</span>seg2node<span class="token punctuation">[</span>new_seg<span class="token punctuation">]</span> <span class="token operator">=</span> new_node  <span class="token comment"># 记录映射关系</span>
        <span class="token keyword">return</span> new_node

    <span class="token comment"># 辅助函数：清除某个结点的所有指针域</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">_clear_node_link</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token comment"># 根据 Endpoint 端点对象增加结点 (可以根据端点对象找出其所在的 Segment 线段对象)</span>
    <span class="token comment"># 增加后（每次都增加叶结点），调用 rb_insert_fixup 维护红黑性质</span>
    <span class="token comment"># 刚插入新结点时，仅可能违反第四条红黑性质：每个红色结点的子结点都只能是黑色的。</span>
    <span class="token comment"># 而调整过程中，可能会违反其它性质，但都会一一修复</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">rb_insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> insert_ep<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>insert_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
        insert_seg <span class="token operator">=</span> insert_ep<span class="token punctuation">.</span>seg
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>insert_seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_bst_empty<span class="token punctuation">:</span>
            <span class="token comment"># 如果当前 BST 为空，则直接设置 self.bst 结点，完成插入</span>
            new_node <span class="token operator">=</span> self<span class="token punctuation">.</span>_create_new_node<span class="token punctuation">(</span>insert_seg<span class="token punctuation">)</span>
            new_node<span class="token punctuation">.</span>parent <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
            self<span class="token punctuation">.</span>bst <span class="token operator">=</span> new_node
            self<span class="token punctuation">.</span>is_bst_empty <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            ptr <span class="token operator">=</span> self<span class="token punctuation">.</span>bst           <span class="token comment"># 用 ptr 指针从 root 结点（一般设为 self.bst）开始向下搜索插入位置</span>
            ptr_p <span class="token operator">=</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>parent  <span class="token comment"># ptr_p 记录 ptr 的父亲</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> ptr <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                ptr_p <span class="token operator">=</span> ptr
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
                p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>to_point
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
                <span class="token comment"># 根据顶点转向决定 往左还是往右</span>
                d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> insert_ep<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right

            <span class="token comment"># 找到了插入位置，设置新结点属性：红色、左孩子和右孩子均为哨兵 nil、父结点为 ptr_p</span>
            new_node <span class="token operator">=</span> self<span class="token punctuation">.</span>_create_new_node<span class="token punctuation">(</span>insert_seg<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>

            <span class="token comment"># 根据顶点转向决定 该插入到左边还是右边</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr_p<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
            p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> ptr_p<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> ptr_p<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>to_point
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> insert_ep<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
            <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                ptr_p<span class="token punctuation">.</span>left <span class="token operator">=</span> new_node
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ptr_p<span class="token punctuation">.</span>right <span class="token operator">=</span> new_node
            new_node<span class="token punctuation">.</span>parent <span class="token operator">=</span> ptr_p

            self<span class="token punctuation">.</span>_rb_insert_fixup<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>  <span class="token comment"># 插入后维护红黑性质</span>

    <span class="token comment"># 辅助操作：将结点 u 替换为结点 v（用于删除时的红黑性质保持）</span>
    <span class="token comment"># 时间复杂度 O(1)</span>
    <span class="token keyword">def</span> <span class="token function">_rb_transplant</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> u <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">or</span> u<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> v
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># u 的父结点必为树结点 (红黑树性质)</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token comment"># 根据 u 是其父结点的左孩子还是右孩子，更换指针</span>
                <span class="token keyword">if</span> u <span class="token operator">==</span> u<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    u<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> v
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    u<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> v
        <span class="token comment"># 无条件执行：让 v 的 parent 指针指向 u 的父结点</span>
        v<span class="token punctuation">.</span>parent <span class="token operator">=</span> u<span class="token punctuation">.</span>parent

    <span class="token comment"># 辅助操作：删除之后，逐级向上进行红黑性质维护</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token comment"># 当删除结点 node 时，让其后继 s 替换 node。在结点被移除或者在树中移动之前，必须先记录 s 的颜色</span>
    <span class="token comment"># 根据当前结点的父结点、兄弟结点、兄弟结点的孩子结点的颜色，分 4 种情况，用旋转操作来调整平衡</span>
    <span class="token keyword">def</span> <span class="token function">_rb_delete_fixup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># if isinstance(node, TreeNode) and node != self.nil:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">:</span>
            <span class="token comment"># 当前结点 node 为真正需要被删除的结点，其祖先中有黑色结点被删除(替换)了</span>
            <span class="token keyword">while</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>bst <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                <span class="token comment"># node 的父结点必为树结点 (红黑树性质)</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token comment"># 父结点是 nil，表示当前 node 为树根，只需要把根改为黑色即可</span>
                    <span class="token keyword">assert</span> node <span class="token operator">==</span> self<span class="token punctuation">.</span>bst
                    self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                <span class="token keyword">elif</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    <span class="token comment"># 如果 node 是其父结点的左孩子</span>
                    <span class="token comment"># node 的父结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token comment"># 记录 bro 为 node 父结点的右孩子，即 node 的兄弟结点</span>
                    bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                    <span class="token comment"># node 的兄弟结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 1: node 是其父结点的左孩子、其兄弟结点 bro 为红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 让 bro 的颜色改为黑色</span>
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                    <span class="token comment"># bro 结点的孩子必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">and</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 2: 此时兄弟结点 bro 一定为黑色，如果原本不是黑色，会经过 case 1 变为黑色</span>
                        <span class="token comment"># 此时 bro 孩子均为黑色，让 bro 变为 红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 此时 bro 的孩子不全为黑色</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 3: 此时 node 是其父结点的左孩子，且兄弟结点 bro 一定为黑色</span>
                            <span class="token comment"># bro 的左孩子为红色，右孩子为黑色</span>
                            bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改 bro 左孩子为黑色</span>
                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改 bro 为红色（一红挂两黑）</span>
                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>  <span class="token comment"># 右旋 bro</span>
                            bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                            <span class="token comment"># case 3 之后，保证 bro 为黑色、bro 的右孩子为红色</span>
                        <span class="token comment"># case 4: 此时 node 是其父结点的左孩子，且兄弟结点 bro 一定为黑色</span>
                        <span class="token comment"># bro 的右孩子为红色，左孩子颜色为黑色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        node <span class="token operator">=</span> self<span class="token punctuation">.</span>bst

                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token comment"># 如果 node 是其父结点的右孩子</span>
                    <span class="token comment"># node 的父结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token comment"># 记录 bro 为 node 父结点的左孩子，即 node 的兄弟结点</span>
                    bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left
                    <span class="token comment"># node 的兄弟结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 1': node 是其父结点的右孩子、其兄弟结点 bro 为红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 让 bro 的颜色改为黑色</span>
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                    <span class="token comment"># bro 结点的孩子必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">and</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 2': 此时兄弟结点 bro 一定为黑色，如果原本不是黑色，会经过 case 1' 变为黑色</span>
                        <span class="token comment"># 此时 bro 孩子均为黑色，让 bro 变为 红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 此时 bro 的孩子不全为黑色</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 3': 此时 node 是其父结点的右孩子，且兄弟结点 bro 一定为黑色</span>
                            <span class="token comment"># bro 的左孩子为黑色，右孩子为红色</span>
                            bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改 bro 右孩子为黑色</span>
                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改 bro 为红色（一红挂两黑）</span>
                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>  <span class="token comment"># 左旋 bro</span>
                            bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                            <span class="token comment"># case 3' 之后，保证 bro 为黑色、bro 的左孩子为红色</span>
                        <span class="token comment"># case 4': 此时 node 是其父结点的右孩子，且兄弟结点 bro 一定为黑色</span>
                        <span class="token comment"># bro 的左孩子为红色，右孩子颜色为黑色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        node <span class="token operator">=</span> self<span class="token punctuation">.</span>bst

            <span class="token comment"># 最终将 node 的颜色置为黑色</span>
            node<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token comment"># 根据 Endpoint 端点对象删除结点 (可以根据端点对象找出其所在的 Segment 线段对象)</span>
    <span class="token comment"># 删除黑色结点时，可能违反红黑性质，需要调用 rb_delete_fixup 维护红黑性质</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">rb_delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> delete_ep<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>delete_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
        delete_seg <span class="token operator">=</span> delete_ep<span class="token punctuation">.</span>seg
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>delete_seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_bst_empty<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'提示：红黑树为空，无法继续删除。'</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            ptr <span class="token operator">=</span> root               <span class="token comment"># 用 ptr 指针从 root 结点（一般设为 self.bst）开始向下搜索删除位置</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> ptr <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
                <span class="token keyword">if</span> delete_seg <span class="token operator">==</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">:</span>
                    <span class="token keyword">break</span>  <span class="token comment"># 定位到了目标删除结点</span>
                p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>to_point
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
                <span class="token comment"># 根据顶点转向决定 往左还是往右</span>
                d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> delete_ep<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right

            <span class="token comment"># 若没找到目标结点</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
            <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'提示：删除时，找不到目标元素'</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">assert</span> ptr<span class="token punctuation">.</span>seg <span class="token keyword">in</span> self<span class="token punctuation">.</span>seg2node
                self<span class="token punctuation">.</span>seg2node<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>seg<span class="token punctuation">)</span>  <span class="token comment"># 删除映射关系</span>
                <span class="token comment"># 调整树结构</span>
                <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">and</span> ptr<span class="token punctuation">.</span>seg <span class="token operator">==</span> delete_seg <span class="token keyword">and</span> \
                        <span class="token punctuation">(</span><span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">)</span> <span class="token keyword">and</span> \
                        <span class="token punctuation">(</span><span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>right <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token comment"># 当前 BST 仅有一个根结点 ptr，且欲删除根结点，会导致树空</span>
                    self<span class="token punctuation">.</span>bst <span class="token operator">=</span> <span class="token boolean">None</span>
                    self<span class="token punctuation">.</span>is_bst_empty <span class="token operator">=</span> <span class="token boolean">True</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token comment"># 正常删除结点 ptr，不会导致树变为空</span>
                    <span class="token comment"># 这里的 y 主要用于记录 ptr 的后继，而 x 是覆盖了&quot;真正被删除的结点&quot;的结点</span>
                    <span class="token comment"># 如果 x 覆盖了一个黑色的结点，那么在最后 需要从 x 开始向上调整红黑性质</span>
                    y <span class="token operator">=</span> ptr
                    y_original_color <span class="token operator">=</span> y<span class="token punctuation">.</span>color  <span class="token comment"># 记录 y 原始的颜色，用于最后判断是否需要维护红黑性质</span>

                    <span class="token keyword">if</span> ptr<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> ptr<span class="token punctuation">.</span>right <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                        <span class="token comment"># 如果欲删除结点 ptr 的左右孩子均为空，则为叶，没有孩子可以覆盖 ptr</span>
                        <span class="token comment"># 先让 ptr 父结点的相应孩子指针指向 self.nil</span>
                        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                        <span class="token keyword">if</span> ptr <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                            ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                            bro <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                            bro <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left

                        <span class="token comment"># 如果欲删除的叶结点 ptr 为红色，那么红黑性质不会被破坏</span>
                        <span class="token keyword">if</span> ptr<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token keyword">return</span>
                        <span class="token comment"># 如果欲删除的叶结点 ptr 为黑色，那么红黑性质会被破坏，其父结点的左侧&quot;黑高&quot;低于右侧&quot;黑高&quot;</span>
                        <span class="token comment"># 因为原本红黑性质是满足的，所以此时 (删除 ptr 前) 只有如下这几种可能：</span>
                        <span class="token comment"># 1. ptr 为黑、ptr 的父结点为黑</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil  <span class="token comment"># 兄弟必存在，否则原本就不符合红黑性质了</span>
                            <span class="token comment"># 1.1. ptr 为黑、ptr 的父结点为黑、ptr 的兄弟结点为红</span>
                            <span class="token comment"># 那么 bro 必有两个黑孩子，而且 bro 的黑孩子必为叶</span>
                            <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                                <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                                <span class="token comment"># 1.1.1. 如果 bro 是右孩子</span>
                                <span class="token comment"># 则此时只需要把 bro 染黑、bro 的左孩子染红，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                <span class="token keyword">if</span> bro <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token comment"># 1.1.2. 如果 bro 是左孩子</span>
                                <span class="token comment"># 则此时只需要把 bro 染黑、bro 的右孩子染红，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                            <span class="token comment"># 1.2. ptr 为黑、ptr 的父结点为黑、ptr 的兄弟结点为黑</span>
                            <span class="token comment"># 那么 bro 若有孩子，必为红孩子，而且 bro 的红孩子必为叶</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 1.1.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">if</span> bro <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时只需要把 bro 的右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的左孩子染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，原本的&quot;黑高&quot;为 2 定然无法维持</span>
                                        <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                                <span class="token comment"># 1.1.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时只需要把 bro 的左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的右孩子染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，而原本&quot;黑高&quot;为 2，定然无法维持</span>
                                        <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                        <span class="token comment"># 2. ptr 为黑、ptr 的父结点为红</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 此时兄弟必存在，且为黑，否则原本就不符合红黑性质了</span>
                            <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                            <span class="token comment"># 类似 1.2. 处理</span>
                            <span class="token comment"># 2.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                            <span class="token keyword">if</span> bro <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                    <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

                            <span class="token comment"># 2.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                    <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        <span class="token keyword">return</span>
                    <span class="token comment"># 如果进入下面的分支，ptr 不为叶</span>
                    <span class="token keyword">elif</span> ptr<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                        <span class="token comment"># 如果欲删除结点 ptr 的左孩子为空，且右孩子不为空，则将 ptr 替换为其右孩子</span>
                        x <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                        self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                    <span class="token keyword">elif</span> ptr<span class="token punctuation">.</span>right <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                        <span class="token comment"># 如果欲删除结点 ptr 的右孩子为空，且左孩子不为空，则将 ptr 替换为其左孩子</span>
                        x <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                        self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 欲删除结点 ptr 的左右孩子均不为空，则将 ptr 替换为其后继</span>
                        y <span class="token operator">=</span> self<span class="token punctuation">.</span>below<span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>     <span class="token comment"># y 为 ptr 的后继，y 的左孩子为 nil</span>
                        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> y<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil
                        y_original_color <span class="token operator">=</span> y<span class="token punctuation">.</span>color  <span class="token comment"># (修改)记录 y 原始的颜色</span>
                        x <span class="token operator">=</span> y<span class="token punctuation">.</span>right  <span class="token comment"># 后继结点 y 必无左孩子，让其右孩子 x 替换 y</span>

                        <span class="token keyword">if</span> x <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                            <span class="token comment"># 如果 x 是哨兵 nil，意味着 y 是叶，类似前面 ptr 为叶的处理方式</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                            <span class="token comment"># 如果欲删除结点 y 的左右孩子均为空，则为叶，没有孩子可以覆盖 y</span>
                            <span class="token comment"># 先让 y 父结点的相应孩子指针指向 self.nil</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                            <span class="token keyword">if</span> y <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                                bro <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                                bro <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left

                            <span class="token comment"># 如果欲删除的叶结点 y 为红色，那么红黑性质不会被破坏</span>
                            <span class="token keyword">if</span> y<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                <span class="token comment"># 把 ptr 替换为其后继结点 y，并修改链接关系和 color (不修改 y 的 key、value)</span>
                                <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    self<span class="token punctuation">.</span>bst <span class="token operator">=</span> y
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 根据 u 是其父结点的左孩子还是右孩子，更换指针</span>
                                    <span class="token keyword">if</span> ptr <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                        ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> y
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> y
                                <span class="token comment"># 让 y 的 parent 指针指向 ptr 的父结点</span>
                                y<span class="token punctuation">.</span>parent <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent
                                y<span class="token punctuation">.</span>left <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                                y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                                y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                                y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                                y<span class="token punctuation">.</span>color <span class="token operator">=</span> ptr<span class="token punctuation">.</span>color  <span class="token comment"># y 继承 ptr 的颜色</span>
                                <span class="token keyword">return</span>
                            <span class="token comment"># 如果欲删除的叶结点 y 为黑色，那么红黑性质会被破坏，其父结点的左侧&quot;黑高&quot;低于右侧&quot;黑高&quot;</span>
                            <span class="token comment"># 因为原本红黑性质是满足的，所以此时 (删除 y 前) 只有如下这几种可能：</span>
                            <span class="token comment"># 1. y 为黑、y 的父结点为黑</span>
                            <span class="token keyword">if</span> <span class="token keyword">not</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil  <span class="token comment"># 兄弟必存在，否则原本就不符合红黑性质了</span>
                                <span class="token comment"># 1.1. y 为黑、y 的父结点为黑、y 的兄弟结点为红</span>
                                <span class="token comment"># 那么 bro 必有两个黑孩子，而且 bro 的黑孩子必为叶</span>
                                <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                                    <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                                    <span class="token comment"># 1.1.1. 如果 bro 是右孩子</span>
                                    <span class="token comment"># 则此时只需要把 bro 染黑、bro 的左孩子染红，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 1.1.2. 如果 bro 是左孩子</span>
                                    <span class="token comment"># 则此时只需要把 bro 染黑、bro 的右孩子染红，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                                <span class="token comment"># 1.2. y 为黑、y 的父结点为黑、y 的兄弟结点为黑</span>
                                <span class="token comment"># 那么 bro 若有孩子，必为红孩子，而且 bro 的红孩子必为叶</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 1.1.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                                    <span class="token keyword">if</span> bro <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时只需要把 bro 的右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                        <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时把 bro 的左孩子染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                        <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                                            <span class="token comment"># 如果 bro 的左右孩子都不存在，原本的&quot;黑高&quot;为 2 定然无法维持</span>
                                            <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                            self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                                    <span class="token comment"># 1.1.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时只需要把 bro 的左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                        <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时把 bro 的右孩子染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                        <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                                            <span class="token comment"># 如果 bro 的左右孩子都不存在，而原本&quot;黑高&quot;为 2，定然无法维持</span>
                                            <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                            self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                            <span class="token comment"># 2. y 为黑、y 的父结点为红</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 此时兄弟必存在，且为黑，否则原本就不符合红黑性质了</span>
                                <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                                <span class="token comment"># 类似 1.2. 处理</span>
                                <span class="token comment"># 2.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">if</span> bro <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                        <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

                                <span class="token comment"># 2.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                        <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

                            <span class="token comment"># 把 ptr 替换为其后继结点 y，并修改链接关系和 color (不修改 y 的 key、value)</span>
                            <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> y
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 根据 u 是其父结点的左孩子还是右孩子，更换指针</span>
                                <span class="token keyword">if</span> ptr <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> y
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> y
                            <span class="token comment"># 让 y 的 parent 指针指向 ptr 的父结点</span>
                            y<span class="token punctuation">.</span>parent <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent
                            y<span class="token punctuation">.</span>left <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                            y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                            y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                            y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                            y<span class="token punctuation">.</span>color <span class="token operator">=</span> ptr<span class="token punctuation">.</span>color  <span class="token comment"># y 继承 ptr 的颜色</span>
                            <span class="token keyword">return</span>
                        <span class="token comment"># 此时后继 y 一定有右孩子，x 不可能为 self.nil</span>
                        <span class="token keyword">if</span> y<span class="token punctuation">.</span>parent <span class="token operator">==</span> ptr<span class="token punctuation">:</span>
                            <span class="token comment"># 如果 ptr 的后继 y 就是 ptr 的直接右孩子</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> x <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 如果 ptr 的后继 y 不是 ptr 的直接右孩子</span>
                            <span class="token comment"># 让 y 被其右孩子替换（因为之后 y 要用于替换 ptr）</span>
                            <span class="token comment"># 所以替换了 y 的结点就是 y.right，也即 x</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> y<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                            self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>y<span class="token punctuation">,</span> y<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                            y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                            y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y

                        <span class="token comment"># 现在把 ptr 替换为其后继结点 y，并修改链接关系和 color (不修改 y 的 key、value)</span>
                        self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
                        y<span class="token punctuation">.</span>left <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                        y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                        y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                        y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                        y<span class="token punctuation">.</span>color <span class="token operator">=</span> ptr<span class="token punctuation">.</span>color  <span class="token comment"># y 继承 ptr 的颜色</span>
                    <span class="token comment"># 最后，如果&quot;真正&quot;删除的结点颜色为黑色，则破坏了红黑性质，需要进行维护</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> y_original_color<span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 删除后维护红黑性质</span>

    <span class="token comment"># 找到一棵以 root 为根的 BST/RBT 中的最上方结点（一路左转）</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">highest_bst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            <span class="token keyword">return</span> root
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 找到一棵以 root 为根的 BST/RBT 中的最下方结点（一路右转）</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">lowest_bst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
            <span class="token keyword">return</span> root
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 找到在 BST 中 node 结点的前驱结点</span>
    <span class="token comment"># 如果 node 的左孩子存在，则 node 的前驱就是其左子树中的最大值</span>
    <span class="token comment"># 如果 node 的左孩子不存在，则 node 的前驱是其某个祖先结点 a，满足此时 a.right == node</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">above</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowest_bst<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> node<span class="token punctuation">.</span>parent <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">==</span> node<span class="token punctuation">:</span>
                        <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
                <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 找到在 BST 中 node 结点的后继结点</span>
    <span class="token comment"># 如果 node 的右孩子存在，则 node 的后继就是其右子树中的最小值</span>
    <span class="token comment"># 如果 node 的右孩子不存在，则 node 的前驱是其某个祖先结点 a，满足此时 a.left == node</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">below</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>highest_bst<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> node<span class="token punctuation">.</span>parent <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">:</span>
                        <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
                <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    cg <span class="token operator">=</span> ComputationalGeometry<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 给定两条线段，判断二者是否相交</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n给定两条线段，判断二者是否相交:'</span><span class="token punctuation">)</span>
    p_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    p_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>
    p_3 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_3'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
    p_4 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_4'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">400</span><span class="token punctuation">)</span>
    seg_1 <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">)</span>
    seg_2 <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_3<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_4<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">222</span><span class="token punctuation">)</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_1 <span class="token operator">=</span> cg<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>seg_1<span class="token punctuation">,</span> seg_2<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: True</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_1<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token keyword">and</span> res_1<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! 两线段相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! 两线段不相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 给定线段集合，确定其中是否存在相交线段</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n给定两条线段，判断二者是否相交:'</span><span class="token punctuation">)</span>
    <span class="token comment"># 仿照《CLRS》Chapter 33 的图 33-5</span>
    p_a_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'a_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    p_a_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'a_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">)</span>
    p_b_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'b_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>
    p_b_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'b_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">201</span><span class="token punctuation">)</span>
    p_c_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'c_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
    p_c_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'c_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">301</span><span class="token punctuation">)</span>
    p_d_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'d_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">400</span><span class="token punctuation">)</span>
    p_d_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'d_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">401</span><span class="token punctuation">)</span>
    p_e_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'e_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">)</span>
    p_e_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'e_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">501</span><span class="token punctuation">)</span>
    p_f_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'f_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">600</span><span class="token punctuation">)</span>
    p_f_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'f_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">601</span><span class="token punctuation">)</span>
    seg_a <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_a_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_a_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_a'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">)</span>
    seg_b <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_b_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_b_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_b'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">222</span><span class="token punctuation">)</span>
    seg_c <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_c_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_c_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_c'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">333</span><span class="token punctuation">)</span>
    seg_d <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_d_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_d_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_d'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">444</span><span class="token punctuation">)</span>
    seg_e <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_e_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_e_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_e'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">555</span><span class="token punctuation">)</span>
    seg_f <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_f_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_f_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_f'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span>
    seg_list <span class="token operator">=</span> <span class="token punctuation">[</span>seg_a<span class="token punctuation">,</span> seg_b<span class="token punctuation">,</span> seg_c<span class="token punctuation">,</span> seg_d<span class="token punctuation">,</span> seg_e<span class="token punctuation">,</span> seg_f<span class="token punctuation">]</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_2 <span class="token operator">=</span> cg<span class="token punctuation">.</span>any_segments_intersect<span class="token punctuation">(</span>seg_list<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: True</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_2<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token keyword">and</span> res_2<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! 线段集合中存在两线段相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! 线段集合中不存在两线段相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>Introduction to Algorithm (aka CLRS) Third Edition - Chapter 33</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.889edd9f.js" defer></script><script src="/assets/js/2.db22a8ef.js" defer></script><script src="/assets/js/71.12750d3a.js" defer></script>
  </body>
</html>
