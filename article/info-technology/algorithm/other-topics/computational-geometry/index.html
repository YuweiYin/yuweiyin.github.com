<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Computational Geometry | YuweiYin</title>
    <meta name="description" content="Homepage of YuweiYin">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/YuweiYin.jpeg">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    
    <link rel="preload" href="/assets/css/0.styles.2d4b740c.css" as="style"><link rel="preload" href="/assets/js/app.338776d8.js" as="script"><link rel="preload" href="/assets/js/2.5e710586.js" as="script"><link rel="preload" href="/assets/js/72.ae211912.js" as="script"><link rel="prefetch" href="/assets/js/10.f967ec33.js"><link rel="prefetch" href="/assets/js/100.a918bf34.js"><link rel="prefetch" href="/assets/js/101.e464ffed.js"><link rel="prefetch" href="/assets/js/102.3a55cd96.js"><link rel="prefetch" href="/assets/js/103.d7e285df.js"><link rel="prefetch" href="/assets/js/104.6f9034d1.js"><link rel="prefetch" href="/assets/js/105.567bcf9a.js"><link rel="prefetch" href="/assets/js/106.36477351.js"><link rel="prefetch" href="/assets/js/107.d93634dd.js"><link rel="prefetch" href="/assets/js/108.6a65eea8.js"><link rel="prefetch" href="/assets/js/109.3f687204.js"><link rel="prefetch" href="/assets/js/11.5b164cb4.js"><link rel="prefetch" href="/assets/js/110.b4dc8ef9.js"><link rel="prefetch" href="/assets/js/111.140ef49f.js"><link rel="prefetch" href="/assets/js/112.aa9132ca.js"><link rel="prefetch" href="/assets/js/113.386e4b2c.js"><link rel="prefetch" href="/assets/js/114.2be7cae4.js"><link rel="prefetch" href="/assets/js/115.b726cf6d.js"><link rel="prefetch" href="/assets/js/116.ee059642.js"><link rel="prefetch" href="/assets/js/117.7f774cdf.js"><link rel="prefetch" href="/assets/js/118.74b6de68.js"><link rel="prefetch" href="/assets/js/119.d512e6f3.js"><link rel="prefetch" href="/assets/js/12.61fdaa73.js"><link rel="prefetch" href="/assets/js/120.47edd6d3.js"><link rel="prefetch" href="/assets/js/121.31ec9f51.js"><link rel="prefetch" href="/assets/js/122.30351000.js"><link rel="prefetch" href="/assets/js/123.aa02cb94.js"><link rel="prefetch" href="/assets/js/124.c1f764cf.js"><link rel="prefetch" href="/assets/js/125.0524501e.js"><link rel="prefetch" href="/assets/js/126.6d80204b.js"><link rel="prefetch" href="/assets/js/127.dcf117ed.js"><link rel="prefetch" href="/assets/js/128.69bc2470.js"><link rel="prefetch" href="/assets/js/129.c7de5e6a.js"><link rel="prefetch" href="/assets/js/13.13423942.js"><link rel="prefetch" href="/assets/js/130.107a0d2d.js"><link rel="prefetch" href="/assets/js/131.1df56ec0.js"><link rel="prefetch" href="/assets/js/132.6756aacd.js"><link rel="prefetch" href="/assets/js/133.983902dd.js"><link rel="prefetch" href="/assets/js/134.9835e6be.js"><link rel="prefetch" href="/assets/js/135.c29a8913.js"><link rel="prefetch" href="/assets/js/136.fa35ed67.js"><link rel="prefetch" href="/assets/js/137.1a084d2e.js"><link rel="prefetch" href="/assets/js/138.9c6c6a83.js"><link rel="prefetch" href="/assets/js/139.8874f356.js"><link rel="prefetch" href="/assets/js/14.e2fb8aa6.js"><link rel="prefetch" href="/assets/js/140.2777cfc0.js"><link rel="prefetch" href="/assets/js/141.00c1d847.js"><link rel="prefetch" href="/assets/js/142.3a601367.js"><link rel="prefetch" href="/assets/js/143.a8a9824f.js"><link rel="prefetch" href="/assets/js/144.12e4e356.js"><link rel="prefetch" href="/assets/js/145.38b61aa5.js"><link rel="prefetch" href="/assets/js/146.219cd70a.js"><link rel="prefetch" href="/assets/js/147.ac4650a8.js"><link rel="prefetch" href="/assets/js/148.0511156f.js"><link rel="prefetch" href="/assets/js/149.c1c22b39.js"><link rel="prefetch" href="/assets/js/15.7f07769f.js"><link rel="prefetch" href="/assets/js/150.c5eaaa68.js"><link rel="prefetch" href="/assets/js/151.03599ce7.js"><link rel="prefetch" href="/assets/js/152.fcd974ce.js"><link rel="prefetch" href="/assets/js/153.9091e45c.js"><link rel="prefetch" href="/assets/js/154.6c7ccc17.js"><link rel="prefetch" href="/assets/js/155.16c47efe.js"><link rel="prefetch" href="/assets/js/156.ffe70d22.js"><link rel="prefetch" href="/assets/js/157.436c00ba.js"><link rel="prefetch" href="/assets/js/158.9d96045c.js"><link rel="prefetch" href="/assets/js/159.689c9ddf.js"><link rel="prefetch" href="/assets/js/16.5a323c58.js"><link rel="prefetch" href="/assets/js/160.edda7049.js"><link rel="prefetch" href="/assets/js/161.62badf8c.js"><link rel="prefetch" href="/assets/js/162.abfe29b2.js"><link rel="prefetch" href="/assets/js/163.09214f3c.js"><link rel="prefetch" href="/assets/js/164.03d8ae33.js"><link rel="prefetch" href="/assets/js/165.3b9d5941.js"><link rel="prefetch" href="/assets/js/166.b9a8cc51.js"><link rel="prefetch" href="/assets/js/167.dc295c17.js"><link rel="prefetch" href="/assets/js/168.b4447c67.js"><link rel="prefetch" href="/assets/js/169.f5298f65.js"><link rel="prefetch" href="/assets/js/17.f35473d0.js"><link rel="prefetch" href="/assets/js/170.cc46837a.js"><link rel="prefetch" href="/assets/js/171.b8e0bc09.js"><link rel="prefetch" href="/assets/js/172.1f3e9b4c.js"><link rel="prefetch" href="/assets/js/173.ad3c19e4.js"><link rel="prefetch" href="/assets/js/174.3c39a927.js"><link rel="prefetch" href="/assets/js/175.c85abbec.js"><link rel="prefetch" href="/assets/js/176.d55e245e.js"><link rel="prefetch" href="/assets/js/177.6cb7185e.js"><link rel="prefetch" href="/assets/js/178.9e614d32.js"><link rel="prefetch" href="/assets/js/179.2181acfc.js"><link rel="prefetch" href="/assets/js/18.02dc7ab7.js"><link rel="prefetch" href="/assets/js/180.c090d601.js"><link rel="prefetch" href="/assets/js/181.91db370b.js"><link rel="prefetch" href="/assets/js/182.6eada193.js"><link rel="prefetch" href="/assets/js/183.12cd6d4a.js"><link rel="prefetch" href="/assets/js/184.1ccc4713.js"><link rel="prefetch" href="/assets/js/185.d14590c1.js"><link rel="prefetch" href="/assets/js/186.5dd557ed.js"><link rel="prefetch" href="/assets/js/187.d2e17b0d.js"><link rel="prefetch" href="/assets/js/188.7aafe1eb.js"><link rel="prefetch" href="/assets/js/189.8aceef41.js"><link rel="prefetch" href="/assets/js/19.f64226cb.js"><link rel="prefetch" href="/assets/js/190.c9b1c15b.js"><link rel="prefetch" href="/assets/js/191.70606a81.js"><link rel="prefetch" href="/assets/js/192.05bd6ea2.js"><link rel="prefetch" href="/assets/js/193.e9cdf591.js"><link rel="prefetch" href="/assets/js/194.ebf27382.js"><link rel="prefetch" href="/assets/js/195.54482430.js"><link rel="prefetch" href="/assets/js/196.35bffb17.js"><link rel="prefetch" href="/assets/js/197.5914d2e6.js"><link rel="prefetch" href="/assets/js/198.5e69d743.js"><link rel="prefetch" href="/assets/js/199.dadae2e8.js"><link rel="prefetch" href="/assets/js/20.b665ce81.js"><link rel="prefetch" href="/assets/js/200.917da530.js"><link rel="prefetch" href="/assets/js/201.d3d3d6bd.js"><link rel="prefetch" href="/assets/js/202.6604d2ed.js"><link rel="prefetch" href="/assets/js/203.f6bd1db4.js"><link rel="prefetch" href="/assets/js/204.e7aafd59.js"><link rel="prefetch" href="/assets/js/205.908acc95.js"><link rel="prefetch" href="/assets/js/206.97772be9.js"><link rel="prefetch" href="/assets/js/207.5216da83.js"><link rel="prefetch" href="/assets/js/208.d017221c.js"><link rel="prefetch" href="/assets/js/209.33870b33.js"><link rel="prefetch" href="/assets/js/21.c65c1870.js"><link rel="prefetch" href="/assets/js/210.8daf5510.js"><link rel="prefetch" href="/assets/js/211.f6648c90.js"><link rel="prefetch" href="/assets/js/212.fa602434.js"><link rel="prefetch" href="/assets/js/213.ec9a7b92.js"><link rel="prefetch" href="/assets/js/214.fbffd193.js"><link rel="prefetch" href="/assets/js/215.8f1f172c.js"><link rel="prefetch" href="/assets/js/216.ffe862b7.js"><link rel="prefetch" href="/assets/js/217.bec477c4.js"><link rel="prefetch" href="/assets/js/218.5a6f166d.js"><link rel="prefetch" href="/assets/js/219.bae877e4.js"><link rel="prefetch" href="/assets/js/22.2567d3cf.js"><link rel="prefetch" href="/assets/js/220.094d2873.js"><link rel="prefetch" href="/assets/js/221.fd3e1a1f.js"><link rel="prefetch" href="/assets/js/222.006637e6.js"><link rel="prefetch" href="/assets/js/223.1638798f.js"><link rel="prefetch" href="/assets/js/224.c0b420d7.js"><link rel="prefetch" href="/assets/js/225.3c8aa2c3.js"><link rel="prefetch" href="/assets/js/226.889d304f.js"><link rel="prefetch" href="/assets/js/227.895c2ba6.js"><link rel="prefetch" href="/assets/js/228.29379bcf.js"><link rel="prefetch" href="/assets/js/229.8394d87a.js"><link rel="prefetch" href="/assets/js/23.f741ae26.js"><link rel="prefetch" href="/assets/js/230.98bed704.js"><link rel="prefetch" href="/assets/js/231.eac55cec.js"><link rel="prefetch" href="/assets/js/232.2fc99ed6.js"><link rel="prefetch" href="/assets/js/233.f6369da9.js"><link rel="prefetch" href="/assets/js/234.df156227.js"><link rel="prefetch" href="/assets/js/235.5eadd95d.js"><link rel="prefetch" href="/assets/js/236.6c91ae22.js"><link rel="prefetch" href="/assets/js/237.81746335.js"><link rel="prefetch" href="/assets/js/238.41ce5506.js"><link rel="prefetch" href="/assets/js/239.e4ccf186.js"><link rel="prefetch" href="/assets/js/24.f025ec84.js"><link rel="prefetch" href="/assets/js/240.5ad5cee2.js"><link rel="prefetch" href="/assets/js/241.d6a35d18.js"><link rel="prefetch" href="/assets/js/242.4ff20ec6.js"><link rel="prefetch" href="/assets/js/243.576f20e1.js"><link rel="prefetch" href="/assets/js/244.86fd8409.js"><link rel="prefetch" href="/assets/js/245.4e383f82.js"><link rel="prefetch" href="/assets/js/246.7f1d9e62.js"><link rel="prefetch" href="/assets/js/247.98d0de76.js"><link rel="prefetch" href="/assets/js/248.9cdf71b5.js"><link rel="prefetch" href="/assets/js/249.d4ef6b66.js"><link rel="prefetch" href="/assets/js/25.27544cfc.js"><link rel="prefetch" href="/assets/js/250.0410d925.js"><link rel="prefetch" href="/assets/js/251.c7af59ae.js"><link rel="prefetch" href="/assets/js/252.d61700a3.js"><link rel="prefetch" href="/assets/js/253.37371cdd.js"><link rel="prefetch" href="/assets/js/254.44657697.js"><link rel="prefetch" href="/assets/js/255.7b2525a5.js"><link rel="prefetch" href="/assets/js/256.baf1fff0.js"><link rel="prefetch" href="/assets/js/257.b57f3bf8.js"><link rel="prefetch" href="/assets/js/258.429d4e2f.js"><link rel="prefetch" href="/assets/js/259.51d3b3b6.js"><link rel="prefetch" href="/assets/js/26.c2a925b2.js"><link rel="prefetch" href="/assets/js/260.5f987d68.js"><link rel="prefetch" href="/assets/js/261.00668317.js"><link rel="prefetch" href="/assets/js/262.aa89bef2.js"><link rel="prefetch" href="/assets/js/263.32fa0026.js"><link rel="prefetch" href="/assets/js/264.e4e401a0.js"><link rel="prefetch" href="/assets/js/265.3cc461cc.js"><link rel="prefetch" href="/assets/js/266.0417a9cb.js"><link rel="prefetch" href="/assets/js/267.7990cbee.js"><link rel="prefetch" href="/assets/js/268.6adf55f1.js"><link rel="prefetch" href="/assets/js/269.a88fdbb7.js"><link rel="prefetch" href="/assets/js/27.37b34950.js"><link rel="prefetch" href="/assets/js/270.6a31176d.js"><link rel="prefetch" href="/assets/js/271.40d79711.js"><link rel="prefetch" href="/assets/js/272.427070ea.js"><link rel="prefetch" href="/assets/js/273.f7591e26.js"><link rel="prefetch" href="/assets/js/274.1b456b63.js"><link rel="prefetch" href="/assets/js/275.591b2bd3.js"><link rel="prefetch" href="/assets/js/276.75adb3b6.js"><link rel="prefetch" href="/assets/js/277.a2362c20.js"><link rel="prefetch" href="/assets/js/278.4ee60bb5.js"><link rel="prefetch" href="/assets/js/279.660f4251.js"><link rel="prefetch" href="/assets/js/28.0f4bbb5e.js"><link rel="prefetch" href="/assets/js/280.39730018.js"><link rel="prefetch" href="/assets/js/281.1f32fc88.js"><link rel="prefetch" href="/assets/js/282.a5bc1e6e.js"><link rel="prefetch" href="/assets/js/283.b70797a7.js"><link rel="prefetch" href="/assets/js/284.1fc7d948.js"><link rel="prefetch" href="/assets/js/285.cf03c302.js"><link rel="prefetch" href="/assets/js/286.02e50b29.js"><link rel="prefetch" href="/assets/js/287.02402755.js"><link rel="prefetch" href="/assets/js/288.edbc576e.js"><link rel="prefetch" href="/assets/js/289.fb4cf8c2.js"><link rel="prefetch" href="/assets/js/29.564f8e0e.js"><link rel="prefetch" href="/assets/js/290.2cf26f70.js"><link rel="prefetch" href="/assets/js/291.67580e26.js"><link rel="prefetch" href="/assets/js/292.dce634f4.js"><link rel="prefetch" href="/assets/js/293.d4c1532c.js"><link rel="prefetch" href="/assets/js/294.97bdad35.js"><link rel="prefetch" href="/assets/js/295.01df8642.js"><link rel="prefetch" href="/assets/js/296.95f159ff.js"><link rel="prefetch" href="/assets/js/297.3f2e8cb6.js"><link rel="prefetch" href="/assets/js/298.cd089005.js"><link rel="prefetch" href="/assets/js/299.7fe1a970.js"><link rel="prefetch" href="/assets/js/3.9a9af370.js"><link rel="prefetch" href="/assets/js/30.19956ec4.js"><link rel="prefetch" href="/assets/js/300.82c7e2d5.js"><link rel="prefetch" href="/assets/js/301.cb106109.js"><link rel="prefetch" href="/assets/js/302.f3c6aaaa.js"><link rel="prefetch" href="/assets/js/303.1f5e7dda.js"><link rel="prefetch" href="/assets/js/304.b3f0adcf.js"><link rel="prefetch" href="/assets/js/305.3467aaee.js"><link rel="prefetch" href="/assets/js/306.234e8b08.js"><link rel="prefetch" href="/assets/js/307.9327734b.js"><link rel="prefetch" href="/assets/js/308.3f891bed.js"><link rel="prefetch" href="/assets/js/309.53c5b5d5.js"><link rel="prefetch" href="/assets/js/31.5c51ce08.js"><link rel="prefetch" href="/assets/js/310.175b9ccc.js"><link rel="prefetch" href="/assets/js/311.9045049e.js"><link rel="prefetch" href="/assets/js/312.e3cc54ca.js"><link rel="prefetch" href="/assets/js/313.1c2ab56f.js"><link rel="prefetch" href="/assets/js/314.7aa5ec25.js"><link rel="prefetch" href="/assets/js/315.032a37d0.js"><link rel="prefetch" href="/assets/js/316.4b853264.js"><link rel="prefetch" href="/assets/js/317.ff5483a3.js"><link rel="prefetch" href="/assets/js/318.04d8f96a.js"><link rel="prefetch" href="/assets/js/319.1f08f11e.js"><link rel="prefetch" href="/assets/js/32.c552eab3.js"><link rel="prefetch" href="/assets/js/320.999084a0.js"><link rel="prefetch" href="/assets/js/321.f3d0e77a.js"><link rel="prefetch" href="/assets/js/322.98bd4126.js"><link rel="prefetch" href="/assets/js/323.e12970c8.js"><link rel="prefetch" href="/assets/js/324.f2be1859.js"><link rel="prefetch" href="/assets/js/325.e00aca7c.js"><link rel="prefetch" href="/assets/js/326.59c312d8.js"><link rel="prefetch" href="/assets/js/327.c44080fd.js"><link rel="prefetch" href="/assets/js/328.8e805344.js"><link rel="prefetch" href="/assets/js/329.511f5ab9.js"><link rel="prefetch" href="/assets/js/33.2e71c95d.js"><link rel="prefetch" href="/assets/js/330.c67d354c.js"><link rel="prefetch" href="/assets/js/331.53da0aa4.js"><link rel="prefetch" href="/assets/js/332.884c1bcc.js"><link rel="prefetch" href="/assets/js/333.66688fca.js"><link rel="prefetch" href="/assets/js/334.7784446e.js"><link rel="prefetch" href="/assets/js/34.4715792b.js"><link rel="prefetch" href="/assets/js/35.ca84af36.js"><link rel="prefetch" href="/assets/js/36.c31edebc.js"><link rel="prefetch" href="/assets/js/37.92098954.js"><link rel="prefetch" href="/assets/js/38.ecc049e7.js"><link rel="prefetch" href="/assets/js/39.f61cb78d.js"><link rel="prefetch" href="/assets/js/4.d0b4519a.js"><link rel="prefetch" href="/assets/js/40.f736c71e.js"><link rel="prefetch" href="/assets/js/41.6fad76cf.js"><link rel="prefetch" href="/assets/js/42.66f5c85d.js"><link rel="prefetch" href="/assets/js/43.6110bd5a.js"><link rel="prefetch" href="/assets/js/44.8c2a4521.js"><link rel="prefetch" href="/assets/js/45.447e1b3b.js"><link rel="prefetch" href="/assets/js/46.8a78ee37.js"><link rel="prefetch" href="/assets/js/47.aa58d0b6.js"><link rel="prefetch" href="/assets/js/48.56a4614c.js"><link rel="prefetch" href="/assets/js/49.565287b4.js"><link rel="prefetch" href="/assets/js/5.ee9e9007.js"><link rel="prefetch" href="/assets/js/50.4e663700.js"><link rel="prefetch" href="/assets/js/51.948fce4a.js"><link rel="prefetch" href="/assets/js/52.c9e4e6c6.js"><link rel="prefetch" href="/assets/js/53.05935292.js"><link rel="prefetch" href="/assets/js/54.91c7ce05.js"><link rel="prefetch" href="/assets/js/55.ba07dcf9.js"><link rel="prefetch" href="/assets/js/56.9f99d43e.js"><link rel="prefetch" href="/assets/js/57.a9171b61.js"><link rel="prefetch" href="/assets/js/58.6a6a5be5.js"><link rel="prefetch" href="/assets/js/59.85b399bd.js"><link rel="prefetch" href="/assets/js/6.ac40faf8.js"><link rel="prefetch" href="/assets/js/60.0fb661ef.js"><link rel="prefetch" href="/assets/js/61.40edcedb.js"><link rel="prefetch" href="/assets/js/62.fa853823.js"><link rel="prefetch" href="/assets/js/63.a068397d.js"><link rel="prefetch" href="/assets/js/64.2ced4bc7.js"><link rel="prefetch" href="/assets/js/65.8b482577.js"><link rel="prefetch" href="/assets/js/66.a9e2a128.js"><link rel="prefetch" href="/assets/js/67.4e561d8e.js"><link rel="prefetch" href="/assets/js/68.0b673cf1.js"><link rel="prefetch" href="/assets/js/69.fdbdf778.js"><link rel="prefetch" href="/assets/js/7.3f1ed5cd.js"><link rel="prefetch" href="/assets/js/70.88afc254.js"><link rel="prefetch" href="/assets/js/71.78080656.js"><link rel="prefetch" href="/assets/js/73.64dd0cf6.js"><link rel="prefetch" href="/assets/js/74.4f7419c2.js"><link rel="prefetch" href="/assets/js/75.89400b60.js"><link rel="prefetch" href="/assets/js/76.c65d8991.js"><link rel="prefetch" href="/assets/js/77.00a30e67.js"><link rel="prefetch" href="/assets/js/78.579afef9.js"><link rel="prefetch" href="/assets/js/79.a5d0a91b.js"><link rel="prefetch" href="/assets/js/8.e9792fd3.js"><link rel="prefetch" href="/assets/js/80.bae1b070.js"><link rel="prefetch" href="/assets/js/81.813378ea.js"><link rel="prefetch" href="/assets/js/82.e34af38a.js"><link rel="prefetch" href="/assets/js/83.1a9e34b3.js"><link rel="prefetch" href="/assets/js/84.865f324b.js"><link rel="prefetch" href="/assets/js/85.f6a86574.js"><link rel="prefetch" href="/assets/js/86.2fc9ee67.js"><link rel="prefetch" href="/assets/js/87.933bb3b6.js"><link rel="prefetch" href="/assets/js/88.c20736eb.js"><link rel="prefetch" href="/assets/js/89.13947370.js"><link rel="prefetch" href="/assets/js/9.1d1256b9.js"><link rel="prefetch" href="/assets/js/90.9f1b8469.js"><link rel="prefetch" href="/assets/js/91.f8f9ad88.js"><link rel="prefetch" href="/assets/js/92.4756af88.js"><link rel="prefetch" href="/assets/js/93.4d56a2c7.js"><link rel="prefetch" href="/assets/js/94.0500dacc.js"><link rel="prefetch" href="/assets/js/95.78162db3.js"><link rel="prefetch" href="/assets/js/96.ec69af5c.js"><link rel="prefetch" href="/assets/js/97.cc8d35e3.js"><link rel="prefetch" href="/assets/js/98.f3bd6e0f.js"><link rel="prefetch" href="/assets/js/99.c4efab6f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2d4b740c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YuweiYin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></div><div class="nav-item"><a href="/article/physics/" class="nav-link">
  物理宇宙
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="信息科学" class="dropdown-title"><span class="title">信息科学</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/info-technology/computer-science/" class="nav-link">
  计科基础
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/algorithm/" class="nav-link router-link-active">
  算法编程
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/artificial-intelligence/" class="nav-link">
  人工智能
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-crawler/" class="nav-link">
  网络爬虫
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-frontend/" class="nav-link">
  网站前端
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-backend/" class="nav-link">
  网站后端
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-security/" class="nav-link">
  网络安全
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/system-management/" class="nav-link">
  系统管理
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/other/" class="nav-link">
  其它文章
</a></li></ul></div></div><div class="nav-item"><a href="/article/paper-notes/" class="nav-link">
  论文笔记
</a></div><div class="nav-item"><a href="/article/essay/" class="nav-link">
  见闻随笔
</a></div><div class="nav-item"><a href="/article/other/" class="nav-link">
  其它系列
</a></div><div class="nav-item"><a href="/article/reprint/" class="nav-link">
  转载文章
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></div><div class="nav-item"><a href="/article/physics/" class="nav-link">
  物理宇宙
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="信息科学" class="dropdown-title"><span class="title">信息科学</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/info-technology/computer-science/" class="nav-link">
  计科基础
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/algorithm/" class="nav-link router-link-active">
  算法编程
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/artificial-intelligence/" class="nav-link">
  人工智能
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-crawler/" class="nav-link">
  网络爬虫
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-frontend/" class="nav-link">
  网站前端
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-backend/" class="nav-link">
  网站后端
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/web-security/" class="nav-link">
  网络安全
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/system-management/" class="nav-link">
  系统管理
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/other/" class="nav-link">
  其它文章
</a></li></ul></div></div><div class="nav-item"><a href="/article/paper-notes/" class="nav-link">
  论文笔记
</a></div><div class="nav-item"><a href="/article/essay/" class="nav-link">
  见闻随笔
</a></div><div class="nav-item"><a href="/article/other/" class="nav-link">
  其它系列
</a></div><div class="nav-item"><a href="/article/reprint/" class="nav-link">
  转载文章
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/article/info-technology/" class="sidebar-link">Information Technology</a></li><li><a href="/article/info-technology/computer-science/" class="sidebar-link">Computer Science</a></li><li><a href="/article/info-technology/algorithm/" class="sidebar-link">Algorithm</a></li><li><a href="/article/info-technology/artificial-intelligence/" class="sidebar-link">Artificial Intelligence</a></li><li><a href="/article/info-technology/web-crawler/" class="sidebar-link">Web Crawler</a></li><li><a href="/article/info-technology/web-frontend/" class="sidebar-link">Web Frontend</a></li><li><a href="/article/info-technology/web-backend/" class="sidebar-link">Web Backend</a></li><li><a href="/article/info-technology/web-security/" class="sidebar-link">Web Security</a></li><li><a href="/article/info-technology/system-management/" class="sidebar-link">System Management</a></li><li><a href="/article/info-technology/other/" class="sidebar-link">Other</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="algorithm-computational-geometry"><a href="#algorithm-computational-geometry" class="header-anchor">#</a> Algorithm - Computational Geometry</h1> <p>By <a href="https://yuweiyin.github.io/" target="_blank" rel="noopener noreferrer">YuweiYin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <ul><li>计算几何学 Computational Geometry
<ul><li>(欧几里得空间)点和线段的构造</li> <li>基本几何运算: 对位四则运算、内积、叉积、距离、夹角</li> <li>判断线段相交
<ul><li>给定两条线段，判断二者是否相交</li> <li>给定线段集合，判断其中是否存在相交线段</li></ul></li> <li>凸包问题: 给定点集，寻找该点集的凸包 (convex hull)
<ul><li>Graham 扫描法</li> <li>Jarvis 步进法</li></ul></li> <li>最远/最近点对问题
<ul><li>给定凸多边形的顶点集合，求出该点集的最远点对: 旋转卡壳算法 (Rotating Calipers)</li> <li>给定点集，求出该点集的最近点对</li></ul></li></ul></li></ul> <h2 id="_0-计算几何学"><a href="#_0-计算几何学" class="header-anchor">#</a> 0. 计算几何学</h2> <p>计算几何学是计算机科学的一个分支，专门研究那些用来解决<strong>几何问题</strong>的算法。在现代工程与数学界，计算几何学在不同的领域里有着广泛的应用，包括计算机图形学、机器人学、VLSI 电路设计、计算机辅助设计、分子建模、冶金学、制造业、纺织品设计学、林学和统计学等。计算几何学问题的<strong>输入</strong>通常是<strong>对几何对象集合的描述</strong>，如点集、线段集，或者一个多边形中按顺/逆时针顺序排列的顶点集合。而问题的<strong>输出</strong>通常是回答<strong>关于这些几何对象的查询</strong>，例如，<strong>直线是否相交</strong>；或者是否为一个新的几何对象，例如，点集的<strong>凸包问题</strong> (convex hull，即最小封闭凸多边形)。</p> <p>这里将研究<strong>欧式二维空间</strong>内(即平面上)的若干个计算几何算法。用点集 {p1, p2, p3, ...} 来表示每一个数输入对象，其中每个 pi = {xi, yi}, 且 $ xi, yi \in R $。例如，以顶点序列 <code>&lt;p_0, p_1, p_2, ..., p_{n-1}&gt;</code> 来表示一个含有 n 个顶点的多边形 P (polygon)，这些点以在 P 的边界上出现的顺序来排列。</p> <p>计算几何学也可以应用到三维，甚至更高维度的空间上，不过这样的问题及其解决方案较难可视化。而且 即便是在二维空间上，也能够充分展现计算几何学的精妙之处。</p> <h2 id="_1-线段的性质"><a href="#_1-线段的性质" class="header-anchor">#</a> 1. 线段的性质</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-1.png" alt="computational-geometry-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-2.png" alt="computational-geometry-2"></p> <h3 id="_1-1-叉积"><a href="#_1-1-叉积" class="header-anchor">#</a> 1.1. 叉积</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-3.png" alt="computational-geometry-3"></p> <p>事实上，二维向量的<strong>叉积</strong>是一个三维的概念。根据“右手法则”，它是一个与 p1 和 p2 都垂直的向量，其量值为 <code>| x1 y2 - x2 y1 |</code>。在这里，不考虑叉积作为一个向量的方向性，而仅考虑其模长。</p> <h3 id="_1-2-确定连续线段是向左转还是向右转"><a href="#_1-2-确定连续线段是向左转还是向右转" class="header-anchor">#</a> 1.2. 确定连续线段是向左转还是向右转</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-4.png" alt="computational-geometry-4"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-5.png" alt="computational-geometry-5"></p> <h3 id="_1-3-判定两条线段是否相交"><a href="#_1-3-判定两条线段是否相交" class="header-anchor">#</a> 1.3. 判定两条线段是否相交</h3> <p>为判定两条线段是否相交，需要检查每条线段是否<strong>跨越</strong>了包含另一条线段的直线。如果点 p1 位于某条直线的一边，而点 p2 位于该直线的另一边，则称线段 p1p2 跨越了这条直线。若 p1 或 p2 恰好落在直线上，则出现边界情况。两条线段相交当且仅当下面两个条件<strong>至少成立一个</strong>：</p> <ol><li>对于这两条线段，其中的每条线段都<strong>跨越</strong>了包含另一条线段的直线。</li> <li>一条线段的某个端点落在另一条线段上。（边界情况）</li></ol> <p>下面的过程实现了上述思想。如果线段 p1p2 和 p3p4 相交，那么 <code>SEGMENTS_INTERSECT</code> 返回 True，否则返回 False。它调用了子过程 <code>DIRECTION</code>，利用上述的叉积方法计算出线段的相应方向；另外还调用了子过程 <code>ON_SEGMENT</code> 来判断一个与线段共线的点 是否位于这条线段上（包含线段的端点）。</p> <div class="language- extra-class"><pre class="language-text"><code>SEGMENTS_INTERSECT(p1, p2, p3, p4)
1  d_1 = DIRECTION(p3, p4, p1)
2  d_2 = DIRECTION(p3, p4, p2)
3  d_3 = DIRECTION(p1, p2, p3)
4  d_4 = DIRECTION(p1, p2, p4)
5  if ((d_1 &gt; 0 and d_2 &lt; 0) or (d_1 &lt; 0 and d_2 &gt; 0) and
       (d_3 &gt; 0 and d_4 &lt; 0) or (d_3 &lt; 0 and d_4 &gt; 0))
6      return True
7  elif d_1 == 0 and ON_SEGMENT(p3, p4, p1)
8      return True
9  elif d_2 == 0 and ON_SEGMENT(p3, p4, p2)
10     return True
11 elif d_3 == 0 and ON_SEGMENT(p1, p2, p3)
12     return True
13 elif d_4 == 0 and ON_SEGMENT(p1, p2, p4)
14     return True
15 else
16     return False
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>DIRECTION(pi, pj, pk)
1  return (pk - pi) * (pj - pi)
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>ON_SEGMENT(pi, pj, pk)
1  if min(xi, xj) &lt;= xk &lt;= max(xi, xj) and
       min(yi, yj) &lt;= yk &lt;= max(yi, yj)
2      return True
3  else
4      return False
</code></pre></div><p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-6.png" alt="computational-geometry-6"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-7.png" alt="computational-geometry-7"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-8.png" alt="computational-geometry-8"></p> <h3 id="_1-4-叉积的其它应用"><a href="#_1-4-叉积的其它应用" class="header-anchor">#</a> 1.4. 叉积的其它应用</h3> <p>当需要根据相对于给定原点的极角大小 对给定的点集进行排序时，可以使用叉积进行排序过程中的比较。另外，可以用红黑树来维护一个线段集合的垂直顺序。并不是显式地记录红黑树关键字值，而是通过计算叉积来确定 与同一个给定的垂直线相交的两条线段的相对位置。</p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-9.png" alt="computational-geometry-9"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-10.png" alt="computational-geometry-10"></p> <h2 id="_2-确定任意一对线段是否相交"><a href="#_2-确定任意一对线段是否相交" class="header-anchor">#</a> 2. 确定任意一对线段是否相交</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-1.png" alt="segment-intersect-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-2.png" alt="segment-intersect-2"></p> <h3 id="_2-1-线段排序"><a href="#_2-1-线段排序" class="header-anchor">#</a> 2.1. 线段排序</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-3.png" alt="segment-intersect-3"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-4.png" alt="segment-intersect-4"></p> <h3 id="_2-2-移动扫除线"><a href="#_2-2-移动扫除线" class="header-anchor">#</a> 2.2. 移动扫除线</h3> <p>典型的扫除 Sweeping 算法需要维护如下两组数据：</p> <ol><li><strong>扫除线状态</strong> (sweep-line status) 给出了与扫除线相交的物体之间的关系。</li> <li><strong>事件点调度</strong> (event-point schedule) 是一个按 x 坐标从左到右排列的事件点序列。随着扫除线从左到右行进，每当遇到事件点的 x 坐标时，扫除都会暂停 并处理该事件点，然后重新开始扫除。扫除线状态仅在事件点处改变。</li></ol> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-5.png" alt="segment-intersect-5"></p> <h3 id="_2-3-求线段交点的伪代码"><a href="#_2-3-求线段交点的伪代码" class="header-anchor">#</a> 2.3. 求线段交点的伪代码</h3> <p>下面的算法将一个由 n 条线段组成的集合 S 作为输入，如果 S 中存在一对线段相交，则返回 True，否则返回 False。完全前序 T 由一棵<a href="../../data-structure/red-black-tree">红黑树</a>来维护。</p> <div class="language- extra-class"><pre class="language-text"><code>ANY_SEGMENTS_INTERSECT(S)
1  T = \emptyset
2  sort the endpoints of the segments in S from left to right,
       breaking ties by putting left endpoints before right endpoints
       and breaking further ties by putting points with lower y-coordinates first
3  for each point p in the sorted list of endpoints
4      if p is the left endpoint of a segment s
5          INSERT(T, s)
6          if (ABOVE(T, s) exists and intersects s)
               or (BELOW(T, s) exists and intersects s)
7              return True
8      if p is the right endpoint of a segment s
9          if both ABOVE(T, s) and BELOW(T, s) exist
               and ABOVE(T, s) intersects BELOW(T, s)
10             return True
11         DELETE(T, s)
12 return False
</code></pre></div><p>下图 33-5 说明了此算法的执行过程。</p> <ol><li>第 1 行，初始化完全前序(扩展红黑树的动态集合) T 为空</li> <li>第 2 行，将 2n 个线段端点 由左到右排序，并按照前述方法处理多个点 x 坐标值相同的情况，从而确定事件点的调度次序。
<ul><li>执行第 2 行的一种方式是，在 (x, e, y) 上对端点按照字典序排序，其中 x 和 y 为通常对坐标，而 e = 0 表示左端点、e = 1 表示右端点。</li></ul></li> <li>在第 3～11 行的 for 循环中，每一次迭代都处理一个事件点 p。
<ul><li>如果事件点 p 是某线段 s 的左端点，那么第 5 行将 s 添加到完全前序 T 中。
<ul><li>如果 s 与(由经过 p 的扫除线所定义的)完全前序中的(与之连续的)两条连续线段 中的任一条相交，则第 6～7 行返回 True，表示存在相交的线段。</li> <li>如果 p 位于另一条线段 s' 上，则出现边界情况。此时，仅需要将 s 和 s' 连续地放入 T 中。</li></ul></li> <li>如果事件点 p 是某线段 s 的右端点，那么第 11 行会将 s 从完全前序 T 中删除。
<ul><li>考虑经过 p 的扫除线所定义的完全前序，如果 s 旁边(ABOVE 或者 BELOW)的线段有相交，那么第 9～10 行返回 True。</li> <li>如果这些线段不相交，则第 11 行就将 s 从完全前序 T 中删除。</li> <li>只要第 10 行的 return 语句没有阻碍第 11 行的执行，那么当 s 被删除后，s 旁边的线段就会在完全前序中变为连续。</li></ul></li></ul></li> <li>最后，如果在处理完全部 2n 个事件点后没发现存在线段相交，第 12 行就返回 False。</li></ol> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-6.png" alt="segment-intersect-6"></p> <h3 id="_2-4-求线段交点算法的正确性"><a href="#_2-4-求线段交点算法的正确性" class="header-anchor">#</a> 2.4. 求线段交点算法的正确性</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-7.png" alt="segment-intersect-7"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-8.png" alt="segment-intersect-8"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-9.png" alt="segment-intersect-9"></p> <h3 id="_2-5-求线段交点算法的运行时间"><a href="#_2-5-求线段交点算法的运行时间" class="header-anchor">#</a> 2.5. 求线段交点算法的运行时间</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-10.png" alt="segment-intersect-10"></p> <h3 id="_2-6-其它线段相交相关问题与性质"><a href="#_2-6-其它线段相交相关问题与性质" class="header-anchor">#</a> 2.6. 其它线段相交相关问题与性质</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-11.png" alt="segment-intersect-11"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-12.png" alt="segment-intersect-12"></p> <h2 id="_3-寻找凸包"><a href="#_3-寻找凸包" class="header-anchor">#</a> 3. 寻找凸包</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-1.png" alt="convex-hull-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-2.png" alt="convex-hull-2"></p> <p>因此，通过在 O(n log n) 时间内计算出 n 个输入点的凸包，然后再找出得到的凸多边形中的最远顶点对，就可以在 O(n log n) 时间内 找出任意 n 个点组成的集合中<strong>距离最远的点对</strong>。</p> <p><strong>旋转卡壳</strong> (Rotating Calipers) 算法可以在 O(n) 时间内计算出给定凸多边形(或者凸包的顶点集)的最远点对。</p> <div class="language- extra-class"><pre class="language-text"><code>begin
     p0:=pn;
     q:=NEXT[p];
     while (Area(p,NEXT[p],NEXT[q]) &gt; Area(p,NEXT[p],q)) do
          q:=NEXT[q];
          q0:=q;
          while (q != p0) do
               begin
                    p:=NEXT[p];
                    Print(p,q);
                    while (Area(p,NEXT[p],NEXT[q]) &gt; Area(p,NEXT[p],q) do
                         begin
                              q:=NEXT[q];
                              if ((p,q) != (q0,p0)) then Print(p,q)
                              else return
                         end;
                    if (Area(p,NEXT[p],NEXT[q]) = Area(p,NEXT[p],q)) then
                      if ((p,q) != (q0,p0)) then Print(p,NEXT[q])
                      else Print(NEXT[p],q)
               end
end
</code></pre></div><h3 id="_3-1-graham-扫描法"><a href="#_3-1-graham-扫描法" class="header-anchor">#</a> 3.1. Graham 扫描法</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-3.png" alt="convex-hull-3"></p> <div class="language- extra-class"><pre class="language-text"><code>GRAHAM_SCAN(Q)
1  let p_0 be the point in Q with the minimum y-coordinate,
       or the leftmost such point in case of a tie
2  let &lt;p_1, p_2, ..., p_m&gt; be the remaining points in Q,
       sorted by polar angle in counterclockwise order around p_0
       (if more than one point has the same angle, remove all but
       	the one that is farthest from p_0)
3  if m &lt; 2
4      return &quot;convex hull is empty&quot;
5  else
6      let S be an empty stack
7      PUSH(p_0, S)
8      PUSH(p_1, S)
9      PUSH(p_2, S)
10     for i = 3 to m
11         while the angle formed by points NEXT_TO_TOP(S), TOP(S), 
               and p_i makes a nonleft turn
12             POP(S)
13         PUSH(p_i, S)
14 return S
</code></pre></div><p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-4.png" alt="convex-hull-4"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-5.png" alt="convex-hull-5"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-6.png" alt="convex-hull-6"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-7.png" alt="convex-hull-7"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-8.png" alt="convex-hull-8"></p> <h3 id="_3-2-jarvis-步进法"><a href="#_3-2-jarvis-步进法" class="header-anchor">#</a> 3.2. Jarvis 步进法</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-9.png" alt="convex-hull-9"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-10.png" alt="convex-hull-10"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-11.png" alt="convex-hull-11"></p> <h3 id="_3-3-其它点集凸包相关问题与性质"><a href="#_3-3-其它点集凸包相关问题与性质" class="header-anchor">#</a> 3.3. 其它点集凸包相关问题与性质</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-12.png" alt="convex-hull-12"></p> <h2 id="_4-寻找最近点对"><a href="#_4-寻找最近点对" class="header-anchor">#</a> 4. 寻找最近点对</h2> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-1.png" alt="nearest-pair-1"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-2.png" alt="nearest-pair-2"></p> <h3 id="_4-1-分治算法"><a href="#_4-1-分治算法" class="header-anchor">#</a> 4.1. 分治算法</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-3.png" alt="nearest-pair-3"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-4.png" alt="nearest-pair-4"></p> <h3 id="_4-2-算法的正确性"><a href="#_4-2-算法的正确性" class="header-anchor">#</a> 4.2. 算法的正确性</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-5.png" alt="nearest-pair-5"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-6.png" alt="nearest-pair-6"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-7.png" alt="nearest-pair-7"></p> <h3 id="_4-3-算法的实现与运行时间分析"><a href="#_4-3-算法的实现与运行时间分析" class="header-anchor">#</a> 4.3. 算法的实现与运行时间分析</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-8.png" alt="nearest-pair-8"></p> <div class="language- extra-class"><pre class="language-text"><code>1  let Y_L[1..Y.length] and Y_R[1..Y.length] be new arrays
2  Y_L.length = Y_R.length = 0
3  for i = 1 to Y.length
4      if Y[i] \in P_L
5          Y_L.length = Y_L.length + 1
6          Y_L[Y_L.length] = Y[i]
7      else
8          Y_R.length = Y_R.length + 1
9          Y_R[Y_R.length] = Y[i]
</code></pre></div><p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-9.png" alt="nearest-pair-9"></p> <h3 id="_4-4-其它最近点对相关问题与性质"><a href="#_4-4-其它最近点对相关问题与性质" class="header-anchor">#</a> 4.4. 其它最近点对相关问题与性质</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-10.png" alt="nearest-pair-10"></p> <h2 id="_5-其它计算几何学相关问题"><a href="#_5-其它计算几何学相关问题" class="header-anchor">#</a> 5. 其它计算几何学相关问题</h2> <h3 id="_5-1-凸层"><a href="#_5-1-凸层" class="header-anchor">#</a> 5.1. 凸层</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-1.png" alt="cg-other-questions-1"></p> <h3 id="_5-2-最大层"><a href="#_5-2-最大层" class="header-anchor">#</a> 5.2. 最大层</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-2.png" alt="cg-other-questions-2"></p> <h3 id="_5-3-巨人和鬼问题"><a href="#_5-3-巨人和鬼问题" class="header-anchor">#</a> 5.3. 巨人和鬼问题</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-3.png" alt="cg-other-questions-3"></p> <h3 id="_5-4-拾取棍子问题"><a href="#_5-4-拾取棍子问题" class="header-anchor">#</a> 5.4. 拾取棍子问题</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-4.png" alt="cg-other-questions-4"></p> <h3 id="_5-5-稀疏包分布"><a href="#_5-5-稀疏包分布" class="header-anchor">#</a> 5.5. 稀疏包分布</h3> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-5.png" alt="cg-other-questions-5"></p> <p><img src="/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-6.png" alt="cg-other-questions-6"></p> <h2 id="代码范例"><a href="#代码范例" class="header-anchor">#</a> 代码范例</h2> <h3 id="python"><a href="#python" class="header-anchor">#</a> Python</h3> <p>Python 环境：Python 3.7</p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment">#!/usr/bin/env python</span>
<span class="token comment"># -*- coding:utf-8 -*-</span>
<span class="token triple-quoted-string string">&quot;&quot;&quot;=================================================
@Project : algorithm/other-topics/computational-geometry
@File    : computational-geometry.py
@Author  : YuweiYin
@Date    : 2020-06-13
==================================================&quot;&quot;&quot;</span>

<span class="token keyword">import</span> sys
<span class="token keyword">import</span> time
<span class="token keyword">import</span> math

<span class="token triple-quoted-string string">&quot;&quot;&quot;
- 计算几何学 Computational Geometry
    - (欧几里得空间)点和线段的构造
    - 给定两条线段，判断二者是否相交
    - 给定线段集合，判断其中是否存在相交线段
    - 给定点集，寻找该点集的凸包 convex hull
        - 给定凸多边形的顶点集合，求出该点集的最远点对
    - 给定点集，求出该点集的最近点对

参考资料：
Introduction to Algorithm (aka CLRS) Third Edition - Chapter 33
&quot;&quot;&quot;</span>


<span class="token comment"># (欧几里得空间)点结构体, 单点也可视作为向量 p_0 -&gt; p 其中 p_0 表示坐标系原点</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vec<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>vec <span class="token operator">=</span> vec  <span class="token comment"># 坐标(coordinate): dim 长度的列表</span>
        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim  <span class="token comment"># 维度，默认维度为 2-平面几何</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key  <span class="token comment"># 关键字</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val  <span class="token comment"># 值对象</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'key:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tval:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\tdim:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tvec:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>vec<span class="token punctuation">)</span>


<span class="token comment"># (欧几里得空间)线段结构体</span>
<span class="token keyword">class</span> <span class="token class-name">Segment</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> from_point<span class="token punctuation">,</span> to_point<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> is_directed<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>from_point <span class="token operator">=</span> from_point    <span class="token comment"># 线段的起点</span>
        self<span class="token punctuation">.</span>to_point <span class="token operator">=</span> to_point        <span class="token comment"># 线段的终点</span>
        self<span class="token punctuation">.</span>is_directed <span class="token operator">=</span> is_directed  <span class="token comment"># True 表示此线段是有向线段，否则为无向线段</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key  <span class="token comment"># 关键字</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val  <span class="token comment"># 值对象</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'key:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tval:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tis_directed:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>is_directed<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\nfrom:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>from_point<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\nto:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>to_point<span class="token punctuation">)</span>


<span class="token comment"># 线段端点结构体</span>
<span class="token keyword">class</span> <span class="token class-name">Endpoint</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> point<span class="token punctuation">,</span> seg<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key  <span class="token comment"># 关键字</span>
        self<span class="token punctuation">.</span>point <span class="token operator">=</span> point  <span class="token comment"># 此端点对应的点 Point 结构体</span>
        self<span class="token punctuation">.</span>seg <span class="token operator">=</span> seg  <span class="token comment"># 此端点所属的线段 Segment 结构体</span>
        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim  <span class="token comment"># 维度，默认维度为 2-平面几何</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'key:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\tdim:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dim<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\npoint:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>point<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\nseg:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>seg<span class="token punctuation">)</span>


<span class="token comment"># (欧几里得空间)计算几何学算法</span>
<span class="token keyword">class</span> <span class="token class-name">ComputationalGeometry</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>dim <span class="token operator">=</span> dim  <span class="token comment"># 当前处理的欧氏空间维度，默认为 2-平面几何</span>

    <span class="token comment"># 对于两个向量，逐元素地操作 (例如：加减乘除等)</span>
    <span class="token comment"># func 须是 lambda 表达式。默认为加法</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">vector_operation_by_ele</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        res_vec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res_vec<span class="token punctuation">.</span>append<span class="token punctuation">(</span>func<span class="token punctuation">(</span>vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res_vec

    <span class="token comment"># 计算两向量(列表)的内积/点积</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">inner_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token comment"># 对应位置相乘 再求和</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res <span class="token operator">+=</span> vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res

    <span class="token comment"># 计算两向量(列表)的叉积</span>
    <span class="token comment"># 这里只考虑维度为 2 或者 3 的情况</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token keyword">if</span> dim <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token comment"># 对二维向量 a = &lt;a_0, a_1&gt; 和 b = &lt;b_0, b_1&gt; 而言，返回(可正可负可零的)数值</span>
            <span class="token comment"># a x b = |a|·|b|·sin&lt;a, b&gt; 或者 a x b = det{{a_0, a_1}, {b_0, b_1}} 行列式值</span>
            <span class="token comment"># 如果该数值为正，则表示两向量夹角(不考虑周期)属于开区间 (0, \pi)</span>
            <span class="token comment"># 如果该数值为负，则表示两向量夹角(不考虑周期)属于开区间 (\pi, 2 \pi)</span>
            <span class="token comment"># 如果该数值为零，则表示两向量夹角(不考虑周期)要么是 0 要么是 \pi，故两向量共线</span>
            <span class="token keyword">return</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">elif</span> dim <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token comment"># 对三维向量 a = &lt;a_0, a_1, a_2&gt; 和 b = &lt;b_0, b_1, b_2&gt; 而言，返回三维向量</span>
            <span class="token comment"># a x b = det{{i, j, k}, {a_0, a_1, a_2}, {b_0, b_1, b_2}} 行列式值</span>
            <span class="token comment"># 上式中的 i, j, k 分别为 x, y, z 轴方向的单位向量</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cross_product: 维度不为 2 或者 3'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 利用叉积公式计算两向量(列表)夹角的正弦值</span>
    <span class="token keyword">def</span> <span class="token function">sin_angle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        cross <span class="token operator">=</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span>
        square_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>inner_product<span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_1<span class="token punctuation">)</span>
        square_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>inner_product<span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> square_1 <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> square_2 <span class="token operator">&gt;</span> <span class="token number">0</span>
        <span class="token keyword">return</span> cross <span class="token operator">/</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>square_1 <span class="token operator">*</span> square_2<span class="token punctuation">)</span>

    <span class="token comment"># 利用内积公式计算两向量(列表)夹角的余弦值</span>
    <span class="token keyword">def</span> <span class="token function">cos_angle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        inner <span class="token operator">=</span> self<span class="token punctuation">.</span>inner_product<span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span>
        square_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>inner_product<span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_1<span class="token punctuation">)</span>
        square_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>inner_product<span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> square_1 <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">and</span> square_2 <span class="token operator">&gt;</span> <span class="token number">0</span>
        <span class="token keyword">return</span> inner <span class="token operator">/</span> math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>square_1 <span class="token operator">*</span> square_2<span class="token punctuation">)</span>

    <span class="token comment"># 在二维欧氏空间中，计算两点距离的平方</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">point_distance_square_2d</span><span class="token punctuation">(</span>point_1<span class="token punctuation">,</span> point_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> point_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> point_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>point_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> point_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>point_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> point_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>

    <span class="token comment"># (二维欧氏空间中)给定线段 Segment 结构体 seg，以及 x 坐标，获得该点的 y 坐标</span>
    <span class="token comment"># 如果 x 坐标越出 seg 范围，则返回 None</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">segment_x2y</span><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 先根据 Segment 结构体获取其两个端点的 Point 结构体</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
        p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg<span class="token punctuation">.</span>to_point
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token comment"># 确定 x 坐标是否越界</span>
        <span class="token keyword">if</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> x <span class="token operator">&lt;=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 若线段垂直于 x 轴，则返回其低端点的 y 值</span>
            <span class="token keyword">if</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token comment"># 否则根据平面几何公式计算 y 值</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                slope <span class="token operator">=</span> <span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 斜率</span>
                <span class="token keyword">return</span> slope <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 给定两条线段，判断二者是否相交</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token keyword">def</span> <span class="token function">segments_intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seg_1<span class="token punctuation">,</span> seg_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg_1<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg_2<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 获取两线段的四端点</span>
            p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_3<span class="token punctuation">,</span> p_4 <span class="token operator">=</span> seg_1<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg_1<span class="token punctuation">.</span>to_point<span class="token punctuation">,</span> seg_2<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg_2<span class="token punctuation">.</span>to_point
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_4<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token comment"># 判断转向</span>
            d_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_1<span class="token punctuation">)</span>
            d_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span>
            d_3 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_3<span class="token punctuation">)</span>
            d_4 <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_4<span class="token punctuation">)</span>
            <span class="token comment"># 根据转向判断线段是否相交</span>
            <span class="token comment"># 如果 d_1 与 d_2 异号，表示从向量 p3p4 出发去往 p1 和 p2 是不同的转向，说明 p1 与 p2 分居线段 p3p4 的两侧</span>
            <span class="token comment"># 同理，如果 d_3 与 d_4 异号，说明 p3 与 p4 分居线段 p1p2 的两侧</span>
            <span class="token comment"># 上述两点同时满足的话，两线段必相交</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>d_1 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span> d_2 <span class="token keyword">or</span> d_1 <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&gt;</span> d_2<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>d_3 <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">&lt;</span> d_4 <span class="token keyword">or</span> d_3 <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&gt;</span> d_4<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 如果 d_1 == 0，表示 p1 与线段 p3p4 共线</span>
            <span class="token comment"># 此时判断 p1 是否落在线段 p3p4 内，若是，则两线段至少有交点 p1。下同</span>
            <span class="token keyword">elif</span> d_1 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_1<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> d_2 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_3<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> d_3 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_3<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token keyword">elif</span> d_4 <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>on_segment<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_4<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 其它情况下，两线段不相交</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的线段参数不合法'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token comment"># 在二维空间中，对于首尾相接的两条有向线段 p0p1 和 p1p2</span>
    <span class="token comment"># 以 p0p1 的方向看过去，判断 p1p2 是向左 还是向右 还是不转向</span>
    <span class="token comment"># 只需计算 (p2 - p0) 和 (p1 - p0) 的叉积</span>
    <span class="token comment"># 如果结果为正值，表示向量 p0p2 在 p0p1 的顺时针方法，故在 p1 处需右转</span>
    <span class="token comment"># 如果结果为负值，表示向量 p0p2 在 p0p1 的逆时针方法，故在 p1 处需左转</span>
    <span class="token comment"># 如果结果为零，表示向量 p0p2 与 p0p1 共线，故在 p1 处不变方向 (或者反转 180 度)</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token keyword">def</span> <span class="token function">direction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> p_0<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>  <span class="token comment"># 仅考虑二维欧氏空间</span>
        vec_02 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        vec_01 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>vec_02<span class="token punctuation">,</span> vec_01<span class="token punctuation">)</span>

    <span class="token comment"># 假定点 p2 已经与线段 p0p1 共线</span>
    <span class="token comment"># 判断点 p2 是否位于线段 p0p1 上 (包含线段的端点)</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">on_segment</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> p_0<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>  <span class="token comment"># 仅考虑二维欧氏空间</span>
        <span class="token comment"># 仅需进行区间判断</span>
        <span class="token keyword">if</span> <span class="token builtin">min</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">and</span> \
                <span class="token builtin">min</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token comment"># 给定线段集合 seg_list，确定其中是否存在相交线段</span>
    <span class="token comment"># 时间复杂度：O(n log n)</span>
    <span class="token keyword">def</span> <span class="token function">any_segments_intersect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seg_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 1. 初始化完全前序(扩展红黑树的动态集合) T 为空</span>
        seg_rbt <span class="token operator">=</span> SegmentRedBlackTree<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># 2. 将 2n 个线段端点 由左到右排序，若多个点 x 坐标值相同，则优先取 y 值低的，从而确定事件点的调度次序</span>
        <span class="token comment">#    排序方式：以 (x, e, y) 作为多级关键字 进行排序，其中 x 和 y 为通常对坐标，而 e = 0 表示左端点、e = 1 表示右端点</span>
        <span class="token comment">#    如果某线段是竖直(垂直于时间轴)的，则将其底部端点当作左端点、顶部端点当作右端点即可</span>
        endpoint_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 先封装这 2n 个端点为 Endpoint 结构体，再进行排序。关键字 key 为元组 (x, e, y)</span>
        <span class="token keyword">for</span> seg <span class="token keyword">in</span> seg_list<span class="token punctuation">:</span>
            <span class="token comment"># 先根据 Segment 结构体获取其两个端点的 Point 结构体</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
            <span class="token comment"># 根据 (x, e, y) 多级关键字 顺序，将左端点设置为 seg.from_point、右端点设置为 seg.to_point</span>
            <span class="token comment"># 方便调用 self.direction、利用叉积来判断线段的次序</span>
            <span class="token keyword">if</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> seg<span class="token punctuation">.</span>to_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                temp <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point
                seg<span class="token punctuation">.</span>from_point <span class="token operator">=</span> seg<span class="token punctuation">.</span>to_point
                seg<span class="token punctuation">.</span>to_point <span class="token operator">=</span> temp
            <span class="token comment"># 若两端点的 x 坐标相同，表示此线段与 x (时间)轴垂直，则考虑 y 坐标</span>
            <span class="token comment"># 若两端点的 x、y 坐标均相同，则表示此线段退化成了一个点，则任取其一作为左端点均可</span>
            <span class="token keyword">elif</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> seg<span class="token punctuation">.</span>to_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                <span class="token comment"># 优先取 y 坐标较小的端点</span>
                <span class="token keyword">if</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> seg<span class="token punctuation">.</span>to_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    temp <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point
                    seg<span class="token punctuation">.</span>from_point <span class="token operator">=</span> seg<span class="token punctuation">.</span>to_point
                    seg<span class="token punctuation">.</span>to_point <span class="token operator">=</span> temp
            <span class="token comment"># 封装端点结构体</span>
            p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> seg<span class="token punctuation">.</span>to_point
            ep_1 <span class="token operator">=</span> Endpoint<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> p_1<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token operator">=</span>p_1<span class="token punctuation">,</span> seg<span class="token operator">=</span>seg<span class="token punctuation">)</span>
            ep_2 <span class="token operator">=</span> Endpoint<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> p_2<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token operator">=</span>p_2<span class="token punctuation">,</span> seg<span class="token operator">=</span>seg<span class="token punctuation">)</span>
            <span class="token comment"># 将当前线段的两端点封装好后，加入 endpoint_list 列表</span>
            endpoint_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ep_1<span class="token punctuation">)</span>
            endpoint_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ep_2<span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>sort_endpoints<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">)</span>

        <span class="token comment"># 3. 在 for 循环中，每一次迭代都处理一个(端点)事件点 ep</span>
        <span class="token keyword">for</span> ep <span class="token keyword">in</span> endpoint_list<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ep<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ep<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
            <span class="token comment"># 如果事件点 p 是某线段 s 的左端点，那么第 5 行将 s 添加到完全前序 T 中</span>
            <span class="token comment">#   如果 s 与(由经过 p 的扫除线所定义的)完全前序中的(与之连续的)两条连续线段 中的任一条相交，</span>
            <span class="token comment">#   则返回 True，表示存在相交的线段。</span>
            <span class="token comment">#   如果 p 位于另一条线段 s' 上，则出现边界情况。此时，仅需要将 s 和 s' 连续地放入 T 中</span>
            <span class="token keyword">if</span> ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
                <span class="token comment"># 将当前(线段)端点插入(红黑树)完全前序 T 中</span>
                seg_rbt<span class="token punctuation">.</span>rb_insert<span class="token punctuation">(</span>insert_ep<span class="token operator">=</span>ep<span class="token punctuation">)</span>
                <span class="token comment"># 获取当前端点对应线段的 TreeNode 树结点</span>
                <span class="token keyword">assert</span> ep<span class="token punctuation">.</span>seg <span class="token keyword">in</span> seg_rbt<span class="token punctuation">.</span>seg2node
                cur_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>seg2node<span class="token punctuation">[</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>cur_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token comment"># 如果前驱结点存在，判断两线段是否相交</span>
                above_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>above<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    above_seg <span class="token operator">=</span> above_node<span class="token punctuation">.</span>seg
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> above_seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type-1:'</span><span class="token punctuation">)</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'插入端点'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>point<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'时，发现线段'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
                              <span class="token string">'与其上方的线段'</span><span class="token punctuation">,</span> above_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'相交'</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
                <span class="token comment"># 如果后继结点存在，判断两线段是否相交</span>
                below_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>below<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    below_seg <span class="token operator">=</span> below_node<span class="token punctuation">.</span>seg
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> below_seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type-2:'</span><span class="token punctuation">)</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'插入端点'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>point<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'时，发现线段'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
                              <span class="token string">'与其下方的线段'</span><span class="token punctuation">,</span> below_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'相交'</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
            <span class="token comment"># 如果事件点 p 是某线段 s 的右端点，那么会将 s 从完全前序 T 中删除</span>
            <span class="token comment">#   考虑经过 p 的扫除线所定义的完全前序，如果 s 旁边(ABOVE 或者 BELOW)的线段有相交，则返回 True</span>
            <span class="token comment">#   如果这些线段不相交，则第 11 行就将 s 从完全前序 T 中删除</span>
            <span class="token comment">#   当 s 被删除后，s 旁边的线段就会在完全前序中变为连续(即相邻)</span>
            <span class="token keyword">if</span> ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 获取当前端点对应线段的 TreeNode 树结点</span>
                <span class="token keyword">assert</span> ep<span class="token punctuation">.</span>seg <span class="token keyword">in</span> seg_rbt<span class="token punctuation">.</span>seg2node
                cur_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>seg2node<span class="token punctuation">[</span>ep<span class="token punctuation">.</span>seg<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>cur_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token comment"># 如果前驱结点和后继结点均存在，且前驱和后继对应的线段相交，则返回 True</span>
                above_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>above<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                below_node <span class="token operator">=</span> seg_rbt<span class="token punctuation">.</span>below<span class="token punctuation">(</span>cur_node<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>above_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span> <span class="token keyword">and</span> \
                        <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>below_node<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    above_seg <span class="token operator">=</span> above_node<span class="token punctuation">.</span>seg
                    below_seg <span class="token operator">=</span> below_node<span class="token punctuation">.</span>seg
                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>above_seg<span class="token punctuation">,</span> below_seg<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Type-3:'</span><span class="token punctuation">)</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'删除端点'</span><span class="token punctuation">,</span> ep<span class="token punctuation">.</span>point<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'时，发现线段'</span><span class="token punctuation">,</span> above_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
                              <span class="token string">'与其下方的线段'</span><span class="token punctuation">,</span> below_seg<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token string">'相交'</span><span class="token punctuation">)</span>
                        <span class="token keyword">return</span> <span class="token boolean">True</span>
                <span class="token comment"># 将当前(线段)端点从(红黑树)完全前序 T 中删除</span>
                seg_rbt<span class="token punctuation">.</span>rb_delete<span class="token punctuation">(</span>seg_rbt<span class="token punctuation">.</span>bst<span class="token punctuation">,</span> delete_ep<span class="token operator">=</span>ep<span class="token punctuation">)</span>

        <span class="token comment"># 4. 最后，如果在处理完全部 2n 个事件点后没发现存在线段相交，则返回 False</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>

    <span class="token comment"># 对端点集合进行二路归并排序(升序)</span>
    <span class="token keyword">def</span> <span class="token function">sort_endpoints</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> endpoint_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_endpoints_merge_sort<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>endpoint_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment"># 二路归并排序</span>
    <span class="token keyword">def</span> <span class="token function">_endpoints_merge_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 当待排序数组的左下标等于右下标时为基本情况：</span>
        <span class="token comment"># 该数组只有一个元素。这自然是已排好序的，无需处理</span>
        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>
            m <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 二路归并</span>
            self<span class="token punctuation">.</span>_endpoints_merge_sort<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_endpoints_merge_sort<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_endpoints_merge<span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span>

    <span class="token comment"># 合并</span>
    <span class="token comment"># 该过程假设子数组 endpoint_list[l..m] 和 endpoint_list[m+1..r] 都已排好序</span>
    <span class="token comment"># 合并上述两个子数组为一个排好序的较大数组</span>
    <span class="token comment"># 参数范围 l &lt;= m &lt; r</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">_endpoints_merge</span><span class="token punctuation">(</span>endpoint_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        len_sub1 <span class="token operator">=</span> m <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 左子数组的长度</span>
        len_sub2 <span class="token operator">=</span> r <span class="token operator">-</span> m      <span class="token comment"># 右子数组的长度</span>

        <span class="token comment"># 设置左辅助数组的前 len_sub1 项值为左子数组的值</span>
        aux_left <span class="token operator">=</span> endpoint_list<span class="token punctuation">[</span>l<span class="token punctuation">:</span> l <span class="token operator">+</span> len_sub1<span class="token punctuation">]</span>

        <span class="token comment"># 设置右辅助数组的前 len_sub2 项值为右子数组的值</span>
        aux_right <span class="token operator">=</span> endpoint_list<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> len_sub2<span class="token punctuation">]</span>

        <span class="token comment"># 升序排序(默认)，辅助数组末尾放置哨兵 inf 正无穷</span>
        inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 哨兵数字 inf，用于升序排序。需要比所有坐标值都大</span>
        inf_endpoint <span class="token operator">=</span> Endpoint<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token punctuation">(</span>inf<span class="token punctuation">,</span> inf<span class="token punctuation">,</span> inf<span class="token punctuation">)</span><span class="token punctuation">,</span> point<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> seg<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>
        aux_left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inf_endpoint<span class="token punctuation">)</span>
        aux_right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inf_endpoint<span class="token punctuation">)</span>

        <span class="token comment"># 两个有序数组的合并</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        j <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 获取当前端点</span>
            left_ep <span class="token operator">=</span> aux_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            right_ep <span class="token operator">=</span> aux_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>left_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>right_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>left_ep<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>left_ep<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>right_ep<span class="token punctuation">.</span>key<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>right_ep<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span>
            <span class="token comment"># 先按 x 坐标升序排序</span>
            <span class="token keyword">if</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_ep
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_ep
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token comment"># 如果 x 坐标相等，则先考虑端点是左端点还是右端点 (让左端点在前面)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_ep
                    i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">elif</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                    endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_ep
                    j <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token comment"># 如果同是左端点、或同是右端点，那么再考虑 y 坐标，让 y 坐标小的在前面</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> left_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right_ep<span class="token punctuation">.</span>key<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
                        endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_ep
                        i <span class="token operator">+=</span> <span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        endpoint_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_ep
                        j <span class="token operator">+=</span> <span class="token number">1</span>

    <span class="token comment"># Graham 扫描法 - 给定点集，寻找该点集的凸包 convex hull</span>
    <span class="token comment"># (可利用凸包求出该点集的最远点对 - O(n))</span>
    <span class="token comment"># 时间复杂度：O(n log n) 其中 n 为点集中的点数目</span>
    <span class="token keyword">def</span> <span class="token function">convex_hull_graham_scan</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 点集 Q 的要求：点数目 &gt;= 3，且至少存在不共线的 3 个点</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的点集至少应有 3 个点'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        <span class="token comment"># 1. 选取点 p_0，它是 y 坐标最小的点 (如果有多个极小 y 坐标的点，则选取其中 x 坐标最小的点)</span>
        <span class="token comment">#    点 p_0 一定是凸包的一个顶点</span>
        p_0_index <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> index<span class="token punctuation">,</span> point <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span><span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">or</span> \
                    <span class="token punctuation">(</span>point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span><span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span><span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                p_0_index <span class="token operator">=</span> index
        p_0 <span class="token operator">=</span> point_list<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>p_0_index<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>

        <span class="token comment"># 2. 利用叉积方法，求取其它各点相对于 p_0 的极角，并按极角升序(逆时针)排列这些点</span>
        <span class="token comment">#    如果存在多个点 相对 p_0 的极角相同，则只保留(欧式)距离 p_0 最远的那一个点</span>
        n_points <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span>
        remain_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_points<span class="token punctuation">)</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>sort_polar_angle<span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">)</span>
        <span class="token comment"># remain_list[i] == True 表示需保留 point_list[i] 点，否则不保留 (因为存在共线且更远的点)</span>
        <span class="token comment"># 此时进行线性扫描，只选 remain_list[i] == True 的那些点</span>
        ordered_points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_points<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> remain_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
                ordered_points<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token comment"># 3. 检查剩余的点数目，应至少有 2 个</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ordered_points<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'convex hull is empty!'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        <span class="token comment"># 4. 按极角序逐个处理每个点</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 用 list 模拟栈，先让 p_0、p_1、p_2 入栈</span>
            stack_list <span class="token operator">=</span> <span class="token punctuation">[</span>p_0<span class="token punctuation">,</span> ordered_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ordered_points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

            <span class="token comment"># 循环处理剩余的每个点</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>ordered_points<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 按逆时针方向遍历凸包时，理应在每个顶点处向左转</span>
                <span class="token comment"># 因此，如果 while 发现在一个顶点处没有左转，就该把此顶点从栈中弹出</span>
                cur_point <span class="token operator">=</span> ordered_points<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack_list<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
                    s_len <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack_list<span class="token punctuation">)</span>
                    d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>stack_list<span class="token punctuation">[</span>s_len <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stack_list<span class="token punctuation">[</span>s_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cur_point<span class="token punctuation">)</span>
                    <span class="token comment"># 左转</span>
                    <span class="token keyword">if</span> d <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                        <span class="token keyword">break</span>
                    <span class="token comment"># 非左转</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        stack_list<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
                        s_len <span class="token operator">-=</span> <span class="token number">1</span>
                stack_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_point<span class="token punctuation">)</span>

            <span class="token comment"># 此时 stack_list 是从 p_0 开始按逆时针方向排列的各个凸包顶点</span>
            <span class="token keyword">return</span> stack_list

    <span class="token comment"># 对点集 point_list，以 compare_point 为参照点进行极角(升序)排序-二路归并排序</span>
    <span class="token keyword">def</span> <span class="token function">sort_polar_angle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>compare_point<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>remain_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>_polar_angle_merge_sort<span class="token punctuation">(</span>compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token comment"># 二路归并排序</span>
    <span class="token keyword">def</span> <span class="token function">_polar_angle_merge_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 当待排序数组的左下标等于右下标时为基本情况：</span>
        <span class="token comment"># 该数组只有一个元素。这自然是已排好序的，无需处理</span>
        <span class="token keyword">if</span> l <span class="token operator">&lt;</span> r<span class="token punctuation">:</span>
            m <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 二路归并</span>
            self<span class="token punctuation">.</span>_polar_angle_merge_sort<span class="token punctuation">(</span>compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_polar_angle_merge_sort<span class="token punctuation">(</span>compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>_polar_angle_merge<span class="token punctuation">(</span>compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span>

    <span class="token comment"># 合并 (以 compare_point 为基点，按极角(升序)排序)</span>
    <span class="token comment"># remain_list[i] == True 表示需保留 point_list[i] 点，否则不保留 (因为存在共线且更远的点)</span>
    <span class="token comment"># 该过程假设子数组 point_list[l..m] 和 point_list[m+1..r] 都已排好序</span>
    <span class="token comment"># 合并上述两个子数组为一个排好序的较长数组</span>
    <span class="token comment"># 参数范围 l &lt;= m &lt; r</span>
    <span class="token keyword">def</span> <span class="token function">_polar_angle_merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> compare_point<span class="token punctuation">,</span> remain_list<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
        len_sub1 <span class="token operator">=</span> m <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment"># 左子数组的长度</span>
        len_sub2 <span class="token operator">=</span> r <span class="token operator">-</span> m  <span class="token comment"># 右子数组的长度</span>

        <span class="token comment"># 设置左辅助数组的前 len_sub1 项值为左子数组的值</span>
        aux_left <span class="token operator">=</span> point_list<span class="token punctuation">[</span>l<span class="token punctuation">:</span> l <span class="token operator">+</span> len_sub1<span class="token punctuation">]</span>
        aux_left_remain <span class="token operator">=</span> remain_list<span class="token punctuation">[</span>l<span class="token punctuation">:</span> l <span class="token operator">+</span> len_sub1<span class="token punctuation">]</span>

        <span class="token comment"># 设置右辅助数组的前 len_sub2 项值为右子数组的值</span>
        aux_right <span class="token operator">=</span> point_list<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> len_sub2<span class="token punctuation">]</span>
        aux_right_remain <span class="token operator">=</span> remain_list<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span> m <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> len_sub2<span class="token punctuation">]</span>

        <span class="token comment"># 升序排序(默认)，辅助数组末尾放置哨兵 inf 正无穷</span>
        inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 哨兵数字 inf，用于升序排序。需要比所有坐标值都大</span>
        inf_point <span class="token operator">=</span> Point<span class="token punctuation">(</span>key<span class="token operator">=</span>inf<span class="token punctuation">,</span> vec<span class="token operator">=</span><span class="token punctuation">[</span>inf<span class="token punctuation">,</span> inf<span class="token punctuation">]</span><span class="token punctuation">)</span>
        aux_left<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inf_point<span class="token punctuation">)</span>
        aux_right<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inf_point<span class="token punctuation">)</span>

        <span class="token comment"># 两个有序数组的合并</span>
        i <span class="token operator">=</span> <span class="token number">0</span>
        j <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 获取当前端点</span>
            left_p <span class="token operator">=</span> aux_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            right_p <span class="token operator">=</span> aux_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>left_p<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>right_p<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token comment"># 某个辅助列表达到末尾</span>
            <span class="token keyword">if</span> left_p <span class="token operator">==</span> inf_point<span class="token punctuation">:</span>
                <span class="token keyword">while</span> aux_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> inf_point<span class="token punctuation">:</span>
                    point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux_right<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    remain_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux_right_remain<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                    k <span class="token operator">+=</span> <span class="token number">1</span>
                    j <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">break</span>
            <span class="token keyword">if</span> right_p <span class="token operator">==</span> inf_point<span class="token punctuation">:</span>
                <span class="token keyword">while</span> aux_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> inf_point<span class="token punctuation">:</span>
                    point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux_left<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                    remain_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux_left_remain<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                    k <span class="token operator">+=</span> <span class="token number">1</span>
                    i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">break</span>
            <span class="token comment"># 判断转向，d &lt; 0 表示(相对于 compare_point) right_p 在 left_p 的逆时针方法，所以 left_p 在极角序中更靠前</span>
            <span class="token comment"># d &gt; 0 反之。而 d == 0 表示三点共线</span>
            d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>compare_point<span class="token punctuation">,</span> left_p<span class="token punctuation">,</span> right_p<span class="token punctuation">)</span>
            <span class="token keyword">if</span> d <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_p
                remain_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux_left_remain<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                i <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">elif</span> d <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
                point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_p
                remain_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> aux_right_remain<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                j <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token comment"># d == 0 表示三点共线，则只按与 compare_point 的距离排序，越远越靠前</span>
            <span class="token comment"># 由于此时 left_p 与 right_p 共线，所以判断距离很容易，不用计算平方</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># 计算 x 坐标差距以及 y 坐标差距</span>
                left_dis_x <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_p<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> compare_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                left_dis_y <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>left_p<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> compare_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                right_dis_x <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right_p<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> compare_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                right_dis_y <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>right_p<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> compare_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token comment"># 此时选取差距较小的点，并把其 remain 标志位置为 False (排序之后的线性扫描会扔弃这些点)</span>
                remain_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>
                <span class="token keyword">if</span> left_dis_x <span class="token operator">&lt;</span> right_dis_x<span class="token punctuation">:</span>
                    point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_p
                    i <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token keyword">elif</span> left_dis_x <span class="token operator">&gt;</span> right_dis_x<span class="token punctuation">:</span>
                    point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_p
                    j <span class="token operator">+=</span> <span class="token number">1</span>
                <span class="token comment"># 如果 x 坐标差距相同，则比较 y 坐标差距</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token keyword">if</span> left_dis_y <span class="token operator">&lt;=</span> right_dis_y<span class="token punctuation">:</span>
                        point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> left_p
                        i <span class="token operator">+=</span> <span class="token number">1</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        point_list<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> right_p
                        j <span class="token operator">+=</span> <span class="token number">1</span>

    <span class="token comment"># Jarvis 步进法 - 给定点集，寻找该点集的凸包 convex hull</span>
    <span class="token comment"># 点集 Q 的要求：点数目 &gt;= 3，且至少存在不共线的 3 个点</span>
    <span class="token comment"># (可利用凸包求出该点集的最远点对 - O(n))</span>
    <span class="token comment"># 时间复杂度：O(nh) 其中 h 为凸包的顶点数目</span>
    <span class="token keyword">def</span> <span class="token function">convex_hull_jarvis_march</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 点集 Q 的要求：点数目 &gt;= 3，且至少存在不共线的 3 个点</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的点集至少应有 3 个点'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

        <span class="token comment"># 1. 选取点 p_0，它是 y 坐标最小的点 (如果有多个极小 y 坐标的点，则选取其中 x 坐标最小的点)</span>
        <span class="token comment">#    点 p_0 一定是凸包的一个顶点</span>
        p_0_index <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> index<span class="token punctuation">,</span> point <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span><span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">or</span> \
                    <span class="token punctuation">(</span>point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span><span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">and</span> point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span><span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                p_0_index <span class="token operator">=</span> index
        p_0 <span class="token operator">=</span> point_list<span class="token punctuation">[</span>p_0_index<span class="token punctuation">]</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>

        <span class="token comment"># 2. 循环过程中，每次选取一个点作为凸包的顶点，该点相对于前一个选出的点 具有最小的极角</span>
        <span class="token comment">#    循环从 p_0 开始，直至回到 p_0 为止。用极角的余弦值来比较极角的大小，余弦值越大、极角越小</span>
        <span class="token comment">#    由于对于凸包的每条边来说，凸包的点都仅位于此边的一侧，所以极角取值范围为 [0, \pi]，因此余弦值从 1 降至 -1</span>
        vertex_list <span class="token operator">=</span> <span class="token punctuation">[</span>p_0<span class="token punctuation">]</span>  <span class="token comment"># p_0 必选</span>
        first_flag <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token comment"># 初次选取标志</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token comment"># 2.1.1 首次选取需与向量 [0, 1] 夹角最小</span>
            <span class="token keyword">if</span> first_flag<span class="token punctuation">:</span>
                first_flag <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 去除首次循环标志</span>
                p_i <span class="token operator">=</span> p_0
                p_j <span class="token operator">=</span> Point<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token string">'first'</span><span class="token punctuation">,</span> vec<span class="token operator">=</span><span class="token punctuation">[</span>p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                vec_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
            <span class="token comment"># 2.1.2. 之后的每次选取点，需与 vertex_list 中最末两点形成的向量 pi pj 的夹角最小</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                p_i <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>vertex_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>
                p_j <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span><span class="token builtin">len</span><span class="token punctuation">(</span>vertex_list<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                vec_x <span class="token operator">=</span> <span class="token punctuation">[</span>p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

            <span class="token comment"># 2.2. min_point: 当前选择的最小极角的点 (不能选取 p_i 或 p_j)</span>
            first_index <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">while</span> point_list<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span> <span class="token operator">==</span> p_i <span class="token keyword">or</span> point_list<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span> <span class="token operator">==</span> p_j<span class="token punctuation">:</span>
                first_index <span class="token operator">+=</span> <span class="token number">1</span>
            min_point <span class="token operator">=</span> point_list<span class="token punctuation">[</span>first_index<span class="token punctuation">]</span>

            <span class="token comment"># 2.3. min_angle: 当前选择的最小极角(余弦值的平方)</span>
            <span class="token comment"># 由于对于凸包的每条边来说，凸包的点都仅位于此边的一侧，所以极角取值范围为 [0, \pi]，因此余弦值从 1 降至 -1</span>
            cur_vec <span class="token operator">=</span> <span class="token punctuation">[</span>min_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
            min_cos_angle <span class="token operator">=</span> self<span class="token punctuation">.</span>cos_angle<span class="token punctuation">(</span>vec_x<span class="token punctuation">,</span> cur_vec<span class="token punctuation">)</span>

            <span class="token comment"># 2.4. 进行选取</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                cur_point <span class="token operator">=</span> point_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token comment"># 每次选取不考虑 p_i 和 p_j 和 min_point</span>
                <span class="token keyword">if</span> cur_point <span class="token operator">==</span> p_i <span class="token keyword">or</span> cur_point <span class="token operator">==</span> p_j <span class="token keyword">or</span> cur_point <span class="token operator">==</span> min_point<span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>

                <span class="token comment"># 利用内积公式求夹角的余弦值</span>
                cur_vec <span class="token operator">=</span> <span class="token punctuation">[</span>cur_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cur_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                cur_cos <span class="token operator">=</span> self<span class="token punctuation">.</span>cos_angle<span class="token punctuation">(</span>vec_x<span class="token punctuation">,</span> cur_vec<span class="token punctuation">)</span>  <span class="token comment"># 余弦值</span>
                <span class="token keyword">assert</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;=</span> cur_cos <span class="token operator">&lt;=</span> <span class="token number">1</span>
                <span class="token keyword">if</span> cur_cos <span class="token operator">&gt;</span> min_cos_angle<span class="token punctuation">:</span>
                    min_cos_angle <span class="token operator">=</span> cur_cos
                    min_point <span class="token operator">=</span> cur_point

            <span class="token comment"># 2.5. 如果当前选出的点是 p_0，则结束凸包选取，否则把新选出的顶点加入 vertex_list 列表</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>min_point<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token keyword">if</span> min_point <span class="token operator">==</span> p_0<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                vertex_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>min_point<span class="token punctuation">)</span>

        <span class="token comment"># 3. 此时 vertex_list 是从 p_0 开始按逆时针方向排列的各个凸包顶点</span>
        <span class="token keyword">return</span> vertex_list

    <span class="token comment"># 旋转卡壳 (Rotating Calipers) 算法 - 给定凸多边形，求其最远点对</span>
    <span class="token comment"># 输入：凸包的顶点集 vertex_list</span>
    <span class="token comment"># 输出：最远点对</span>
    <span class="token comment"># 时间复杂度：O(n)</span>
    <span class="token keyword">def</span> <span class="token function">rotating_calipers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vertex_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vertex_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        n_vertex <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vertex_list<span class="token punctuation">)</span>
        <span class="token comment"># 0. 边界情况</span>
        <span class="token keyword">if</span> n_vertex <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的顶点不足 2 个'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> n_vertex <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的顶点仅有 2 个'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> vertex_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vertex_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>

        <span class="token comment"># 1. 记录 Point 对象到 vertex_list 下标的映射</span>
        point2index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> index<span class="token punctuation">,</span> point <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>vertex_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
            point2index<span class="token punctuation">[</span>point<span class="token punctuation">]</span> <span class="token operator">=</span> index

        <span class="token comment"># 2.1. 初次选取：默认 vertex_list 是从某点开始 按逆时针方向排列的各个凸包顶点</span>
        p_i<span class="token punctuation">,</span> p_next_i<span class="token punctuation">,</span> p_j <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vertex_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> vertex_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_j<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>

        <span class="token comment"># 2.2. 初次选取：找出离 p0 pi 最远的顶点 (最远，即形成的平行四边形面积最大，也即叉积值最大)</span>
        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_j<span class="token punctuation">)</span>
        max_cross <span class="token operator">=</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>
            self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
            self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_j<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
        max_cross <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>max_cross<span class="token punctuation">)</span>

        <span class="token comment"># 2.3. 初次选取：考察除了 p_0, p_i, p_j 外的各个点</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_vertex<span class="token punctuation">)</span><span class="token punctuation">:</span>
            cur_v <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>cur_v<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            <span class="token keyword">if</span> cur_v <span class="token operator">==</span> p_i <span class="token keyword">or</span> cur_v <span class="token operator">==</span> p_next_i <span class="token keyword">or</span> cur_v <span class="token operator">==</span> p_j<span class="token punctuation">:</span>
                <span class="token keyword">continue</span>

            cur_cross <span class="token operator">=</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>
                self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
                self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>cur_v<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
            cur_cross <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>cur_cross<span class="token punctuation">)</span>
            <span class="token keyword">if</span> cur_cross <span class="token operator">&gt;</span> max_cross<span class="token punctuation">:</span>
                max_cross <span class="token operator">=</span> cur_cross
                max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> cur_v<span class="token punctuation">)</span>

        <span class="token comment"># 3. 如果所有点均共线</span>
        <span class="token keyword">if</span> max_cross <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'凸多边形所有点共线，形成的面积为 0'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> max_pair

        <span class="token comment"># 4. 旋转卡壳 - 循环 n 次，n 为顶点数(也为边数)</span>
        <span class="token comment"># 用平行于 p0 pi 的两条边 (包含 p0 pi) &quot;夹住&quot;凸包，初始在边 p0 pi 处 &quot;卡壳&quot;</span>
        <span class="token comment"># 随后逆时针旋转平行边 (因为默认 vertex_list 是凸包顶点的逆时针序)，想象循转过程中保持夹紧凸包</span>
        <span class="token comment"># 每次旋转结束后，其中(至少)一条平行边会与凸包的某条边平行，然后考察此边的两端点与对点的距离</span>
        <span class="token comment"># 当前卡壳的边的两个端点 (也是凸包的两个顶点) 是 p_i 和 p_next_i</span>
        <span class="token comment"># 当前卡壳边的对点为 p_j, 而 p_i 和 p_j 形成转动的主轴</span>
        <span class="token comment"># 总共循转 n 次，每次循环会计算 2 次余弦值、2 次点对距离(的平方)</span>
        p_i<span class="token punctuation">,</span> p_j <span class="token operator">=</span> max_pair<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> max_pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        max_dis <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_j<span class="token punctuation">)</span>
        cur_calipers <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># True 表示当前卡壳的边是 p_i p_next_i, 否则为 p_j p_next_j</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_vertex<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># next_i 是 p_i 逆时针的下一个顶点下标</span>
            next_i <span class="token operator">=</span> <span class="token punctuation">(</span>point2index<span class="token punctuation">[</span>p_i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n_vertex
            p_next_i <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span>next_i<span class="token punctuation">]</span>
            <span class="token comment"># next_i 是 p_j 逆时针的下一个顶点下标</span>
            next_j <span class="token operator">=</span> <span class="token punctuation">(</span>point2index<span class="token punctuation">[</span>p_j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n_vertex
            p_next_j <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span>next_j<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_next_j<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>

            <span class="token comment"># 4.1. 如果当前卡壳的边是 p_i p_next_i</span>
            <span class="token keyword">if</span> cur_calipers<span class="token punctuation">:</span>
                <span class="token comment"># vec_x 是卡壳边的正向向量, vec_x_reverse 是卡壳边的反向向量</span>
                vec_x <span class="token operator">=</span> <span class="token punctuation">[</span>p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                vec_x_reverse <span class="token operator">=</span> <span class="token punctuation">[</span>p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                <span class="token comment"># 根据夹角大小，判断下一次旋转卡壳时的边，是 p_next_i p_next_next_i 还是 p_j p_next_j</span>
                next_next_i <span class="token operator">=</span> <span class="token punctuation">(</span>next_i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n_vertex
                p_next_next_i <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span>next_next_i<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_next_next_i<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>

                <span class="token comment"># 计算夹角的余弦值，值越大、夹角越小、对应的边越快卡壳</span>
                <span class="token comment"># 由于对于凸包的每条边来说，凸包的点都仅位于此边的一侧，所以极角取值范围为 [0, \pi]，因此余弦值从 1 降至 -1</span>
                cos_angle_i <span class="token operator">=</span> self<span class="token punctuation">.</span>cos_angle<span class="token punctuation">(</span>
                    vec_x<span class="token punctuation">,</span> <span class="token punctuation">[</span>p_next_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_next_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                cos_angle_j <span class="token operator">=</span> self<span class="token punctuation">.</span>cos_angle<span class="token punctuation">(</span>
                    vec_x_reverse<span class="token punctuation">,</span> <span class="token punctuation">[</span>p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

                <span class="token comment"># case 1: 如果下次 p_next_i p_next_next_i 卡壳 (还是 i 卡壳)</span>
                <span class="token keyword">if</span> cos_angle_i <span class="token operator">&gt;</span> cos_angle_j<span class="token punctuation">:</span>
                    cur_calipers <span class="token operator">=</span> <span class="token boolean">True</span>
                    <span class="token comment"># 以 p_next_i p_next_next_i 为卡壳边，以 p_j 为对点，计算距离</span>
                    cur_dis_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_j<span class="token punctuation">,</span> p_next_i<span class="token punctuation">)</span>
                    cur_dis_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_j<span class="token punctuation">,</span> p_next_next_i<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_1 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_1
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> p_j<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_2 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_2
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_next_next_i<span class="token punctuation">,</span> p_j<span class="token punctuation">)</span>

                <span class="token comment"># case 2: 如果下次 p_j p_next_j 卡壳 (改成了 j 卡壳)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    cur_calipers <span class="token operator">=</span> <span class="token boolean">False</span>
                    <span class="token comment"># 以 p_j p_next_j 为卡壳边，以 p_next_i 为对点，计算距离</span>
                    cur_dis_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> p_j<span class="token punctuation">)</span>
                    cur_dis_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> p_next_j<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_1 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_1
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> p_j<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_2 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_2
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> p_next_j<span class="token punctuation">)</span>

                <span class="token comment"># 更新移动(旋转)，原来的卡壳必然不会再卡壳，所以卡壳边的起点 p_i 要移动至下一个</span>
                p_i <span class="token operator">=</span> p_next_i
            <span class="token comment"># 4.2. 如果当前卡壳的边是 p_j p_next_j</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># vec_x 是卡壳边的正向向量, vec_x_reverse 是卡壳边的反向向量</span>
                vec_x <span class="token operator">=</span> <span class="token punctuation">[</span>p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                vec_x_reverse <span class="token operator">=</span> <span class="token punctuation">[</span>p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
                <span class="token comment"># 根据夹角大小，判断下一次旋转卡壳时的边，是 p_i p_next_i 还是 p_next_j p_next_next_j</span>
                next_next_j <span class="token operator">=</span> <span class="token punctuation">(</span>next_j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> n_vertex
                p_next_next_j <span class="token operator">=</span> vertex_list<span class="token punctuation">[</span>next_next_j<span class="token punctuation">]</span>

                <span class="token comment"># 计算夹角的余弦值，值越大、夹角越小、对应的边越快卡壳</span>
                <span class="token comment"># 由于对于凸包的每条边来说，凸包的点都仅位于此边的一侧，所以极角取值范围为 [0, \pi]，因此余弦值从 1 降至 -1</span>
                cos_angle_i <span class="token operator">=</span> self<span class="token punctuation">.</span>cos_angle<span class="token punctuation">(</span>
                    vec_x<span class="token punctuation">,</span> <span class="token punctuation">[</span>p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_next_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_i<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                cos_angle_j <span class="token operator">=</span> self<span class="token punctuation">.</span>cos_angle<span class="token punctuation">(</span>
                    vec_x_reverse<span class="token punctuation">,</span> <span class="token punctuation">[</span>p_next_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p_next_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> p_next_j<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

                <span class="token comment"># case 3: 如果下次 p_i p_next_i 卡壳 (改成了 i 卡壳)</span>
                <span class="token keyword">if</span> cos_angle_i <span class="token operator">&gt;</span> cos_angle_j<span class="token punctuation">:</span>
                    cur_calipers <span class="token operator">=</span> <span class="token boolean">True</span>
                    <span class="token comment"># 以 p_i p_next_i 为卡壳边，以 p_next_j 为对点，计算距离</span>
                    cur_dis_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_next_j<span class="token punctuation">,</span> p_i<span class="token punctuation">)</span>
                    cur_dis_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_next_j<span class="token punctuation">,</span> p_next_i<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_1 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_1
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_next_j<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_2 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_2
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_next_i<span class="token punctuation">,</span> p_next_j<span class="token punctuation">)</span>

                <span class="token comment"># case 4: 如果下次 p_next_j p_next_next_j 卡壳 (还是 j 卡壳)</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    cur_calipers <span class="token operator">=</span> <span class="token boolean">False</span>
                    <span class="token comment"># 以 p_next_j p_next_next_j 为卡壳边，以 p_i 为对点，计算距离</span>
                    cur_dis_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_next_j<span class="token punctuation">)</span>
                    cur_dis_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_next_next_j<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_1 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_1
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_next_j<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> cur_dis_2 <span class="token operator">&gt;</span> max_dis<span class="token punctuation">:</span>
                        max_dis <span class="token operator">=</span> cur_dis_2
                        max_pair <span class="token operator">=</span> <span class="token punctuation">(</span>p_i<span class="token punctuation">,</span> p_next_next_j<span class="token punctuation">)</span>

                <span class="token comment"># 更新移动(旋转)，原来的卡壳必然不会再卡壳，所以卡壳边的起点 p_i 要移动至下一个</span>
                p_j <span class="token operator">=</span> p_next_j

        <span class="token comment"># 5. 返回最大距离的点对 (tuple)</span>
        <span class="token keyword">return</span> max_pair

    <span class="token comment"># 给定点集，求出该点集的最近点对 (二维欧氏空间 - 平面)</span>
    <span class="token comment"># 输入：点集 point_list</span>
    <span class="token comment"># 输出：最近点对 及其距离</span>
    <span class="token comment"># 时间复杂度：O(n log n)</span>
    <span class="token keyword">def</span> <span class="token function">nearest_point_pair</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        n_points <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span>
        <span class="token comment"># 边界情况</span>
        <span class="token keyword">if</span> n_points <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的点不足 2 个'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span>
        <span class="token keyword">if</span> n_points <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的点仅有 2 个'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> n_points <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的点仅有 3 个'</span><span class="token punctuation">)</span>
            dis_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            dis_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            dis_3 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            min_dis <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dis_1<span class="token punctuation">,</span> dis_2<span class="token punctuation">,</span> dis_3<span class="token punctuation">)</span>
            <span class="token keyword">if</span> dis_1 <span class="token operator">==</span> min_dis<span class="token punctuation">:</span>
                <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> dis_2 <span class="token operator">==</span> min_dis<span class="token punctuation">:</span>
                <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> dis_3 <span class="token operator">==</span> min_dis<span class="token punctuation">:</span>
                <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>

        <span class="token comment"># 预排序</span>
        x_sorted_list <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># point_list 中的所有点按 x 坐标排序</span>
        y_sorted_list <span class="token operator">=</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># point_list 中的所有点按 y 坐标排序</span>

        <span class="token comment"># 分治法初始调用</span>
        p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> dis <span class="token operator">=</span> self<span class="token punctuation">.</span>nearest_point_pair_split<span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> x_sorted_list<span class="token punctuation">,</span> y_sorted_list<span class="token punctuation">)</span>
        <span class="token keyword">return</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> dis

    <span class="token comment"># 分治法</span>
    <span class="token comment"># 输入：point_list 点集、x_sorted_list 按 x 坐标升序排列的点集、y_sorted_list 按 y 坐标升序排列的点集</span>
    <span class="token comment"># 输出：当前子问题下的最近点对 及其距离</span>
    <span class="token keyword">def</span> <span class="token function">nearest_point_pair_split</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> point_list<span class="token punctuation">,</span> x_sorted_list<span class="token punctuation">,</span> y_sorted_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>point_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>x_sorted_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y_sorted_list<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        n_points <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>point_list<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x_sorted_list<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>y_sorted_list<span class="token punctuation">)</span> <span class="token operator">==</span> n_points
        <span class="token keyword">assert</span> n_points <span class="token operator">&gt;=</span> <span class="token number">2</span>
        <span class="token comment"># 1. 基本情况</span>
        <span class="token keyword">if</span> n_points <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            dis <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dis
        <span class="token keyword">if</span> n_points <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
            dis_1 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            dis_2 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            dis_3 <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            min_dis <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>dis_1<span class="token punctuation">,</span> dis_2<span class="token punctuation">,</span> dis_3<span class="token punctuation">)</span>
            <span class="token keyword">if</span> dis_1 <span class="token operator">==</span> min_dis<span class="token punctuation">:</span>
                <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_dis
            <span class="token keyword">if</span> dis_2 <span class="token operator">==</span> min_dis<span class="token punctuation">:</span>
                <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_dis
            <span class="token keyword">if</span> dis_3 <span class="token operator">==</span> min_dis<span class="token punctuation">:</span>
                <span class="token keyword">return</span> point_list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> point_list<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_dis

        <span class="token comment"># 2. 分解子问题：选取一个垂直线 l: x = x_0，将 point_list 分为两个集合 Pl 和 Pr</span>
        <span class="token comment">#    Pl 中的所有点的 x 坐标小于等于 x_0，而 Pr 中的所有点的 x 坐标大于等于 x_0</span>
        <span class="token comment">#    并且集合 Pl 的秩是 len(point_list) / 2 上取整，而 Pr 的秩是 len(point_list) / 2 下取整</span>
        <span class="token comment">#    首先切分 x_sorted_list</span>
        right_len <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x_sorted_list<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>
        left_len <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x_sorted_list<span class="token punctuation">)</span> <span class="token operator">-</span> right_len
        left_x_sorted_list <span class="token operator">=</span> x_sorted_list<span class="token punctuation">[</span><span class="token punctuation">:</span>left_len<span class="token punctuation">]</span>
        right_x_sorted_list <span class="token operator">=</span> x_sorted_list<span class="token punctuation">[</span>left_len<span class="token punctuation">:</span><span class="token punctuation">]</span>
        mid_point <span class="token operator">=</span> left_x_sorted_list<span class="token punctuation">[</span>left_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token comment"># 用字典记录属于左侧的点</span>
        is_left <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> left_x_sorted_list<span class="token punctuation">:</span>
            is_left<span class="token punctuation">[</span>point<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token comment"># 然后根据 is_left 切分 point_list 和 y_sorted_list</span>
        left_point_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        right_point_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        left_y_sorted_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        right_y_sorted_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> y_sorted_list<span class="token punctuation">:</span>
            <span class="token keyword">if</span> point <span class="token keyword">in</span> is_left<span class="token punctuation">:</span>
                left_y_sorted_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
                left_point_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                right_y_sorted_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
                right_point_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">)</span>

        <span class="token comment"># 3. 递归调用、解决子问题</span>
        left_p_1<span class="token punctuation">,</span> left_p_2<span class="token punctuation">,</span> left_dis <span class="token operator">=</span> self<span class="token punctuation">.</span>nearest_point_pair_split<span class="token punctuation">(</span>
            left_point_list<span class="token punctuation">,</span> left_x_sorted_list<span class="token punctuation">,</span> left_y_sorted_list<span class="token punctuation">)</span>
        right_p_1<span class="token punctuation">,</span> right_p_2<span class="token punctuation">,</span> right_dis <span class="token operator">=</span> self<span class="token punctuation">.</span>nearest_point_pair_split<span class="token punctuation">(</span>
            right_point_list<span class="token punctuation">,</span> right_x_sorted_list<span class="token punctuation">,</span> right_y_sorted_list<span class="token punctuation">)</span>

        <span class="token keyword">if</span> left_dis <span class="token operator">&lt;=</span> right_dis<span class="token punctuation">:</span>
            min_dis <span class="token operator">=</span> left_dis
            min_points <span class="token operator">=</span> <span class="token punctuation">(</span>left_p_1<span class="token punctuation">,</span> left_p_2<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            min_dis <span class="token operator">=</span> right_dis
            min_points <span class="token operator">=</span> <span class="token punctuation">(</span>right_p_1<span class="token punctuation">,</span> right_p_2<span class="token punctuation">)</span>

        <span class="token comment"># 4. 合并结果</span>
        <span class="token comment">#    检查最短点对是否为跨越 left 和 right 区域的点对</span>
        <span class="token comment">#    先创建新 list，仅保留 y_sorted_list 在中心线左右 min_dis 区域内的点</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>mid_point<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        mid_x <span class="token operator">=</span> mid_point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        l_bound <span class="token operator">=</span> mid_x <span class="token operator">-</span> min_dis
        r_bound <span class="token operator">=</span> mid_x <span class="token operator">+</span> min_dis
        new_y_sorted_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 这个 list 也是按 y 坐标的升序排列的</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> y_sorted_list<span class="token punctuation">:</span>
            <span class="token keyword">if</span> l_bound <span class="token operator">&lt;=</span> point<span class="token punctuation">.</span>vec<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r_bound<span class="token punctuation">:</span>
                new_y_sorted_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>point<span class="token punctuation">)</span>

        <span class="token comment"># 如果在区域内的点不足 2 个，则无需考虑跨越的情况</span>
        new_y_len <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>new_y_sorted_list<span class="token punctuation">)</span>
        <span class="token keyword">if</span> new_y_len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> min_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_dis

        <span class="token comment"># 然后对于 new_y_sorted_list 中的每个点 p 进行处理</span>
        <span class="token keyword">for</span> i<span class="token punctuation">,</span> point <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>new_y_sorted_list<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 计算 p 与紧随其后的(至多) 7 个点的距离，记录最近点对及其距离</span>
            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token punctuation">(</span>new_y_len<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                next_p <span class="token operator">=</span> new_y_sorted_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
                cur_dis <span class="token operator">=</span> self<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>point<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span>
                <span class="token keyword">if</span> cur_dis <span class="token operator">&lt;</span> min_dis<span class="token punctuation">:</span>
                    min_dis <span class="token operator">=</span> cur_dis
                    min_points <span class="token operator">=</span> <span class="token punctuation">(</span>point<span class="token punctuation">,</span> next_p<span class="token punctuation">)</span>

        <span class="token comment"># 5. 返回合并结果</span>
        <span class="token keyword">return</span> min_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_points<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> min_dis


<span class="token comment"># 红黑树的树结点</span>
<span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seg<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>seg <span class="token operator">=</span> seg       <span class="token comment"># 线段 Segment 结构体，根据叉积判断次序</span>
        self<span class="token punctuation">.</span>color <span class="token operator">=</span> color   <span class="token comment"># 结点的颜色，True 代表红色(默认)，False 代表黑色</span>
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>     <span class="token comment"># 左孩子指针</span>
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>    <span class="token comment"># 右孩子指针</span>
        self<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>   <span class="token comment"># 父结点指针</span>


<span class="token comment"># 用于扫除线过程中维护线段高低序的 红黑树 Red-Black Tree</span>
<span class="token comment"># 将基于关键字 key 的比较替换为基于叉积的比较</span>
<span class="token keyword">class</span> <span class="token class-name">SegmentRedBlackTree</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造 红黑树 Red-Black Tree</span>
    <span class="token comment"># 时间复杂度 O(n log n)</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>bst <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>seg<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 二叉搜索树结构，树根。初始设置任意属性的 TreeNode</span>
        self<span class="token punctuation">.</span>is_bst_empty <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 标志着当前 BST 是否为空</span>
        self<span class="token punctuation">.</span>seg2node <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment"># Segment 对象到 TreeNode 的映射</span>

        self<span class="token punctuation">.</span>nil <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>seg<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment"># 黑色的哨兵结点</span>
        self<span class="token punctuation">.</span>nil<span class="token punctuation">.</span>parent <span class="token operator">=</span> self<span class="token punctuation">.</span>nil   <span class="token comment"># 哨兵的父结点仍为自己</span>
        self<span class="token punctuation">.</span>nil<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil     <span class="token comment"># 哨兵的左孩子仍为自己</span>
        self<span class="token punctuation">.</span>nil<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil    <span class="token comment"># 哨兵的右孩子仍为自己</span>

    <span class="token comment"># 辅助操作：左旋。返回替代了 node 的新结点</span>
    <span class="token comment"># 时间复杂度 O(1)</span>
    <span class="token keyword">def</span> <span class="token function">_left_rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node_x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 对 x 进行左旋，即让 x 的右孩子 y (x.right) 成为 x 的父结点，且 x 等于 y.left。</span>
        <span class="token comment"># 而 y 结点原本的左孩子变为新 x 的右孩子</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果 x 是 BST 树根，那么树根要更换</span>
            <span class="token keyword">if</span> node_x <span class="token operator">==</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> node_x<span class="token punctuation">.</span>right

            <span class="token comment"># 调整树结构</span>
            node_y <span class="token operator">=</span> node_x<span class="token punctuation">.</span>right
            node_y<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x<span class="token punctuation">.</span>parent  <span class="token comment"># 设置 node_y 的父结点（互相关联）</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node_x <span class="token operator">==</span> node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node_y
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node_y

            node_x<span class="token punctuation">.</span>right <span class="token operator">=</span> node_y<span class="token punctuation">.</span>left  <span class="token comment"># y 结点原本的左孩子变为新 x 的右孩子</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_y<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node_y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x

            node_y<span class="token punctuation">.</span>left <span class="token operator">=</span> node_x
            node_x<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_y

            <span class="token comment"># 返回替代了 node 的结点 node_y</span>
            <span class="token keyword">return</span> node_y
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 辅助操作：右旋。返回替代了 node 的新结点</span>
    <span class="token comment"># 时间复杂度 O(1)</span>
    <span class="token keyword">def</span> <span class="token function">_right_rotate</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node_x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 对 x 进行右旋，即让 x 的左孩子 y (x.left) 成为 x 的父结点，且 x 等于 y.right。</span>
        <span class="token comment"># 而 y 结点原本的右孩子变为新 x 的左孩子</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 如果 x 是 BST 树根，那么树根要更换</span>
            <span class="token keyword">if</span> node_x <span class="token operator">==</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> node_x<span class="token punctuation">.</span>left

            <span class="token comment"># 调整树结构</span>
            node_y <span class="token operator">=</span> node_x<span class="token punctuation">.</span>left
            node_y<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x<span class="token punctuation">.</span>parent  <span class="token comment"># 设置 node_y 的父结点（互相关联）</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_x<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> node_x <span class="token operator">==</span> node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> node_y
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    node_x<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> node_y

            node_x<span class="token punctuation">.</span>left <span class="token operator">=</span> node_y<span class="token punctuation">.</span>right  <span class="token comment"># y 结点原本的右孩子变为新 x 的左孩子</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node_y<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                node_y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_x

            node_y<span class="token punctuation">.</span>right <span class="token operator">=</span> node_x
            node_x<span class="token punctuation">.</span>parent <span class="token operator">=</span> node_y

            <span class="token comment"># 返回替代了 node 的结点 node_y</span>
            <span class="token keyword">return</span> node_y
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 对于两个向量，逐元素地操作 (例如：加减乘除等)</span>
    <span class="token comment"># func 须是 lambda 表达式。默认为加法</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">vector_operation_by_ele</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        res_vec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            res_vec<span class="token punctuation">.</span>append<span class="token punctuation">(</span>func<span class="token punctuation">(</span>vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> res_vec

    <span class="token comment"># 计算两向量(列表)的内积/点积</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">inner_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token comment"># 对应位置相乘 再求和</span>
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">:</span>
            res <span class="token operator">+=</span> vec_1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">return</span> res

    <span class="token comment"># 计算两向量(列表)的叉积</span>
    <span class="token comment"># 这里只考虑维度为 2 或者 3 的情况</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">cross_product</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">)</span>
        dim <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vec_1<span class="token punctuation">)</span>
        <span class="token keyword">if</span> dim <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token comment"># 对二维向量 a = &lt;a_0, a_1&gt; 和 b = &lt;b_0, b_1&gt; 而言，返回(可正可负可零的)数值</span>
            <span class="token comment"># a x b = |a|·|b|·sin&lt;a, b&gt; 或者 a x b = det{{a_0, a_1}, {b_0, b_1}} 行列式值</span>
            <span class="token comment"># 如果该数值为正，则表示两向量夹角(不考虑周期)属于开区间 (0, \pi)</span>
            <span class="token comment"># 如果该数值为负，则表示两向量夹角(不考虑周期)属于开区间 (\pi, 2 \pi)</span>
            <span class="token comment"># 如果该数值为零，则表示两向量夹角(不考虑周期)要么是 0 要么是 \pi，故两向量共线</span>
            <span class="token keyword">return</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">elif</span> dim <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>
            <span class="token comment"># 对三维向量 a = &lt;a_0, a_1, a_2&gt; 和 b = &lt;b_0, b_1, b_2&gt; 而言，返回三维向量</span>
            <span class="token comment"># a x b = det{{i, j, k}, {a_0, a_1, a_2}, {b_0, b_1, b_2}} 行列式值</span>
            <span class="token comment"># 上式中的 i, j, k 分别为 x, y, z 轴方向的单位向量</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span>vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    vec_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> vec_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vec_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cross_product: 维度不为 2 或者 3'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 在二维空间中，对于首尾相接的两条有向线段 p0p1 和 p1p2</span>
    <span class="token comment"># 以 p0p1 的方向看过去，判断 p1p2 是向左 还是向右 还是不转向</span>
    <span class="token comment"># 只需计算 (p2 - p0) 和 (p1 - p0) 的叉积</span>
    <span class="token comment"># 如果结果为正值，表示向量 p0p2 在 p0p1 的顺时针方法，故在 p1 处需右转</span>
    <span class="token comment"># 如果结果为负值，表示向量 p0p2 在 p0p1 的逆时针方法，故在 p1 处需左转</span>
    <span class="token comment"># 如果结果为零，表示向量 p0p2 与 p0p1 共线，故在 p1 处不变方向 (或者反转 180 度)</span>
    <span class="token comment"># 时间复杂度：O(1)</span>
    <span class="token keyword">def</span> <span class="token function">direction</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_0<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> p_0<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_1<span class="token punctuation">.</span>dim <span class="token operator">==</span> p_2<span class="token punctuation">.</span>dim <span class="token operator">==</span> <span class="token number">2</span>  <span class="token comment"># 仅考虑二维欧氏空间</span>
        vec_02 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_2<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        vec_01 <span class="token operator">=</span> self<span class="token punctuation">.</span>vector_operation_by_ele<span class="token punctuation">(</span>p_1<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> p_0<span class="token punctuation">.</span>vec<span class="token punctuation">,</span> func<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">-</span> y<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>cross_product<span class="token punctuation">(</span>vec_02<span class="token punctuation">,</span> vec_01<span class="token punctuation">)</span>

    <span class="token comment"># 辅助操作：插入之后，逐级向上进行红黑性质维护</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token comment"># 根据当前结点的父结点、爷爷结点、叔叔结点的颜色，分 3 种情况，用旋转操作来调整平衡</span>
    <span class="token keyword">def</span> <span class="token function">_rb_insert_fixup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token comment"># 当前结点 node 为新插入的结点，是红色的</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                <span class="token comment"># node 的爷爷结点必为树结点 (红黑树性质)</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token comment"># node 的爷爷结点为 nil 结点，而且父结点存在</span>
                    <span class="token comment"># 这表示父结点为树根，且根是红色。只需要把根改为黑色即可</span>
                    <span class="token keyword">assert</span> node<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>bst
                    self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token comment"># node 的爷爷结点为树结点，且非 nil</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                        <span class="token comment"># 如果 node 的父结点是 node 爷爷结点的左孩子</span>
                        uncle <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>uncle<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> uncle<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 1: 父结点为红色、父结点是爷爷结点的左孩子、叔叔结点也为红色</span>
                            <span class="token comment"># 这种情况可以直接处理掉</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置父结点的颜色为黑色</span>
                            uncle<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置叔叔结点的颜色为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 置爷爷结点颜色为红色</span>
                            node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其爷爷结点</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 此时：父结点为红色、父结点是爷爷结点的左孩子、叔叔结点不存在或者为黑色</span>
                            <span class="token keyword">if</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                <span class="token comment"># case 2: 父结点为红色、父结点是爷爷结点的左孩子、</span>
                                <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的右孩子</span>
                                <span class="token comment"># 这种情况先转换成 case 3，然后再处理掉</span>
                                node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其父（旋转后会降下来）</span>
                                self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">)</span>  <span class="token comment"># 左旋，&quot;拉直&quot; 呈 LL 型</span>
                            <span class="token comment"># case 3: 父结点为红色、父结点是爷爷结点的左孩子、</span>
                            <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的左孩子</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改父结点为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改爷爷结点为红色</span>
                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>  <span class="token comment"># 右旋爷爷结点</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 如果 node 的父结点是 node 爷爷结点的右孩子（与前述操作呈镜像处理，减少注释）</span>
                        uncle <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left
                        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>uncle<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> uncle<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 1': 父结点为红色、父结点是爷爷结点的右孩子、叔叔结点也为红色</span>
                            <span class="token comment"># 这种情况可以直接处理掉</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置父结点的颜色为黑色</span>
                            uncle<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 置叔叔结点的颜色为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 置爷爷结点颜色为红色</span>
                            node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其爷爷结点</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 此时：父结点为红色、父结点是爷爷结点的右孩子、叔叔结点不存在或者为黑色</span>
                            <span class="token keyword">if</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                <span class="token comment"># case 2': 父结点为红色、父结点是爷爷结点的右孩子、</span>
                                <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的左孩子</span>
                                <span class="token comment"># 这种情况先转换成 case 3，然后再处理掉</span>
                                node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移至其父（旋转后会降下来）</span>
                                self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">)</span>  <span class="token comment"># 右旋，&quot;拉直&quot; 呈 RR 型</span>
                            <span class="token comment"># case 3': 父结点为红色、父结点是爷爷结点的右孩子、</span>
                            <span class="token comment"># 叔叔结点不存在或者为黑色、当前结点是父结点的右孩子</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改父结点为黑色</span>
                            node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改爷爷结点为红色</span>
                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>  <span class="token comment"># 左旋爷爷结点</span>

            <span class="token comment"># while 循环结束、处理完毕，如果此时树根存在，则置为黑色</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>bst<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> self<span class="token punctuation">.</span>bst <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token comment"># 辅助操作：新建树结点</span>
    <span class="token keyword">def</span> <span class="token function">_create_new_node</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> new_seg<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        new_node <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span>new_seg<span class="token punctuation">,</span> color<span class="token operator">=</span>color<span class="token punctuation">)</span>
        new_node<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
        new_node<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
        self<span class="token punctuation">.</span>seg2node<span class="token punctuation">[</span>new_seg<span class="token punctuation">]</span> <span class="token operator">=</span> new_node  <span class="token comment"># 记录映射关系</span>
        <span class="token keyword">return</span> new_node

    <span class="token comment"># 辅助函数：清除某个结点的所有指针域</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">_clear_node_link</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            node<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token boolean">None</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token boolean">None</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token comment"># 根据 Endpoint 端点对象增加结点 (可以根据端点对象找出其所在的 Segment 线段对象)</span>
    <span class="token comment"># 增加后（每次都增加叶结点），调用 rb_insert_fixup 维护红黑性质</span>
    <span class="token comment"># 刚插入新结点时，仅可能违反第四条红黑性质：每个红色结点的子结点都只能是黑色的。</span>
    <span class="token comment"># 而调整过程中，可能会违反其它性质，但都会一一修复</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">rb_insert</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> insert_ep<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>insert_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
        insert_seg <span class="token operator">=</span> insert_ep<span class="token punctuation">.</span>seg
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>insert_seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_bst_empty<span class="token punctuation">:</span>
            <span class="token comment"># 如果当前 BST 为空，则直接设置 self.bst 结点，完成插入</span>
            new_node <span class="token operator">=</span> self<span class="token punctuation">.</span>_create_new_node<span class="token punctuation">(</span>insert_seg<span class="token punctuation">)</span>
            new_node<span class="token punctuation">.</span>parent <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
            self<span class="token punctuation">.</span>bst <span class="token operator">=</span> new_node
            self<span class="token punctuation">.</span>is_bst_empty <span class="token operator">=</span> <span class="token boolean">False</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            ptr <span class="token operator">=</span> self<span class="token punctuation">.</span>bst           <span class="token comment"># 用 ptr 指针从 root 结点（一般设为 self.bst）开始向下搜索插入位置</span>
            ptr_p <span class="token operator">=</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>parent  <span class="token comment"># ptr_p 记录 ptr 的父亲</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> ptr <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                ptr_p <span class="token operator">=</span> ptr
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
                p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>to_point
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
                <span class="token comment"># 根据顶点转向决定 往左还是往右</span>
                d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> insert_ep<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right

            <span class="token comment"># 找到了插入位置，设置新结点属性：红色、左孩子和右孩子均为哨兵 nil、父结点为 ptr_p</span>
            new_node <span class="token operator">=</span> self<span class="token punctuation">.</span>_create_new_node<span class="token punctuation">(</span>insert_seg<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>

            <span class="token comment"># 根据顶点转向决定 该插入到左边还是右边</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr_p<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
            p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> ptr_p<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> ptr_p<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>to_point
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
            d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> insert_ep<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
            <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                ptr_p<span class="token punctuation">.</span>left <span class="token operator">=</span> new_node
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                ptr_p<span class="token punctuation">.</span>right <span class="token operator">=</span> new_node
            new_node<span class="token punctuation">.</span>parent <span class="token operator">=</span> ptr_p

            self<span class="token punctuation">.</span>_rb_insert_fixup<span class="token punctuation">(</span>new_node<span class="token punctuation">)</span>  <span class="token comment"># 插入后维护红黑性质</span>

    <span class="token comment"># 辅助操作：将结点 u 替换为结点 v（用于删除时的红黑性质保持）</span>
    <span class="token comment"># 时间复杂度 O(1)</span>
    <span class="token keyword">def</span> <span class="token function">_rb_transplant</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> u <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">or</span> u<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> v
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token comment"># u 的父结点必为树结点 (红黑树性质)</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token comment"># 根据 u 是其父结点的左孩子还是右孩子，更换指针</span>
                <span class="token keyword">if</span> u <span class="token operator">==</span> u<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    u<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> v
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    u<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> v
        <span class="token comment"># 无条件执行：让 v 的 parent 指针指向 u 的父结点</span>
        v<span class="token punctuation">.</span>parent <span class="token operator">=</span> u<span class="token punctuation">.</span>parent

    <span class="token comment"># 辅助操作：删除之后，逐级向上进行红黑性质维护</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token comment"># 当删除结点 node 时，让其后继 s 替换 node。在结点被移除或者在树中移动之前，必须先记录 s 的颜色</span>
    <span class="token comment"># 根据当前结点的父结点、兄弟结点、兄弟结点的孩子结点的颜色，分 4 种情况，用旋转操作来调整平衡</span>
    <span class="token keyword">def</span> <span class="token function">_rb_delete_fixup</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># if isinstance(node, TreeNode) and node != self.nil:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>bst<span class="token punctuation">:</span>
            <span class="token comment"># 当前结点 node 为真正需要被删除的结点，其祖先中有黑色结点被删除(替换)了</span>
            <span class="token keyword">while</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>bst <span class="token keyword">and</span> <span class="token keyword">not</span> node<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                <span class="token comment"># node 的父结点必为树结点 (红黑树性质)</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token comment"># 父结点是 nil，表示当前 node 为树根，只需要把根改为黑色即可</span>
                    <span class="token keyword">assert</span> node <span class="token operator">==</span> self<span class="token punctuation">.</span>bst
                    self<span class="token punctuation">.</span>bst<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                <span class="token keyword">elif</span> node <span class="token operator">==</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                    <span class="token comment"># 如果 node 是其父结点的左孩子</span>
                    <span class="token comment"># node 的父结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token comment"># 记录 bro 为 node 父结点的右孩子，即 node 的兄弟结点</span>
                    bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                    <span class="token comment"># node 的兄弟结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 1: node 是其父结点的左孩子、其兄弟结点 bro 为红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 让 bro 的颜色改为黑色</span>
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                    <span class="token comment"># bro 结点的孩子必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">and</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 2: 此时兄弟结点 bro 一定为黑色，如果原本不是黑色，会经过 case 1 变为黑色</span>
                        <span class="token comment"># 此时 bro 孩子均为黑色，让 bro 变为 红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 此时 bro 的孩子不全为黑色</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 3: 此时 node 是其父结点的左孩子，且兄弟结点 bro 一定为黑色</span>
                            <span class="token comment"># bro 的左孩子为红色，右孩子为黑色</span>
                            bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改 bro 左孩子为黑色</span>
                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改 bro 为红色（一红挂两黑）</span>
                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>  <span class="token comment"># 右旋 bro</span>
                            bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                            <span class="token comment"># case 3 之后，保证 bro 为黑色、bro 的右孩子为红色</span>
                        <span class="token comment"># case 4: 此时 node 是其父结点的左孩子，且兄弟结点 bro 一定为黑色</span>
                        <span class="token comment"># bro 的右孩子为红色，左孩子颜色为黑色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        node <span class="token operator">=</span> self<span class="token punctuation">.</span>bst

                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token comment"># 如果 node 是其父结点的右孩子</span>
                    <span class="token comment"># node 的父结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token comment"># 记录 bro 为 node 父结点的左孩子，即 node 的兄弟结点</span>
                    bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left
                    <span class="token comment"># node 的兄弟结点必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 1': node 是其父结点的右孩子、其兄弟结点 bro 为红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 让 bro 的颜色改为黑色</span>
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                    <span class="token comment"># bro 结点的孩子必为树结点 (红黑树性质)</span>
                    <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bro<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">and</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                        <span class="token comment"># case 2': 此时兄弟结点 bro 一定为黑色，如果原本不是黑色，会经过 case 1' 变为黑色</span>
                        <span class="token comment"># 此时 bro 孩子均为黑色，让 bro 变为 红色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent  <span class="token comment"># node 上移</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 此时 bro 的孩子不全为黑色</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token comment"># case 3': 此时 node 是其父结点的右孩子，且兄弟结点 bro 一定为黑色</span>
                            <span class="token comment"># bro 的左孩子为黑色，右孩子为红色</span>
                            bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 修改 bro 右孩子为黑色</span>
                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 修改 bro 为红色（一红挂两黑）</span>
                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>  <span class="token comment"># 左旋 bro</span>
                            bro <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left  <span class="token comment"># 确保 bro 还是 node 的兄弟结点</span>
                            <span class="token comment"># case 3' 之后，保证 bro 为黑色、bro 的左孩子为红色</span>
                        <span class="token comment"># case 4': 此时 node 是其父结点的右孩子，且兄弟结点 bro 一定为黑色</span>
                        <span class="token comment"># bro 的左孩子为红色，右孩子颜色为黑色</span>
                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color
                        node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                        node <span class="token operator">=</span> self<span class="token punctuation">.</span>bst

            <span class="token comment"># 最终将 node 的颜色置为黑色</span>
            node<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token comment"># 根据 Endpoint 端点对象删除结点 (可以根据端点对象找出其所在的 Segment 线段对象)</span>
    <span class="token comment"># 删除黑色结点时，可能违反红黑性质，需要调用 rb_delete_fixup 维护红黑性质</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">rb_delete</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">,</span> delete_ep<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>delete_ep<span class="token punctuation">,</span> Endpoint<span class="token punctuation">)</span>
        delete_seg <span class="token operator">=</span> delete_ep<span class="token punctuation">.</span>seg
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>delete_seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>is_bst_empty<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'提示：红黑树为空，无法继续删除。'</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            ptr <span class="token operator">=</span> root               <span class="token comment"># 用 ptr 指针从 root 结点（一般设为 self.bst）开始向下搜索删除位置</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> ptr <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>seg<span class="token punctuation">,</span> Segment<span class="token punctuation">)</span>
                <span class="token keyword">if</span> delete_seg <span class="token operator">==</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">:</span>
                    <span class="token keyword">break</span>  <span class="token comment"># 定位到了目标删除结点</span>
                p_1<span class="token punctuation">,</span> p_2 <span class="token operator">=</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>from_point<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>seg<span class="token punctuation">.</span>to_point
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span>
                <span class="token comment"># 根据顶点转向决定 往左还是往右</span>
                d <span class="token operator">=</span> self<span class="token punctuation">.</span>direction<span class="token punctuation">(</span>p_1<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> delete_ep<span class="token punctuation">.</span>point<span class="token punctuation">)</span>
                <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    ptr <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right

            <span class="token comment"># 若没找到目标结点</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
            <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'提示：删除时，找不到目标元素'</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">assert</span> ptr<span class="token punctuation">.</span>seg <span class="token keyword">in</span> self<span class="token punctuation">.</span>seg2node
                self<span class="token punctuation">.</span>seg2node<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>seg<span class="token punctuation">)</span>  <span class="token comment"># 删除映射关系</span>
                <span class="token comment"># 调整树结构</span>
                <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">and</span> ptr<span class="token punctuation">.</span>seg <span class="token operator">==</span> delete_seg <span class="token keyword">and</span> \
                        <span class="token punctuation">(</span><span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">)</span> <span class="token keyword">and</span> \
                        <span class="token punctuation">(</span><span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>right <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">)</span><span class="token punctuation">:</span>
                    <span class="token comment"># 当前 BST 仅有一个根结点 ptr，且欲删除根结点，会导致树空</span>
                    self<span class="token punctuation">.</span>bst <span class="token operator">=</span> <span class="token boolean">None</span>
                    self<span class="token punctuation">.</span>is_bst_empty <span class="token operator">=</span> <span class="token boolean">True</span>
                <span class="token keyword">else</span><span class="token punctuation">:</span>
                    <span class="token comment"># 正常删除结点 ptr，不会导致树变为空</span>
                    <span class="token comment"># 这里的 y 主要用于记录 ptr 的后继，而 x 是覆盖了&quot;真正被删除的结点&quot;的结点</span>
                    <span class="token comment"># 如果 x 覆盖了一个黑色的结点，那么在最后 需要从 x 开始向上调整红黑性质</span>
                    y <span class="token operator">=</span> ptr
                    y_original_color <span class="token operator">=</span> y<span class="token punctuation">.</span>color  <span class="token comment"># 记录 y 原始的颜色，用于最后判断是否需要维护红黑性质</span>

                    <span class="token keyword">if</span> ptr<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> ptr<span class="token punctuation">.</span>right <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                        <span class="token comment"># 如果欲删除结点 ptr 的左右孩子均为空，则为叶，没有孩子可以覆盖 ptr</span>
                        <span class="token comment"># 先让 ptr 父结点的相应孩子指针指向 self.nil</span>
                        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                        <span class="token keyword">if</span> ptr <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                            ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                            bro <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                            bro <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left

                        <span class="token comment"># 如果欲删除的叶结点 ptr 为红色，那么红黑性质不会被破坏</span>
                        <span class="token keyword">if</span> ptr<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token keyword">return</span>
                        <span class="token comment"># 如果欲删除的叶结点 ptr 为黑色，那么红黑性质会被破坏，其父结点的左侧&quot;黑高&quot;低于右侧&quot;黑高&quot;</span>
                        <span class="token comment"># 因为原本红黑性质是满足的，所以此时 (删除 ptr 前) 只有如下这几种可能：</span>
                        <span class="token comment"># 1. ptr 为黑、ptr 的父结点为黑</span>
                        <span class="token keyword">if</span> <span class="token keyword">not</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                            <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil  <span class="token comment"># 兄弟必存在，否则原本就不符合红黑性质了</span>
                            <span class="token comment"># 1.1. ptr 为黑、ptr 的父结点为黑、ptr 的兄弟结点为红</span>
                            <span class="token comment"># 那么 bro 必有两个黑孩子，而且 bro 的黑孩子必为叶</span>
                            <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                                <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                                <span class="token comment"># 1.1.1. 如果 bro 是右孩子</span>
                                <span class="token comment"># 则此时只需要把 bro 染黑、bro 的左孩子染红，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                <span class="token keyword">if</span> bro <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token comment"># 1.1.2. 如果 bro 是左孩子</span>
                                <span class="token comment"># 则此时只需要把 bro 染黑、bro 的右孩子染红，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                            <span class="token comment"># 1.2. ptr 为黑、ptr 的父结点为黑、ptr 的兄弟结点为黑</span>
                            <span class="token comment"># 那么 bro 若有孩子，必为红孩子，而且 bro 的红孩子必为叶</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 1.1.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">if</span> bro <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时只需要把 bro 的右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的左孩子染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，原本的&quot;黑高&quot;为 2 定然无法维持</span>
                                        <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                                <span class="token comment"># 1.1.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时只需要把 bro 的左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的右孩子染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，而原本&quot;黑高&quot;为 2，定然无法维持</span>
                                        <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                        <span class="token comment"># 2. ptr 为黑、ptr 的父结点为红</span>
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 此时兄弟必存在，且为黑，否则原本就不符合红黑性质了</span>
                            <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                            <span class="token comment"># 类似 1.2. 处理</span>
                            <span class="token comment"># 2.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                            <span class="token keyword">if</span> bro <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                    <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

                            <span class="token comment"># 2.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                    self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                    self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                    <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                    bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                        <span class="token keyword">return</span>
                    <span class="token comment"># 如果进入下面的分支，ptr 不为叶</span>
                    <span class="token keyword">elif</span> ptr<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                        <span class="token comment"># 如果欲删除结点 ptr 的左孩子为空，且右孩子不为空，则将 ptr 替换为其右孩子</span>
                        x <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                        self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                    <span class="token keyword">elif</span> ptr<span class="token punctuation">.</span>right <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                        <span class="token comment"># 如果欲删除结点 ptr 的右孩子为空，且左孩子不为空，则将 ptr 替换为其左孩子</span>
                        x <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                        self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> ptr<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        <span class="token comment"># 欲删除结点 ptr 的左右孩子均不为空，则将 ptr 替换为其后继</span>
                        y <span class="token operator">=</span> self<span class="token punctuation">.</span>below<span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>     <span class="token comment"># y 为 ptr 的后继，y 的左孩子为 nil</span>
                        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> y<span class="token punctuation">.</span>left <span class="token operator">==</span> self<span class="token punctuation">.</span>nil
                        y_original_color <span class="token operator">=</span> y<span class="token punctuation">.</span>color  <span class="token comment"># (修改)记录 y 原始的颜色</span>
                        x <span class="token operator">=</span> y<span class="token punctuation">.</span>right  <span class="token comment"># 后继结点 y 必无左孩子，让其右孩子 x 替换 y</span>

                        <span class="token keyword">if</span> x <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                            <span class="token comment"># 如果 x 是哨兵 nil，意味着 y 是叶，类似前面 ptr 为叶的处理方式</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                            <span class="token comment"># 如果欲删除结点 y 的左右孩子均为空，则为叶，没有孩子可以覆盖 y</span>
                            <span class="token comment"># 先让 y 父结点的相应孩子指针指向 self.nil</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span>
                            <span class="token keyword">if</span> y <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                                bro <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>nil
                                bro <span class="token operator">=</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left

                            <span class="token comment"># 如果欲删除的叶结点 y 为红色，那么红黑性质不会被破坏</span>
                            <span class="token keyword">if</span> y<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                <span class="token comment"># 把 ptr 替换为其后继结点 y，并修改链接关系和 color (不修改 y 的 key、value)</span>
                                <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                    self<span class="token punctuation">.</span>bst <span class="token operator">=</span> y
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 根据 u 是其父结点的左孩子还是右孩子，更换指针</span>
                                    <span class="token keyword">if</span> ptr <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                        ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> y
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> y
                                <span class="token comment"># 让 y 的 parent 指针指向 ptr 的父结点</span>
                                y<span class="token punctuation">.</span>parent <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent
                                y<span class="token punctuation">.</span>left <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                                y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                                y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                                y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                                y<span class="token punctuation">.</span>color <span class="token operator">=</span> ptr<span class="token punctuation">.</span>color  <span class="token comment"># y 继承 ptr 的颜色</span>
                                <span class="token keyword">return</span>
                            <span class="token comment"># 如果欲删除的叶结点 y 为黑色，那么红黑性质会被破坏，其父结点的左侧&quot;黑高&quot;低于右侧&quot;黑高&quot;</span>
                            <span class="token comment"># 因为原本红黑性质是满足的，所以此时 (删除 y 前) 只有如下这几种可能：</span>
                            <span class="token comment"># 1. y 为黑、y 的父结点为黑</span>
                            <span class="token keyword">if</span> <span class="token keyword">not</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil  <span class="token comment"># 兄弟必存在，否则原本就不符合红黑性质了</span>
                                <span class="token comment"># 1.1. y 为黑、y 的父结点为黑、y 的兄弟结点为红</span>
                                <span class="token comment"># 那么 bro 必有两个黑孩子，而且 bro 的黑孩子必为叶</span>
                                <span class="token keyword">if</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                                    <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                                    <span class="token keyword">assert</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                                    <span class="token comment"># 1.1.1. 如果 bro 是右孩子</span>
                                    <span class="token comment"># 则此时只需要把 bro 染黑、bro 的左孩子染红，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 1.1.2. 如果 bro 是左孩子</span>
                                    <span class="token comment"># 则此时只需要把 bro 染黑、bro 的右孩子染红，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                                <span class="token comment"># 1.2. y 为黑、y 的父结点为黑、y 的兄弟结点为黑</span>
                                <span class="token comment"># 那么 bro 若有孩子，必为红孩子，而且 bro 的红孩子必为叶</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 1.1.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                                    <span class="token keyword">if</span> bro <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时只需要把 bro 的右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                        <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时把 bro 的左孩子染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                        <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                                            <span class="token comment"># 如果 bro 的左右孩子都不存在，原本的&quot;黑高&quot;为 2 定然无法维持</span>
                                            <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                            self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                                    <span class="token comment"># 1.1.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时只需要把 bro 的左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                        <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                        <span class="token comment"># 则此时把 bro 的右孩子染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                        <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                            <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                            bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                            self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                            self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                                            <span class="token comment"># 如果 bro 的左右孩子都不存在，而原本&quot;黑高&quot;为 2，定然无法维持</span>
                                            <span class="token comment"># 此时将 bro 染红，然后从父结点(&quot;双黑&quot;)开始 fixup</span>
                                            bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                            self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>y<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>

                            <span class="token comment"># 2. y 为黑、y 的父结点为红</span>
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 此时兄弟必存在，且为黑，否则原本就不符合红黑性质了</span>
                                <span class="token keyword">assert</span> bro <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token keyword">not</span> bro<span class="token punctuation">.</span>color<span class="token punctuation">)</span>
                                <span class="token comment"># 类似 1.2. 处理</span>
                                <span class="token comment"># 2.1. 如果 bro 是右孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">if</span> bro <span class="token operator">==</span> y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right<span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 右孩子染黑，然后把 bro 父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的右孩子不存在，但左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 右旋、再原父结点左旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                        <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

                                <span class="token comment"># 2.2. 如果 bro 是左孩子，检查 bro 的孩子情况</span>
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    <span class="token comment"># 如果 bro 的左孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 染红、bro 父结点和 bro 左孩子染黑，然后把 bro 父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">if</span> bro<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        bro<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token comment"># 如果 bro 的左孩子不存在，但右孩子存在(必为红)</span>
                                    <span class="token comment"># 则此时把 bro 的父结点染黑，然后先 bro 左旋、再原父结点右旋，就维护好红黑性质了</span>
                                    <span class="token keyword">elif</span> bro<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                        <span class="token keyword">assert</span> bro<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token keyword">is</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
                                        self<span class="token punctuation">.</span>_left_rotate<span class="token punctuation">(</span>bro<span class="token punctuation">)</span>
                                        self<span class="token punctuation">.</span>_right_rotate<span class="token punctuation">(</span>ptr<span class="token punctuation">.</span>parent<span class="token punctuation">)</span>
                                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                                        <span class="token comment"># 如果 bro 的左右孩子都不存在，原本&quot;黑高&quot;为 1，只通过染色就可以维持</span>
                                        <span class="token comment"># 此时将 bro 染红、父结点染黑即可</span>
                                        bro<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                                        y<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>

                            <span class="token comment"># 把 ptr 替换为其后继结点 y，并修改链接关系和 color (不修改 y 的 key、value)</span>
                            <span class="token keyword">if</span> ptr <span class="token operator">==</span> self<span class="token punctuation">.</span>bst <span class="token keyword">or</span> ptr<span class="token punctuation">.</span>parent <span class="token operator">==</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                                self<span class="token punctuation">.</span>bst <span class="token operator">=</span> y
                            <span class="token keyword">else</span><span class="token punctuation">:</span>
                                <span class="token comment"># 根据 u 是其父结点的左孩子还是右孩子，更换指针</span>
                                <span class="token keyword">if</span> ptr <span class="token operator">==</span> ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left<span class="token punctuation">:</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">=</span> y
                                <span class="token keyword">else</span><span class="token punctuation">:</span>
                                    ptr<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">=</span> y
                            <span class="token comment"># 让 y 的 parent 指针指向 ptr 的父结点</span>
                            y<span class="token punctuation">.</span>parent <span class="token operator">=</span> ptr<span class="token punctuation">.</span>parent
                            y<span class="token punctuation">.</span>left <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                            y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                            y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                            y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                            y<span class="token punctuation">.</span>color <span class="token operator">=</span> ptr<span class="token punctuation">.</span>color  <span class="token comment"># y 继承 ptr 的颜色</span>
                            <span class="token keyword">return</span>
                        <span class="token comment"># 此时后继 y 一定有右孩子，x 不可能为 self.nil</span>
                        <span class="token keyword">if</span> y<span class="token punctuation">.</span>parent <span class="token operator">==</span> ptr<span class="token punctuation">:</span>
                            <span class="token comment"># 如果 ptr 的后继 y 就是 ptr 的直接右孩子</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> x <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                        <span class="token keyword">else</span><span class="token punctuation">:</span>
                            <span class="token comment"># 如果 ptr 的后继 y 不是 ptr 的直接右孩子</span>
                            <span class="token comment"># 让 y 被其右孩子替换（因为之后 y 要用于替换 ptr）</span>
                            <span class="token comment"># 所以替换了 y 的结点就是 y.right，也即 x</span>
                            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> y<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil
                            self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>y<span class="token punctuation">,</span> y<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
                            y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                            y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y

                        <span class="token comment"># 现在把 ptr 替换为其后继结点 y，并修改链接关系和 color (不修改 y 的 key、value)</span>
                        self<span class="token punctuation">.</span>_rb_transplant<span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
                        y<span class="token punctuation">.</span>left <span class="token operator">=</span> ptr<span class="token punctuation">.</span>left
                        y<span class="token punctuation">.</span>left<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                        y<span class="token punctuation">.</span>right <span class="token operator">=</span> ptr<span class="token punctuation">.</span>right
                        y<span class="token punctuation">.</span>right<span class="token punctuation">.</span>parent <span class="token operator">=</span> y
                        y<span class="token punctuation">.</span>color <span class="token operator">=</span> ptr<span class="token punctuation">.</span>color  <span class="token comment"># y 继承 ptr 的颜色</span>
                    <span class="token comment"># 最后，如果&quot;真正&quot;删除的结点颜色为黑色，则破坏了红黑性质，需要进行维护</span>
                    <span class="token keyword">if</span> <span class="token keyword">not</span> y_original_color<span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>_rb_delete_fixup<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 删除后维护红黑性质</span>

    <span class="token comment"># 找到一棵以 root 为根的 BST/RBT 中的最上方结点（一路左转）</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">highest_bst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
            <span class="token keyword">return</span> root
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 找到一棵以 root 为根的 BST/RBT 中的最下方结点（一路右转）</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">lowest_bst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> root<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
            <span class="token keyword">return</span> root
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 找到在 BST 中 node 结点的前驱结点</span>
    <span class="token comment"># 如果 node 的左孩子存在，则 node 的前驱就是其左子树中的最大值</span>
    <span class="token comment"># 如果 node 的左孩子不存在，则 node 的前驱是其某个祖先结点 a，满足此时 a.right == node</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">above</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>left <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>lowest_bst<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> node<span class="token punctuation">.</span>parent <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>right <span class="token operator">==</span> node<span class="token punctuation">:</span>
                        <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
                <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 找到在 BST 中 node 结点的后继结点</span>
    <span class="token comment"># 如果 node 的右孩子存在，则 node 的后继就是其右子树中的最小值</span>
    <span class="token comment"># 如果 node 的右孩子不存在，则 node 的前驱是其某个祖先结点 a，满足此时 a.left == node</span>
    <span class="token comment"># 时间复杂度 O(log n) 与树高有关</span>
    <span class="token keyword">def</span> <span class="token function">below</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
            <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> TreeNode<span class="token punctuation">)</span> <span class="token keyword">and</span> node<span class="token punctuation">.</span>right <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>highest_bst<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">while</span> node<span class="token punctuation">.</span>parent <span class="token operator">!=</span> self<span class="token punctuation">.</span>nil<span class="token punctuation">:</span>
                    <span class="token keyword">if</span> node<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>left <span class="token operator">==</span> node<span class="token punctuation">:</span>
                        <span class="token keyword">return</span> node<span class="token punctuation">.</span>parent
                    <span class="token keyword">else</span><span class="token punctuation">:</span>
                        node <span class="token operator">=</span> node<span class="token punctuation">.</span>parent
                <span class="token keyword">return</span> <span class="token boolean">None</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    cg <span class="token operator">=</span> ComputationalGeometry<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 给定两条线段，判断二者是否相交</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n给定两条线段，判断二者是否相交:'</span><span class="token punctuation">)</span>
    p_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    p_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>
    p_3 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_3'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
    p_4 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_4'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">400</span><span class="token punctuation">)</span>
    seg_1 <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">)</span>
    seg_2 <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_3<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_4<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">222</span><span class="token punctuation">)</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_1 <span class="token operator">=</span> cg<span class="token punctuation">.</span>segments_intersect<span class="token punctuation">(</span>seg_1<span class="token punctuation">,</span> seg_2<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: True</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_1<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token keyword">and</span> res_1<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! 两线段相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! 两线段不相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 给定线段集合，确定其中是否存在相交线段</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n给定两条线段，判断二者是否相交:'</span><span class="token punctuation">)</span>
    <span class="token comment"># 仿照《CLRS》Chapter 33 的图 33-5</span>
    p_a_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'a_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    p_a_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'a_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">)</span>
    p_b_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'b_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>
    p_b_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'b_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">201</span><span class="token punctuation">)</span>
    p_c_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'c_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
    p_c_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'c_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">301</span><span class="token punctuation">)</span>
    p_d_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'d_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">400</span><span class="token punctuation">)</span>
    p_d_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'d_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">401</span><span class="token punctuation">)</span>
    p_e_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'e_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">)</span>
    p_e_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'e_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">501</span><span class="token punctuation">)</span>
    p_f_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'f_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">600</span><span class="token punctuation">)</span>
    p_f_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'f_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">601</span><span class="token punctuation">)</span>
    seg_a <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_a_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_a_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_a'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">111</span><span class="token punctuation">)</span>
    seg_b <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_b_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_b_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_b'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">222</span><span class="token punctuation">)</span>
    seg_c <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_c_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_c_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_c'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">333</span><span class="token punctuation">)</span>
    seg_d <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_d_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_d_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_d'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">444</span><span class="token punctuation">)</span>
    seg_e <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_e_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_e_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_e'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">555</span><span class="token punctuation">)</span>
    seg_f <span class="token operator">=</span> Segment<span class="token punctuation">(</span>from_point<span class="token operator">=</span>p_f_1<span class="token punctuation">,</span> to_point<span class="token operator">=</span>p_f_2<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'seg_f'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">666</span><span class="token punctuation">)</span>
    seg_list <span class="token operator">=</span> <span class="token punctuation">[</span>seg_a<span class="token punctuation">,</span> seg_b<span class="token punctuation">,</span> seg_c<span class="token punctuation">,</span> seg_d<span class="token punctuation">,</span> seg_e<span class="token punctuation">,</span> seg_f<span class="token punctuation">]</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_2 <span class="token operator">=</span> cg<span class="token punctuation">.</span>any_segments_intersect<span class="token punctuation">(</span>seg_list<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: True</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_2<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token keyword">and</span> res_2<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! 线段集合中存在两线段相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! 线段集合中不存在两线段相交'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># Graham 扫描法 - 给定点集，寻找该点集的凸包 convex hull</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\nGraham 扫描法 - 给定点集，寻找该点集的凸包:'</span><span class="token punctuation">)</span>
    <span class="token comment"># 仿照《CLRS》Chapter 33 的图 33-7</span>
    p_0 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_0'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># p_0 起始扫描点</span>
    p_1 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_1'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>
    p_2 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_2'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span>
    p_3 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_3'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
    p_4 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_4'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">400</span><span class="token punctuation">)</span>
    p_5 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_5'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">)</span>
    p_6 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_6'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">600</span><span class="token punctuation">)</span>
    p_7 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_7'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">700</span><span class="token punctuation">)</span>
    p_8 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_8'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">800</span><span class="token punctuation">)</span>
    p_9 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_9'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">900</span><span class="token punctuation">)</span>
    p_10 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_10'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>
    p_11 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_11'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">1100</span><span class="token punctuation">)</span>
    p_12 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_12'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">1200</span><span class="token punctuation">)</span>
    p_13 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_13'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">1300</span><span class="token punctuation">)</span>  <span class="token comment"># 相对于 p_0，与 p_11 共线，但 p_11 更远，所以不选 p_13</span>
    <span class="token comment"># point_list = [p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_10, p_11, p_12, p_13]</span>
    <span class="token comment"># 刻意打乱顺序</span>
    point_list <span class="token operator">=</span> <span class="token punctuation">[</span>p_8<span class="token punctuation">,</span> p_3<span class="token punctuation">,</span> p_12<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_5<span class="token punctuation">,</span> p_10<span class="token punctuation">,</span> p_13<span class="token punctuation">,</span> p_11<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_6<span class="token punctuation">,</span> p_9<span class="token punctuation">,</span> p_7<span class="token punctuation">]</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_3 <span class="token operator">=</span> cg<span class="token punctuation">.</span>convex_hull_graham_scan<span class="token punctuation">(</span>point_list<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: [p_0, p_1, p_3, p_10, p_12]</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_3<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! Graham 扫描法 找到了点集的凸包'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> res_3<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! Graham 扫描法 找不到点集的凸包'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># Jarvis 步进法 - 给定点集，寻找该点集的凸包 convex hull</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\nJarvis 步进法 - 给定点集，寻找该点集的凸包:'</span><span class="token punctuation">)</span>
    <span class="token comment"># point_list = [p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_10, p_11, p_12, p_13]</span>
    <span class="token comment"># 刻意打乱顺序</span>
    point_list <span class="token operator">=</span> <span class="token punctuation">[</span>p_8<span class="token punctuation">,</span> p_3<span class="token punctuation">,</span> p_12<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_5<span class="token punctuation">,</span> p_10<span class="token punctuation">,</span> p_13<span class="token punctuation">,</span> p_11<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_6<span class="token punctuation">,</span> p_9<span class="token punctuation">,</span> p_7<span class="token punctuation">]</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_4 <span class="token operator">=</span> cg<span class="token punctuation">.</span>convex_hull_jarvis_march<span class="token punctuation">(</span>point_list<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: [p_0, p_1, p_3, p_10, p_12]</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_4<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! Jarvis 步进法 找到了点集的凸包'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> res_4<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! Jarvis 步进法 找不到点集的凸包'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 旋转卡壳 (Rotating Calipers) 算法 - 给定凸多边形，求其最远点对</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n旋转卡壳 (Rotating Calipers) 算法 - 给定凸多边形，求其最远点对:'</span><span class="token punctuation">)</span>
    vertex_list <span class="token operator">=</span> res_4

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_5 <span class="token operator">=</span> cg<span class="token punctuation">.</span>rotating_calipers<span class="token punctuation">(</span>vertex_list<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: (p_3, p_12)</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_5<span class="token punctuation">,</span> <span class="token builtin">tuple</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! 旋转卡壳算法 找到了最远点对'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> point <span class="token keyword">in</span> res_5<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'两点的距离平方为:'</span><span class="token punctuation">,</span> cg<span class="token punctuation">.</span>point_distance_square_2d<span class="token punctuation">(</span>res_5<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> res_5<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! 旋转卡壳算法 找不到最远点对'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 给定点集，求出该点集的最近点对</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n给定点集，求出该点集的最近点对:'</span><span class="token punctuation">)</span>
    p_14 <span class="token operator">=</span> Point<span class="token punctuation">(</span>vec<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">8.5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">'p_14'</span><span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">1400</span><span class="token punctuation">)</span>  <span class="token comment"># 该点与 p_4 的距离为 0.5 最近</span>
    point_list <span class="token operator">=</span> <span class="token punctuation">[</span>p_8<span class="token punctuation">,</span> p_3<span class="token punctuation">,</span> p_12<span class="token punctuation">,</span> p_0<span class="token punctuation">,</span> p_4<span class="token punctuation">,</span> p_2<span class="token punctuation">,</span> p_5<span class="token punctuation">,</span> p_10<span class="token punctuation">,</span> p_13<span class="token punctuation">,</span> p_11<span class="token punctuation">,</span> p_1<span class="token punctuation">,</span> p_6<span class="token punctuation">,</span> p_9<span class="token punctuation">,</span> p_7<span class="token punctuation">,</span> p_14<span class="token punctuation">]</span>

    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    res_p_1<span class="token punctuation">,</span> res_p_2<span class="token punctuation">,</span> res_dis <span class="token operator">=</span> cg<span class="token punctuation">.</span>nearest_point_pair<span class="token punctuation">(</span>point_list<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果: p_4, p_14, 0.25</span>
    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_p_1<span class="token punctuation">,</span> Point<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>res_p_2<span class="token punctuation">,</span> Point<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yes! 找到了最近点对'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>res_p_1<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>res_p_2<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'最短距离的平方:'</span><span class="token punctuation">,</span> res_dis<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'No! 找不到最近点对'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>Introduction to Algorithm (aka CLRS) Third Edition - Chapter 33</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.338776d8.js" defer></script><script src="/assets/js/2.5e710586.js" defer></script><script src="/assets/js/72.ae211912.js" defer></script>
  </body>
</html>
