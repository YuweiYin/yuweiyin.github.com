<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Graph Theory - Ford-Fulkerson | YuweiYin</title>
    <meta name="description" content="Homepage of YuweiYin">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/YuweiYin.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.2d4b740c.css" as="style"><link rel="preload" href="/assets/js/app.4a794670.js" as="script"><link rel="preload" href="/assets/js/2.db22a8ef.js" as="script"><link rel="preload" href="/assets/js/43.2f6323ad.js" as="script"><link rel="prefetch" href="/assets/js/10.e9327950.js"><link rel="prefetch" href="/assets/js/100.6d17196f.js"><link rel="prefetch" href="/assets/js/101.a0908757.js"><link rel="prefetch" href="/assets/js/102.06b00d64.js"><link rel="prefetch" href="/assets/js/103.6c3a84ed.js"><link rel="prefetch" href="/assets/js/104.6e3530c8.js"><link rel="prefetch" href="/assets/js/105.cf5cbe05.js"><link rel="prefetch" href="/assets/js/106.96de8820.js"><link rel="prefetch" href="/assets/js/107.90e1d0e6.js"><link rel="prefetch" href="/assets/js/108.fa797411.js"><link rel="prefetch" href="/assets/js/109.18fcc047.js"><link rel="prefetch" href="/assets/js/11.3078c44e.js"><link rel="prefetch" href="/assets/js/110.c5c22fef.js"><link rel="prefetch" href="/assets/js/111.1e0327ec.js"><link rel="prefetch" href="/assets/js/112.f708ac92.js"><link rel="prefetch" href="/assets/js/113.1ecf55e7.js"><link rel="prefetch" href="/assets/js/114.338928ea.js"><link rel="prefetch" href="/assets/js/115.3b5ecfd5.js"><link rel="prefetch" href="/assets/js/116.613dde1e.js"><link rel="prefetch" href="/assets/js/117.38b14a0a.js"><link rel="prefetch" href="/assets/js/118.83899453.js"><link rel="prefetch" href="/assets/js/119.c2388b43.js"><link rel="prefetch" href="/assets/js/12.be4e5c80.js"><link rel="prefetch" href="/assets/js/120.90198b8c.js"><link rel="prefetch" href="/assets/js/121.94edb091.js"><link rel="prefetch" href="/assets/js/122.a12bbbca.js"><link rel="prefetch" href="/assets/js/123.46e8fb30.js"><link rel="prefetch" href="/assets/js/124.1bbf4e6c.js"><link rel="prefetch" href="/assets/js/125.1f6385a4.js"><link rel="prefetch" href="/assets/js/126.6bb48234.js"><link rel="prefetch" href="/assets/js/127.665d097d.js"><link rel="prefetch" href="/assets/js/128.2c7457e0.js"><link rel="prefetch" href="/assets/js/129.abdc50aa.js"><link rel="prefetch" href="/assets/js/13.47640fd0.js"><link rel="prefetch" href="/assets/js/130.e0840104.js"><link rel="prefetch" href="/assets/js/131.2da91308.js"><link rel="prefetch" href="/assets/js/132.8b08746a.js"><link rel="prefetch" href="/assets/js/133.55cc4204.js"><link rel="prefetch" href="/assets/js/134.a8e92592.js"><link rel="prefetch" href="/assets/js/135.4c9568ba.js"><link rel="prefetch" href="/assets/js/136.081bccb5.js"><link rel="prefetch" href="/assets/js/137.afb142be.js"><link rel="prefetch" href="/assets/js/138.b16fb237.js"><link rel="prefetch" href="/assets/js/139.b114d954.js"><link rel="prefetch" href="/assets/js/14.d3de3c5d.js"><link rel="prefetch" href="/assets/js/140.e94f9de2.js"><link rel="prefetch" href="/assets/js/141.54f8d40d.js"><link rel="prefetch" href="/assets/js/142.3f35bbca.js"><link rel="prefetch" href="/assets/js/143.5546a8ba.js"><link rel="prefetch" href="/assets/js/144.3034affd.js"><link rel="prefetch" href="/assets/js/145.92a1ca47.js"><link rel="prefetch" href="/assets/js/146.a623692d.js"><link rel="prefetch" href="/assets/js/147.8b8a4e61.js"><link rel="prefetch" href="/assets/js/148.a8d75c1a.js"><link rel="prefetch" href="/assets/js/149.3cb26b0f.js"><link rel="prefetch" href="/assets/js/15.4a57c22e.js"><link rel="prefetch" href="/assets/js/150.482efc87.js"><link rel="prefetch" href="/assets/js/151.a97efe8a.js"><link rel="prefetch" href="/assets/js/152.03afb7d4.js"><link rel="prefetch" href="/assets/js/153.be279e5b.js"><link rel="prefetch" href="/assets/js/154.c802f4cb.js"><link rel="prefetch" href="/assets/js/155.75bbe81f.js"><link rel="prefetch" href="/assets/js/156.9162a5fb.js"><link rel="prefetch" href="/assets/js/157.04cf6c84.js"><link rel="prefetch" href="/assets/js/158.c687ce54.js"><link rel="prefetch" href="/assets/js/159.c3e7ee4d.js"><link rel="prefetch" href="/assets/js/16.c6b7df6e.js"><link rel="prefetch" href="/assets/js/160.3a51bb2f.js"><link rel="prefetch" href="/assets/js/161.98b12c7c.js"><link rel="prefetch" href="/assets/js/162.3f67f52d.js"><link rel="prefetch" href="/assets/js/163.a6ba96cb.js"><link rel="prefetch" href="/assets/js/164.d49b39cf.js"><link rel="prefetch" href="/assets/js/165.4977f608.js"><link rel="prefetch" href="/assets/js/166.c2779af8.js"><link rel="prefetch" href="/assets/js/167.ea056642.js"><link rel="prefetch" href="/assets/js/168.1b6a151b.js"><link rel="prefetch" href="/assets/js/169.66ebe257.js"><link rel="prefetch" href="/assets/js/17.efcd456f.js"><link rel="prefetch" href="/assets/js/170.0ab24043.js"><link rel="prefetch" href="/assets/js/171.710721ad.js"><link rel="prefetch" href="/assets/js/172.5c79fe64.js"><link rel="prefetch" href="/assets/js/173.5b02164b.js"><link rel="prefetch" href="/assets/js/174.0d937382.js"><link rel="prefetch" href="/assets/js/175.80fad985.js"><link rel="prefetch" href="/assets/js/176.9c70dfa5.js"><link rel="prefetch" href="/assets/js/177.b1e84a53.js"><link rel="prefetch" href="/assets/js/178.6a044e5d.js"><link rel="prefetch" href="/assets/js/179.d84b2f88.js"><link rel="prefetch" href="/assets/js/18.0fecdee3.js"><link rel="prefetch" href="/assets/js/180.5a1be705.js"><link rel="prefetch" href="/assets/js/181.acf02d31.js"><link rel="prefetch" href="/assets/js/182.5d01dae3.js"><link rel="prefetch" href="/assets/js/183.0ba52850.js"><link rel="prefetch" href="/assets/js/184.dc80471b.js"><link rel="prefetch" href="/assets/js/185.2a64ff2a.js"><link rel="prefetch" href="/assets/js/186.61208878.js"><link rel="prefetch" href="/assets/js/187.e961d6e2.js"><link rel="prefetch" href="/assets/js/188.41eb51e9.js"><link rel="prefetch" href="/assets/js/189.59474daa.js"><link rel="prefetch" href="/assets/js/19.a51114c2.js"><link rel="prefetch" href="/assets/js/190.99e5cb4a.js"><link rel="prefetch" href="/assets/js/191.647369d7.js"><link rel="prefetch" href="/assets/js/192.2d3c740b.js"><link rel="prefetch" href="/assets/js/193.93c89f9e.js"><link rel="prefetch" href="/assets/js/194.80318647.js"><link rel="prefetch" href="/assets/js/195.a7704b9e.js"><link rel="prefetch" href="/assets/js/196.6f0a48b2.js"><link rel="prefetch" href="/assets/js/197.e472fefa.js"><link rel="prefetch" href="/assets/js/198.de2c70de.js"><link rel="prefetch" href="/assets/js/199.8c9ede19.js"><link rel="prefetch" href="/assets/js/20.31e5b545.js"><link rel="prefetch" href="/assets/js/200.4e31add6.js"><link rel="prefetch" href="/assets/js/201.f7f94f2e.js"><link rel="prefetch" href="/assets/js/202.5f8ee41a.js"><link rel="prefetch" href="/assets/js/203.22bf5449.js"><link rel="prefetch" href="/assets/js/204.9d82824c.js"><link rel="prefetch" href="/assets/js/205.ef22ead1.js"><link rel="prefetch" href="/assets/js/206.e23ad767.js"><link rel="prefetch" href="/assets/js/207.968544a9.js"><link rel="prefetch" href="/assets/js/208.072b4f71.js"><link rel="prefetch" href="/assets/js/209.e49e9bbd.js"><link rel="prefetch" href="/assets/js/21.e5a244ec.js"><link rel="prefetch" href="/assets/js/210.aea4aaf3.js"><link rel="prefetch" href="/assets/js/211.a9579916.js"><link rel="prefetch" href="/assets/js/212.b25fb707.js"><link rel="prefetch" href="/assets/js/213.dc0e6296.js"><link rel="prefetch" href="/assets/js/214.1dfb4054.js"><link rel="prefetch" href="/assets/js/215.d8cb42d1.js"><link rel="prefetch" href="/assets/js/216.b9774826.js"><link rel="prefetch" href="/assets/js/217.944196ec.js"><link rel="prefetch" href="/assets/js/218.a87c23ed.js"><link rel="prefetch" href="/assets/js/219.7e370f04.js"><link rel="prefetch" href="/assets/js/22.596e8043.js"><link rel="prefetch" href="/assets/js/220.b17fa524.js"><link rel="prefetch" href="/assets/js/221.d2cc7043.js"><link rel="prefetch" href="/assets/js/222.3a1115d1.js"><link rel="prefetch" href="/assets/js/223.a8a77af5.js"><link rel="prefetch" href="/assets/js/224.db19b1c8.js"><link rel="prefetch" href="/assets/js/225.164f4cdc.js"><link rel="prefetch" href="/assets/js/226.904c58e2.js"><link rel="prefetch" href="/assets/js/227.de84e69c.js"><link rel="prefetch" href="/assets/js/228.eb308ad1.js"><link rel="prefetch" href="/assets/js/229.03251b19.js"><link rel="prefetch" href="/assets/js/23.499343b5.js"><link rel="prefetch" href="/assets/js/230.7b35accd.js"><link rel="prefetch" href="/assets/js/231.f27f9821.js"><link rel="prefetch" href="/assets/js/232.149f4c2b.js"><link rel="prefetch" href="/assets/js/233.586f85cf.js"><link rel="prefetch" href="/assets/js/234.99a1abd1.js"><link rel="prefetch" href="/assets/js/235.315d8537.js"><link rel="prefetch" href="/assets/js/236.35dcac9f.js"><link rel="prefetch" href="/assets/js/237.37e670b0.js"><link rel="prefetch" href="/assets/js/238.676c89eb.js"><link rel="prefetch" href="/assets/js/239.bfda4a3c.js"><link rel="prefetch" href="/assets/js/24.e1048786.js"><link rel="prefetch" href="/assets/js/240.73137988.js"><link rel="prefetch" href="/assets/js/241.9ab933ca.js"><link rel="prefetch" href="/assets/js/242.f766d26a.js"><link rel="prefetch" href="/assets/js/243.2f565517.js"><link rel="prefetch" href="/assets/js/244.98be65a4.js"><link rel="prefetch" href="/assets/js/245.318bd9cc.js"><link rel="prefetch" href="/assets/js/246.d9731032.js"><link rel="prefetch" href="/assets/js/247.fde0f974.js"><link rel="prefetch" href="/assets/js/248.81be9d81.js"><link rel="prefetch" href="/assets/js/249.02ba7231.js"><link rel="prefetch" href="/assets/js/25.2076b6f2.js"><link rel="prefetch" href="/assets/js/250.0f0987dd.js"><link rel="prefetch" href="/assets/js/251.d9c85bc3.js"><link rel="prefetch" href="/assets/js/252.4ab8bb3b.js"><link rel="prefetch" href="/assets/js/253.acdea6db.js"><link rel="prefetch" href="/assets/js/254.69a105ad.js"><link rel="prefetch" href="/assets/js/255.741ad129.js"><link rel="prefetch" href="/assets/js/256.e2d1fdfd.js"><link rel="prefetch" href="/assets/js/257.8bbb30c7.js"><link rel="prefetch" href="/assets/js/258.0ff5a70f.js"><link rel="prefetch" href="/assets/js/259.1e7b0b58.js"><link rel="prefetch" href="/assets/js/26.a2e0a391.js"><link rel="prefetch" href="/assets/js/260.76d79fdd.js"><link rel="prefetch" href="/assets/js/261.e6ae9aca.js"><link rel="prefetch" href="/assets/js/262.a5b2150c.js"><link rel="prefetch" href="/assets/js/263.7ec0c66d.js"><link rel="prefetch" href="/assets/js/264.38069883.js"><link rel="prefetch" href="/assets/js/265.9991976d.js"><link rel="prefetch" href="/assets/js/266.3f9e1412.js"><link rel="prefetch" href="/assets/js/267.7d33f2d0.js"><link rel="prefetch" href="/assets/js/268.923569dc.js"><link rel="prefetch" href="/assets/js/269.8fd7a468.js"><link rel="prefetch" href="/assets/js/27.f493e686.js"><link rel="prefetch" href="/assets/js/270.4ceb4bd7.js"><link rel="prefetch" href="/assets/js/271.ac2908c4.js"><link rel="prefetch" href="/assets/js/272.7afa2d72.js"><link rel="prefetch" href="/assets/js/273.6b4dde57.js"><link rel="prefetch" href="/assets/js/274.256a9df9.js"><link rel="prefetch" href="/assets/js/275.f38805a9.js"><link rel="prefetch" href="/assets/js/276.3c52de9c.js"><link rel="prefetch" href="/assets/js/277.844b549f.js"><link rel="prefetch" href="/assets/js/278.1d8e8972.js"><link rel="prefetch" href="/assets/js/279.b8185f86.js"><link rel="prefetch" href="/assets/js/28.d34f2e66.js"><link rel="prefetch" href="/assets/js/280.a3a72cbe.js"><link rel="prefetch" href="/assets/js/281.48b14d02.js"><link rel="prefetch" href="/assets/js/282.f111cd7d.js"><link rel="prefetch" href="/assets/js/283.621a3a4b.js"><link rel="prefetch" href="/assets/js/284.5012180e.js"><link rel="prefetch" href="/assets/js/285.e0a91eb5.js"><link rel="prefetch" href="/assets/js/286.f7c514c5.js"><link rel="prefetch" href="/assets/js/287.335b5e04.js"><link rel="prefetch" href="/assets/js/288.251368e2.js"><link rel="prefetch" href="/assets/js/289.9a2e140b.js"><link rel="prefetch" href="/assets/js/29.4ad54677.js"><link rel="prefetch" href="/assets/js/290.2ea298d3.js"><link rel="prefetch" href="/assets/js/291.e1a1fe37.js"><link rel="prefetch" href="/assets/js/292.d824342f.js"><link rel="prefetch" href="/assets/js/293.0c6a13e9.js"><link rel="prefetch" href="/assets/js/294.6e8d4394.js"><link rel="prefetch" href="/assets/js/295.eb42c611.js"><link rel="prefetch" href="/assets/js/296.53483116.js"><link rel="prefetch" href="/assets/js/297.7786ee81.js"><link rel="prefetch" href="/assets/js/298.c52f92c1.js"><link rel="prefetch" href="/assets/js/299.2ecb152c.js"><link rel="prefetch" href="/assets/js/3.e6869fad.js"><link rel="prefetch" href="/assets/js/30.5bddd19c.js"><link rel="prefetch" href="/assets/js/300.bb106333.js"><link rel="prefetch" href="/assets/js/301.c26bf505.js"><link rel="prefetch" href="/assets/js/302.862be1d2.js"><link rel="prefetch" href="/assets/js/303.2b0f7ca9.js"><link rel="prefetch" href="/assets/js/304.b4b114da.js"><link rel="prefetch" href="/assets/js/305.29f15ebd.js"><link rel="prefetch" href="/assets/js/306.f9980455.js"><link rel="prefetch" href="/assets/js/307.8ad3015b.js"><link rel="prefetch" href="/assets/js/308.24486e5a.js"><link rel="prefetch" href="/assets/js/309.db5516f6.js"><link rel="prefetch" href="/assets/js/31.54473c58.js"><link rel="prefetch" href="/assets/js/310.cf9733a1.js"><link rel="prefetch" href="/assets/js/311.ea463a6e.js"><link rel="prefetch" href="/assets/js/312.47cf7201.js"><link rel="prefetch" href="/assets/js/313.a8ebafd2.js"><link rel="prefetch" href="/assets/js/314.8ae76260.js"><link rel="prefetch" href="/assets/js/315.cc9799c5.js"><link rel="prefetch" href="/assets/js/316.5983ae65.js"><link rel="prefetch" href="/assets/js/317.b8d78698.js"><link rel="prefetch" href="/assets/js/318.78ee2136.js"><link rel="prefetch" href="/assets/js/319.a933d261.js"><link rel="prefetch" href="/assets/js/32.df875ea1.js"><link rel="prefetch" href="/assets/js/320.3d001e73.js"><link rel="prefetch" href="/assets/js/321.e114b25b.js"><link rel="prefetch" href="/assets/js/322.fff927f5.js"><link rel="prefetch" href="/assets/js/323.f3801bd7.js"><link rel="prefetch" href="/assets/js/324.ef62761e.js"><link rel="prefetch" href="/assets/js/325.d8faa362.js"><link rel="prefetch" href="/assets/js/326.5715ee54.js"><link rel="prefetch" href="/assets/js/327.83681cdd.js"><link rel="prefetch" href="/assets/js/328.39b6ef57.js"><link rel="prefetch" href="/assets/js/329.36a09c09.js"><link rel="prefetch" href="/assets/js/33.2f12eb11.js"><link rel="prefetch" href="/assets/js/330.5b119920.js"><link rel="prefetch" href="/assets/js/331.05d9cd77.js"><link rel="prefetch" href="/assets/js/332.0676a2ea.js"><link rel="prefetch" href="/assets/js/34.bf10e6cf.js"><link rel="prefetch" href="/assets/js/35.4abc41f7.js"><link rel="prefetch" href="/assets/js/36.ce3702f1.js"><link rel="prefetch" href="/assets/js/37.8b7dc39a.js"><link rel="prefetch" href="/assets/js/38.59785b60.js"><link rel="prefetch" href="/assets/js/39.329fad68.js"><link rel="prefetch" href="/assets/js/4.afea0107.js"><link rel="prefetch" href="/assets/js/40.537d7d44.js"><link rel="prefetch" href="/assets/js/41.a9444389.js"><link rel="prefetch" href="/assets/js/42.e9167829.js"><link rel="prefetch" href="/assets/js/44.5a62536e.js"><link rel="prefetch" href="/assets/js/45.7db040b5.js"><link rel="prefetch" href="/assets/js/46.969c8e26.js"><link rel="prefetch" href="/assets/js/47.ad02ecc5.js"><link rel="prefetch" href="/assets/js/48.541fabd6.js"><link rel="prefetch" href="/assets/js/49.6b131533.js"><link rel="prefetch" href="/assets/js/5.332429b6.js"><link rel="prefetch" href="/assets/js/50.98a96014.js"><link rel="prefetch" href="/assets/js/51.21a65c39.js"><link rel="prefetch" href="/assets/js/52.d709ddc5.js"><link rel="prefetch" href="/assets/js/53.ad029fc8.js"><link rel="prefetch" href="/assets/js/54.a4c7e884.js"><link rel="prefetch" href="/assets/js/55.4a3be153.js"><link rel="prefetch" href="/assets/js/56.ed074303.js"><link rel="prefetch" href="/assets/js/57.acd416d0.js"><link rel="prefetch" href="/assets/js/58.7de9dcfd.js"><link rel="prefetch" href="/assets/js/59.b868d3f7.js"><link rel="prefetch" href="/assets/js/6.ccffe03f.js"><link rel="prefetch" href="/assets/js/60.b2d275a2.js"><link rel="prefetch" href="/assets/js/61.d1dd1566.js"><link rel="prefetch" href="/assets/js/62.bf534a36.js"><link rel="prefetch" href="/assets/js/63.804907b4.js"><link rel="prefetch" href="/assets/js/64.d4b5fc15.js"><link rel="prefetch" href="/assets/js/65.23948477.js"><link rel="prefetch" href="/assets/js/66.465875e4.js"><link rel="prefetch" href="/assets/js/67.cf0a292b.js"><link rel="prefetch" href="/assets/js/68.a23fc0ea.js"><link rel="prefetch" href="/assets/js/69.e0430d9d.js"><link rel="prefetch" href="/assets/js/7.6c75590d.js"><link rel="prefetch" href="/assets/js/70.06c2f7ec.js"><link rel="prefetch" href="/assets/js/71.c96ebfad.js"><link rel="prefetch" href="/assets/js/72.07fde13e.js"><link rel="prefetch" href="/assets/js/73.44d9ff3d.js"><link rel="prefetch" href="/assets/js/74.220478f6.js"><link rel="prefetch" href="/assets/js/75.f0d29742.js"><link rel="prefetch" href="/assets/js/76.86045c1a.js"><link rel="prefetch" href="/assets/js/77.8ad87172.js"><link rel="prefetch" href="/assets/js/78.f903e028.js"><link rel="prefetch" href="/assets/js/79.8cf8005b.js"><link rel="prefetch" href="/assets/js/8.db773bce.js"><link rel="prefetch" href="/assets/js/80.1f9d5142.js"><link rel="prefetch" href="/assets/js/81.dbd5713f.js"><link rel="prefetch" href="/assets/js/82.e9ece621.js"><link rel="prefetch" href="/assets/js/83.fc651158.js"><link rel="prefetch" href="/assets/js/84.bd34b670.js"><link rel="prefetch" href="/assets/js/85.7edb4476.js"><link rel="prefetch" href="/assets/js/86.045f2c40.js"><link rel="prefetch" href="/assets/js/87.3e74add9.js"><link rel="prefetch" href="/assets/js/88.e25ba7c5.js"><link rel="prefetch" href="/assets/js/89.9666139f.js"><link rel="prefetch" href="/assets/js/9.ec97bbf9.js"><link rel="prefetch" href="/assets/js/90.0fb92dde.js"><link rel="prefetch" href="/assets/js/91.3a7fff9f.js"><link rel="prefetch" href="/assets/js/92.39d3b64e.js"><link rel="prefetch" href="/assets/js/93.f2df86e1.js"><link rel="prefetch" href="/assets/js/94.8a94f8c0.js"><link rel="prefetch" href="/assets/js/95.d4e2d159.js"><link rel="prefetch" href="/assets/js/96.4def6c78.js"><link rel="prefetch" href="/assets/js/97.6ea66591.js"><link rel="prefetch" href="/assets/js/98.74a189bc.js"><link rel="prefetch" href="/assets/js/99.47806e98.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2d4b740c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YuweiYin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></li><li class="dropdown-item"><!----> <a href="/article/physics/" class="nav-link">
  物理宇宙
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/" class="nav-link router-link-active">
  信息技术
</a></li><li class="dropdown-item"><!----> <a href="/article/essay/" class="nav-link">
  见闻随笔
</a></li><li class="dropdown-item"><!----> <a href="/article/other/" class="nav-link">
  其它系列
</a></li><li class="dropdown-item"><!----> <a href="/article/reprint/" class="nav-link">
  转载文章
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></li><li class="dropdown-item"><!----> <a href="/article/physics/" class="nav-link">
  物理宇宙
</a></li><li class="dropdown-item"><!----> <a href="/article/info-technology/" class="nav-link router-link-active">
  信息技术
</a></li><li class="dropdown-item"><!----> <a href="/article/essay/" class="nav-link">
  见闻随笔
</a></li><li class="dropdown-item"><!----> <a href="/article/other/" class="nav-link">
  其它系列
</a></li><li class="dropdown-item"><!----> <a href="/article/reprint/" class="nav-link">
  转载文章
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/article/info-technology/" class="sidebar-link">Information Technology</a></li><li><a href="/article/info-technology/computer-science/" class="sidebar-link">Computer Science</a></li><li><a href="/article/info-technology/algorithm/" class="sidebar-link">Algorithm</a></li><li><a href="/article/info-technology/artificial-intelligence/" class="sidebar-link">Artificial Intelligence</a></li><li><a href="/article/info-technology/web-crawler/" class="sidebar-link">Web Crawler</a></li><li><a href="/article/info-technology/web-frontend/" class="sidebar-link">Web Frontend</a></li><li><a href="/article/info-technology/web-backend/" class="sidebar-link">Web Backend</a></li><li><a href="/article/info-technology/web-security/" class="sidebar-link">Web Security</a></li><li><a href="/article/info-technology/system-management/" class="sidebar-link">System Management</a></li><li><a href="/article/info-technology/paper-notes/" class="sidebar-link">Paper Notes</a></li><li><a href="/article/info-technology/other/" class="sidebar-link">Other</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="algorithm-graph-theory-ford-fulkerson"><a href="#algorithm-graph-theory-ford-fulkerson" class="header-anchor">#</a> Algorithm - Graph Theory - Ford-Fulkerson</h1> <p>Create Date: 2020.06.03</p> <p>Last Update Date: 2020.06.03</p> <p>By <a href="https://yuweiyin.github.io/" target="_blank" rel="noopener noreferrer">YuweiYin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>最大流 Max-Flow</p> <p>Ford-Fulkerson 方法</p> <h3 id="流网络"><a href="#流网络" class="header-anchor">#</a> 流网络</h3> <p>流网络 G = (V, E) 是一个有向图，图中每条边 (u, v) \in E 有一个<strong>非负</strong>的<strong>容量值</strong> c(u, v) &gt;= 0。而且，如果边集合 E 包含一条边 (u, v)，则图中不存在反方向的边 (v, u)。如果 (u, v) \notin E，为方便起见，定义 c(u, v) = 0。并且在图中不允许有自循环/自圈 (u, u)。</p> <p>另外，在流网络的所有结点中，有两个特殊的结点：<strong>源结点</strong> s (source) 和<strong>汇点</strong> t (terminal)。源结点入度为 0、汇点出度为 0。为方便起见，假定 V 中每个结点 v 都位于某条从 s 到 v 的路径上，即有 <code>s ~&gt; v ~&gt; t</code> 路径。</p> <p>因此，流网络图是<strong>弱连通</strong>的。并且由于除源结点 s 外的每个结点都至少有一条进入的边，有 <code>|E| &gt;= |V| - 1</code>。</p> <ul><li>流网络的性质主要如下：
<ul><li>流网络 G = (V, E) 是一个弱连通的有向图</li> <li>所有边的权重为非负值，且每条边的权重值有上界 c(u, v)</li> <li>任意两个结点 u, v \in V，不能同时存在边 (u, v) 和边 (v, u)</li> <li>如果某边 (u, v) 不存在，定义其权重值 c(u, v) = 0</li> <li>图中没有自循环 (u, u)</li> <li>通常来说，源结点 s 的入度为 0，汇点 t 的出度为 0</li> <li>每个结点 v 都处于从 s 到 t 的某条路径上。即：从起点 s 发出的流量可以流经 v 到达终点 t</li></ul></li></ul> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/max-flow-1.png" alt="max-flow-1"></p> <p>这里给出流的形式化定义。设 G = (V, E) 是一个<strong>流网络</strong>，其<strong>容量函数</strong>为 c。设 s 为网络的<strong>源结点</strong>，t 为<strong>汇点</strong>。G 中的<strong>流</strong>是一个<strong>实值函数</strong> f: VxV -&gt; R，满足如下两条性质：</p> <ol><li><strong>容量限制</strong>：（“流量有限额”）对于所有的结点 u, v \in V，要求 0 &lt;= f(u, v) &lt;= c(u, v)</li> <li><strong>流量守恒</strong>：（“流入等于流出”）对于所有的结点 u \in V - {s, t}，要求 $ \sum_{v \in V} f(v, u) = \sum_{v \in V} f(u, v) $
<ul><li>当 (u, v) \notin E 时，从结点 u 到结点 v 之间没有流，因此 f(u, v) == 0</li></ul></li></ol> <p>称非负数值 f(u, v) 为从结点 u 到结点 v 的流。一个流 f 的值 <code>|f|</code> 定义如下：</p> <p>$$ |f| = \sum_{v \in V} f(s, v) = \sum_{v \in V} f(v, s) $$</p> <p>即，流 f 的值时从源结点流出的总流量 减去 流入源结点的总流量。这里符号 <code>|·|</code> 仅用作表达流的值，而不是数的绝对值或者集合的基数值。</p> <p>通常来说，一个流网络不会有任何进入源结点的边，即源结点的入度为 0，故求和项 $ \sum_{v \in V} f(v, s) $ 的值将是 0。但对于有的网络而言（比如<strong>残存网络</strong>），流入源结点的流量十分重要。</p> <p>在<strong>最大流问题</strong>中，给定一个<strong>流网络</strong> G、一个<strong>源结点</strong> s、一个<strong>汇点</strong> t，目标是找到值最大的一个<strong>流</strong>。</p> <h2 id="ford-fulkerson-方法"><a href="#ford-fulkerson-方法" class="header-anchor">#</a> Ford-Fulkerson 方法</h2> <p>常用于解决最大流问题的 Ford-Fulkerson 方法，之所以被称为“方法”而不是“算法”，是因为它主要提供的是一种通用的解决思路，包含了几种运行时间不同的具体算法实现。</p> <p>Ford-Fulkerson 方法依赖于三种重要思想：<strong>残存网络</strong>、<strong>增广路径</strong> 和 <strong>切割</strong>。这三种思想与许多流算法和问题有关，它们是<strong>最大流最小切割定理</strong>（《CLRS》定理 26.6）的精髓。该定理以<strong>流网络的切割</strong>来表述最大流的值。</p> <p>Ford-Fulkerson 方法<strong>循环增加流的值</strong>：</p> <ul><li>在开始的时候，对于所有的结点 u, v \in V，f(u, v) = 0，给出的初始流量为 0。</li> <li>每一次迭代中，将图 G 的流值进行增加，增加的方法就是在一个关联的“残存网络” Gf 中寻找一条“增广路径”
<ul><li>一旦知道图 Gf 中的一条增广路径的边，就可以很容易地辨别出 G 中的一些具体的边，可以对这些边上的流量进行修改，从而增加流的值。</li></ul></li> <li>虽然 Ford-Fulkerson 方法的每次迭代都增加流（整体）的值，但是对于图 G 的一条特定边来说，其流量可能增加，也可能减少。
<ul><li>而且，对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。</li></ul></li> <li>重复对流进行这一过程，知道残存网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法将获得一个最大流。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FORD_FULKERSON_METHOD(G, s, t)
1  initialize flow f to 0
2  while there exists an augmenting path p in the residual network Gf
3      augment flow f along p
4  return f
</code></pre></div><p>为了实现和分析 Ford-Fulkerson 方法，需要引入如下几个新的概念。</p> <h3 id="残存网络"><a href="#残存网络" class="header-anchor">#</a> 残存网络</h3> <p>从直观上看，给定流网络 G 和流量 f，残存网络 Gf 由那些 <strong>仍有空间对流量进行调整的边</strong> 构成。流网络的一条边<strong>可以允许的额外流量</strong>等于 该边的容量 减去 该边上的流量。如果该差值为正，则将该条边置于残存网络图 Gf 中，并将其<strong>残存容量</strong>设置为 cf(u, v) = c(u, v) - f(u, v)。对于图 G 中的边来说，只有能够允许额外流量的边才能被加入到图 Gf 中。如果边 (u, v) 的流量 f(u, v) 等于其容量 c(u, v)，则其 cf(u, v) == 0，该条边将不属于图 Gf。（注意，根据<strong>容量限制</strong>原则，残存容量 cf(u, v) 不可能为负值）</p> <p>残存网络 Gf 中可能包含图 G 中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减，为了表示对一个正流量 f(u, v) 的缩减，将反向边 (v, u) 加入到图 Gf 中，并将其残存容量设置为 cf(v, u) = f(u, v)。即 一条边所能允许的反向流量最多将其正向流量抵消。残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。</p> <p>而将流量从同一条边发送回去等同于<strong>缩减</strong>该条边的流量，这种操作在许多算法中都是必须的。</p> <p>更形式化地说，假定有一个流网络 G = (V, E)，其源结点为 s，汇点为 t。设 f 为图 G 中的一个流，考虑结点对 u, v \in V，定义<strong>残存容量</strong> cf(u, v) 如下：</p> <ul><li>若 (u, v) \in E，则 cf(u, v) = c(u, v) - f(u, v)</li> <li>若 (v, u) \in E，则 cf(u, v) = f(v, u)</li> <li>若是其它情况，则 cf(u, v) = 0</li></ul> <p>由于已经假定在图 G 中边 (u, v) 和边 (v, u) 不能同时出现，故上述三种情况有且仅有一种会发生。</p> <p>举例来说，如果容量限制 c(u, v) = 16，并且当前流量 f(u, v) = 11，则对 f(u, v) 可以增加的量最多为 cf(u, v) = 5，再多就超过边 (u, v) 的容量限制了。同时，允许算法从结点 v 向结点 u 最多返回 11 单位的流量（即全部当前流量），因此残存网络中反向边 cf(v, u) = 11。</p> <hr> <p>给定一个流网络 G = (V, E) 和一个流 f，则由 f 所诱导的图 G 的<strong>残存网络</strong>为 Gf = (V, Ef)，其中边集 Ef = {(u, v) \in V x V: cf(u, v) &gt; 0}</p> <p>即 残存网络的每条边（称为<strong>残存边</strong>），必须允许大于 0 的流量通过。下面图 26-4 中的 (a) 图是前面图 26-1 (b) 的流网络 G 和流量 f 的重新绘制，图 26-4 (b) 描述的是对应的残存网络 Gf。Ef 中的边要么是 E 中原有的边，要么是其反向边，因此有 <code>|Ef| &lt;= 2|E|</code></p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-1.png" alt="ford-fulkerson-1"></p> <p>残存网络 Gf 类似于一个容量为 cf 的流网络，但是不满足前面对流网络的定义，因为在 Gf 中可以有反平行边。除了反平行边这个区别外，流网络的其他性质 Gf 都有保留，因此可以在残存网络中定义一个流，它满足流的两条性质：<strong>容量限制</strong> 和 <strong>流量守恒</strong>。该流针对的是残存网络 Gf 中的残存容量 cf。</p> <p>残存网络 Gf 中的一个流指出的是一条<strong>路线图</strong>：如何在原来的流网络 G 中增加流。如果 f 是 G 的一个流，f' 是对应的残存网络 Gf 中的一个流，定义 f↑f' 为流 f' 对流 f 的<strong>递增</strong> (augmentation)，它是一个从 V x V 到 R 的函数，具体定义如下：</p> <ul><li>若 (u, v) \in E，则 (f↑f')(u, v) = f(u, v) + f'(u, v) - f'(v, u)</li> <li>其它情况，则 (f↑f')(u, v) = 0</li></ul> <p>该定义背后的直观解释遵循残存网络的定义。因为在残存网络中<strong>将流量发送到反向边</strong> 等同于 在原来的网络中<strong>缩减流量</strong>，所以将边 (u, v) 的流量增加 f'(u, v)，但减少 f'(v, u)。在残存网络中将流量推送回去 也被称为<strong>抵消操作</strong> (cancellation)。</p> <p>举例来说，如果某公司将 5 箱货物从城市 u 发送到城市 v，同时将 2 箱同样的货物从城市 v 发送到城市 u，那么可以(从整体上来说)等价于 将 3 箱货物从城市 u 发送到城市 v。这类<strong>抵消操作</strong>对于任何<strong>最大流算法</strong>来说都是<strong>非常关键</strong>的。</p> <hr> <p>《CLRS》<strong>引理 26.1</strong>：设 G = (V, E) 为一个流网络，源结点为 s，汇点为 t，设 f 为 G 中的一个流。设 Gf 为由流 f 所诱导的 G 的残存网络，设 f' 为 Gf 中的一个流。那么函数 (f↑f') 是 G 的一个流，其值为 <code>|f↑f'| = |f| + |f'|</code>。</p> <p>对引理 26.1 的证明主要有以下四点（具体证明参考《CLRS》Chapter 26.2）：</p> <ol><li>流量非负：(f↑f')(u, v) &gt;= 0</li> <li>容量限制：(f↑f')(u, v) &lt;= c(u, v)</li> <li>流量守恒：对于所有的结点 u \in V - {s, t}，$ \sum_{v \in V} (f↑f')(u, v) = \sum_{v \in V} (f↑f')(v, u) $</li> <li>计算 (f↑f') 的值，确保 <code>|f↑f'| = |f| + |f'|</code></li></ol> <h3 id="增广路径"><a href="#增广路径" class="header-anchor">#</a> 增广路径</h3> <p>给定流网络 G = (V, E) 和流 f，<strong>增广路径</strong> p 是残存网络 Gf 中一条从源结点 s 到汇点 t 的<strong>简单路径</strong>。根据残存网络的定义，对于一条增广路径上的边 (u, v)，可以增加其流量的幅度 最大为 cf(u, v)，再多会违反容量限制。</p> <p>例如前面 图 26-4 (b) 中阴影覆盖的路径是一条增广路径。如果将图中的残存网络 Gf 看作一个流网络，那么可以对这条路径上的<strong>每条边的流量增加</strong> 4 个单位，而不会违反容量限制，因为该条路径上<strong>最小的残存容量</strong>是 cf(v2, v3) = 4。</p> <p>称在一条增广路径 p 上能够为每条边增加的流量的最大值 为路径 p 的<strong>残存容量</strong>，该容量的表达式为：cf(p) = min{cf(u, v): (u, v) 属于路径 p}。下面的引理更加精确地阐述了此论断：</p> <p>《CLRS》<strong>引理 26.2</strong>：设 G = (V, E) 为一个流网络，设 f 为图 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。定义一个函数 fp: V x V -&gt; R 如下：</p> <ul><li>若 (u, v) 在 p 上，则 fp(u, v) = cf(p)</li> <li>若是其它情况，则 fp(u, v) = 0</li></ul> <p>则 fp 是残存网络 Gf 中的一个流，其值为 <code>|fp| = cf(p) &gt; 0</code></p> <hr> <p>下面的推论证明，如果将流 f 增加 fp 的量，则将获得 G 的另一个流，该流的值更加接近最大值。图 26-4 (c) 描述的是对图 26-4 (a) 的流 f 增加图 26-4 (b) 所示的 fp 的量 所获得的结果，而图 26-4 (d) 描述的则是残存网络 Gf。</p> <p>《CLRS》<strong>推论 26.3</strong>：设 G = (V, E) 为一个流网络，设 f 为 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。设 fp 由引理 26.2 所定义，假定将 f 增加 fp 的量，则函数 <code>|f↑fp| = |f| + |fp| &gt; |f|</code>。</p> <h3 id="流网络和切割"><a href="#流网络和切割" class="header-anchor">#</a> 流网络和切割</h3> <p>Ford-Fulkerson 方法的核心就是<strong>沿着增广路径重复增加路径上的流量</strong>，直到找到一个最大流为止。稍后证明的<strong>最大流最小切割定理</strong>表明：一个流是最大流 当且仅当 其残存网络不包含任何增广路径。</p> <p>流网络 G = (V, E) 中的一个切割 (S, T) 将结点集合 V 划分为 S 和 T=V-S 两个不相交集合，且使得源结点 s \in S、汇点 t \in T。这类似于最小生成树 MST 中的切割，不过这里是对有向图的切割，而非无向图。</p> <p>若 f 是一个流，则定义横跨切割 (S, T) 的<strong>净流量</strong> f(S, T) 如下：</p> <p>$$ f(S, T) = \sum_{u \in S} \sum_{v \in T} f(u, v) - \sum_{u \in S} \sum_{v \in T} f(v, u) $$</p> <p>切割 (S, T) 的<strong>容量</strong>是：</p> <p>$$ c(S, T) = \sum_{u \in S} \sum_{v \in T} c(u, v) $$</p> <p>一个网络的<strong>最小切割</strong>是整个网络中<strong>容量最小的切割</strong>。</p> <hr> <p>流的定义和切割容量的定义之间不存在对称性，但这种不对称性是有意而为，并且很重要。对于容量来说，只计算从集合 S 发出、进入集合 T 的边的容量，而忽略反方向边上的容量。对于流，考虑的则是从 S 到 T 的总流量 减去 (反方向)从 T 到 S 的流量。</p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-2.png" alt="ford-fulkerson-2"></p> <p>下面的引理将证明，对于给定流 f，横跨任何切割的净流量都相同，都等于 <code>|f|</code>，即流的值。</p> <p>《CLRS》<strong>引理 26.4</strong>：设 f 为流网络 G 的一个流，该流网络的源结点为 s，汇点为 t，设 (S, T) 为流网络 G 的<strong>任意切割</strong>，则横跨切割 (S, T) 的净流量为 f(S, T) = <code>|f|</code>。</p> <p>引理 26.4 的如下推论 说明如何使用切割容量来限定一个流的值。</p> <p>《CLRS》<strong>推论 26.5</strong>：流网络 G 中任意流 f 的值不能超过 G 的任意切割的容量。</p> <p>此推论给出的一个直接结论是：<strong>一个流网络中最大流的值不能超过该网络最小切割的容量</strong>。这就是下面要来陈述和证明的非常重要的最大流最小切割定理。该定理表明一个最大流的值 事实上等于一个最小切割的容量。</p> <p>《CLRS》<strong>定理 26.6</strong>（<strong>最大流最小切割定理</strong>）：设 f 为流网络 G = (V, E) 中的一个流，该流网络的源结点为 s，汇点为 t，则下面的条件是等价的：</p> <ol><li>f 是 G 的一个最大流。</li> <li>残存网络 Gf 不包含任何增广路径。
<ul><li>增广路径：残存网络 Gf 中一条从源结点 s 到汇点 t 的简单路径。</li></ul></li> <li>最大流的值 <code>|f|</code> = c(S, T)，其中 (S, T) 是流网络 G 的某个切割。</li></ol> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-3.png" alt="ford-fulkerson-3"></p> <h2 id="基本的-ford-fulkerson-算法"><a href="#基本的-ford-fulkerson-算法" class="header-anchor">#</a> 基本的 Ford-Fulkerson 算法</h2> <p>在 Ford-Fulkerson 方法的每次迭代中，寻找某条增广路径 p，然后使用 p 来对流 f 进行修改（增加）。正如引理 26.2 和推论 26.3 所示，以 f↑fp 来替换 f，从而获得一个值为 <code>|f| + |fp|</code> 的更大的流。</p> <p>在如下算法实现中，通过为每条边 (u, v) \in E 更新流属性 (u, v).f 来计算流网络 G = (V, E) 中的最大流。如果边 (u, v) \notin E，则设置 (u, v).f = 0。另外，假设流网络各边的容量 c(u, v) 都已经给出，如果边 (u, v) \notin E，则设置 c(u, v) = 0。根据如下式子来计算残存容量 cf(u, v)。代码中的表达式 cf(p) 只是一个临时变量，用于存放路径 p 的残存容量。</p> <ul><li>若 (u, v) \in E，则 cf(u, v) = c(u, v) - f(u, v)</li> <li>若 (v, u) \in E，则 cf(u, v) = f(v, u)</li> <li>若是其它情况，则 cf(u, v) = 0</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FORD_FULKERSON(G, s, t)
1  for each edge(u, v) \in G.E
2      (u, v).f = 0
3  while there exists a path p from s to t in the residual network Gf
4      cf(p) = min { cf(u, v): (u, v) is in path p }
5      for each edge(u, v) in p
6          if (u, v) \in E
7              (u, v).f = (u, v).f + cf(p)
8          else
9              (v, u).f = (v, u).f - cf(p)
</code></pre></div><p><code>FORD_FULKERSON(G, s, t)</code> 算法是对 <code>FORD_FULKERSON_METHOD(G, s, t)</code> 方法的简单扩展。算法流程描述如下：</p> <ol><li>在 1～2 行，将流 f 初始化为 0。</li> <li>在 3～9 行的 while 循环中，重复在残存网络 Gf 中寻找一条增广路径 p，然后使用残存容量 cf(p) 来对路径 p 上的流 f 进行增加。路径 p 上的一条边要么是原来网络中的一条边，要么是原来网络中的边 的反向边。
<ul><li>在 4 行，找出路径 p 中的最小残存容量 cf(u, v)。</li> <li>在 5～9 行的 for 循环中，对路径上 p 的每条边 (u, v) 的流量进行更新。</li> <li>在 6～7 行，如果残存边 (u, v) 是原来流网络中的一条边，则增加其流量 (u, v).f</li> <li>在 8～9 行，如果残存边 (u, v) 不是原来流网络中的一条边，则减少其反向边 (v, u) 流量 (v, u).f</li></ul></li> <li>最后，当 while 循环结束时，不再有增广路径。根据最大流最小切割定理，此时流 f 就是最大流。</li></ol> <h3 id="ford-fulkerson-算法的分析"><a href="#ford-fulkerson-算法的分析" class="header-anchor">#</a> Ford-Fulkerson 算法的分析</h3> <p>Ford-Fulkerson 算法的运行时间取决于算法第 3 行是如何寻找增广路径 p 的。如果使用广度优先搜索 BFS 来寻找增广路径，算法的运行时间是多项式数量级。如果选择不好，<code>FORD_FULKERSON</code> <strong>算法</strong>可能不会终止：流的值会随着后续的递增 (augmentation) 而增加，但它却不一定收敛于最大的流值。</p> <p>另外，只有当变得容量为<strong>无理数</strong>时，<code>FORD_FULKERSON_METHOD</code> <strong>方法</strong>才可能无法终止。下面均假定所选择的任意增广路径 p 和所有的容量 c 都是整数值。在实际情况中，最大流问题中的容量常常都是整数。如果容量为有理数，则可以通过乘以某个系数（或者采用近似值）来将其转换为整数。</p> <hr> <p>如果 f* 表示转换后网络中的一个最大流，则在 <code>FORD_FULKERSON</code> 算法的一个直接实现中，执行第 3～9 行的 while 循环的次数最多为 <code>|f*|</code> 次，因为流量值在每次迭代中至少增加一个单位。</p> <p>如果用于实现流网络 G = (V, E) 的数据结构是合理的，并且寻找一条增广路径 p 的算法时间是线性的（比如 DFS 和 BFS），则整个 while 循环的执行将非常高效。假设有一个与有向图 G' = (V, E') 相对应的数据结构，这里 E' = {(u, v): (u, v) \in E 或者 (v, u) \in E}。网络 G 中的边也是网络 G' 中的边，因此在这一数据结构中，保持其容量和流就非常简单了。给定网络 G 的一个流 f，残存网络 Gf 中的边由网络 G' 中所有满足条件 cf(u, v) &gt; 0 的边 (u, v) 所构成，其中 cf 遵守前述残存容量的性质。</p> <p>因此，如果使用深度优先搜索 DFS 或广度优先搜索 BFS，在一个残存网络中找到一条路径的时间应是 <code>O(|V| + |E'|) = O(|E|)</code>。而 while 循环的每一遍执行所需的时间因此为 <code>O(|E|)</code>，这与算法第 1～2 行的初始化成本一样，从而整个 <code>FORD_FULKERSON</code> 算法的运行时间为 <code>O(|E|·|f*|)</code>。</p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-4.png" alt="ford-fulkerson-4"></p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-5.png" alt="ford-fulkerson-5"></p> <p>当容量都是整数值且最优的流量值 <code>|f*|</code> 较小时，<code>FORD_FULKERSON</code> 算法的运行时间相等不错。但当最优流量值 <code>|f*|</code> 取值较大时，可能会效率很慢，如图 26-7 示例。</p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-6.png" alt="ford-fulkerson-6"></p> <h2 id="edmonds-karp-算法"><a href="#edmonds-karp-算法" class="header-anchor">#</a> Edmonds-Karp 算法</h2> <p>可以通过在 <code>FORD_FULKERSON</code> 算法第 3 行寻找增广路径 p 的操作中 使用广度优先搜索 BFS 来改善算法的效率。即 在残存网络中选择的增广路径是一条从源结点 s 到汇点 t 的(无权重)最短路径，BFS 时每条边的权重均为单位距离。称如此实现的 Ford-Fulkerson 方法为 Edmonds-Karp 算法，其运行时间为 <code>O(|V|·|E|^2)</code>，这就与最优流量值 <code>|f*|</code> 的取值大小无关了。</p> <p>对 Edmonds-Karp 算法的分析取决于残存网络 Gf 中结点之间的距离。下面的引理使用符号 df(u, v) 来表示残存网络 Gf 中从结点 u 到结点 v 的(无权重)最短路径距离，其中每条边的权重为单位距离。</p> <p>《CLRS》<strong>引理 26.7</strong>：如果 Edmonds-Karp 算法运行在流网络 G = (V, E) 上，该网络的源结点为 s、汇点为 t，则对于所有的结点 v \in V-{s, t}，残存网络 Gf 中<strong>最短路径距离</strong> df(u, v) 随着每次流量的递增 而<strong>单调递增</strong>。</p> <p>下面的定理给出了 Edmonds-Karp 算法的迭代次数的上界。</p> <p>《CLRS》<strong>定理 26.8</strong>：如果 Edmonds-Karp 算法运行在源结点为 s、汇点为 t 的流网络 G = (V, E) 上，则该算法所执行的流量递增操作的总次数为 <code>O(|V|·|E|)</code>。</p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-7.png" alt="ford-fulkerson-7"></p> <p>由于在用广度优先搜索 BFS 寻找增广路径时，<code>FORD_FULKERSON(G, s, t)</code> 中的每次迭代可以在 <code>O(|E|)</code> 时间内实现，所以 Edmonds-Karp 算法的总运行时间为 <code>O(|V|·|E|^2)</code>。</p> <p>而<strong>推送-重贴标签</strong>算法能够取得更好的界，可以达到 <code>O(|V|^2·|E|)</code> 甚至 <code>O(|V|^3)</code>。</p> <h2 id="最大二分匹配"><a href="#最大二分匹配" class="header-anchor">#</a> 最大二分匹配</h2> <p>一些组合问题可以很容易地标注为最大流问题，例如多源结点多汇点的最大流问题。其它一些组合问题在表面上看似与流网络没有什么关系，但实际上却能够归约到最大流问题，比如<strong>最大二分匹配</strong>问题：在一个二分图(或称“二部图”)中找出一个最大匹配。</p> <p>解决此问题 将用到由 Ford-Fulkerson 方法所提供的完整性性质 (integrality property)。使用 Ford-Fulkerson 方法能够在 <code>O(|V|·|E|)</code> 时间内解决图 G = (V, E) 的最大二分匹配问题。</p> <h3 id="最大二分匹配问题"><a href="#最大二分匹配问题" class="header-anchor">#</a> 最大二分匹配问题</h3> <p>二分图的最大匹配 (Bipartite Graph Maximum Matching)</p> <p>给定一个<strong>无向图</strong> G = (V, E)，一个<strong>匹配</strong> (match) 是边的一个子集 $ M \subseteq E $，使得对于所有结点 v \in V，子集 M 中<strong>最多有一条边</strong>与结点 v 关联。如果子集 M 中的某条边与结点 v 关联，则称结点 v <strong>由 M 所匹配</strong>；否则，结点 v 就是<strong>没有匹配</strong>的。<strong>最大匹配</strong>是具有<strong>最大基数</strong>的边集 M。这里的“最大”也是“极大”的意思。</p> <p>最大匹配问题不仅限于 二分图，即两类事物的最大匹配，而是可以在 n 分图 (n &gt;= 2) 上寻找最大匹配。而二分图的匹配是其中最基础的，也最具有代表性。</p> <p>在一个二分图中，结点集合 V 有划分 {L, R}，并且边集合 E 中所有的边都横跨 L 和 R。即：任意边 (u, v) \in E，要么 u \in L 且 v \in R，要么 u \in R 且 v in L。进一步假定无向图 G 是<strong>连通</strong>的，因此 V 中的每个结点至少关联了一条边。</p> <p><img src="/img/info-technology/algorithm/graph-theory/max-flow-matching/bipartite-graph-maximum-matching-1.png" alt="bipartite-graph-maximum-matching-1"></p> <p>在二分图中寻找最大匹配问题有许多实际的应用。例如，把一个机器集合 L 和待执行的任务集合 R 相匹配。E 中有边 (u, v) 就说明机器 u \in L 能够完成任务 v \in R。最大匹配能够让尽可能多的机器同时运行。</p> <p>最大二分匹配问题仅需匹配的基数越大越好，因此边的权重都设定为单位权重，即无权图。但如果考虑边的权重，则可以建模更多的场景，如果在带权图中 希望匹配的总权重值最高，则是最佳匹配的问题了。</p> <h3 id="寻找最大二分匹配"><a href="#寻找最大二分匹配" class="header-anchor">#</a> 寻找最大二分匹配</h3> <p>使用 Ford-Fulkerson 方法可以在 <code>O(|V|·|E|)</code> 时间内找出(无权)无向二分图 G = (V, E) 的最大匹配。解决这一问题的关键技巧是增加额外的源结点 s 和汇点 t，构造出一个流网络，其中的流对应于匹配，如图 26-8 (c) 所示。</p> <p>将二分图 G 所对应的流网络 G' = (V', E') 定义如下：设源结点 s 和汇点 t 为原本不属于结点集合 V 的新结点，并设 V' = V \cup {s, t}。如果图 G 的结点集划分为 V = L \cup R，则 E 中所有从 L 指向 R 的边都是流网络 G' 的边。此外 G' 中的边还包括 <code>|V|</code> 条新的有向边。E' = {(s, u): u \in L} \cup E \cup {(v, t): v \in R}</p> <p>最后，给 E' 中的每条边赋予<strong>单位容量</strong>。由于结点集 V 中的每个结点至少有一条相连的边，<code>|E &gt;= |V| / 2</code>。因此 <code>|E| &lt;= |E'| = |E| + |V| &lt;= 3 |E|</code>，所以 <code>|E'| = \Theta(|E|)</code>。</p> <p>下面的引理证明了图 G 中的一个匹配直接对应 G 所对应的流网络 G' 中的一个流。对于流网络 G = (V, E) 中的一个流 f 来说，如果对于所有的边 (u, v) \in V x V，f(u, v) 都是整数值，则称流 f 是<strong>整数值</strong>的。</p> <p>《CLRS》<strong>引理 26.9</strong>：设 G = (V, E) 为一个二分图，其结点划分为 V = L \cup R，设 G' = (V', E') 是图 G 所对应的流网络。如果 M 是 G 中的一个匹配，则流网络 G' 中存在一个整数值的流 f，使得 <code>|f| = |M|</code>。相反，如果 f 是 G' 中的一个整数值的流，则图 G 中存在一个匹配 M，使得 <code>|M| = |f|</code>。</p> <p>基于引理 26.9，希望得出如下结论：二分图 G 中的一个最大匹配对应于流网络 G' 中的一个最大流，并且可以通过在流网络 G' 上运行一个最大流算法来计算出图 G 中的最大匹配。此结论的得来 存在的唯一障碍是：最大流算法可能返回流网络 G' 中一个非整数的流 f(u, v)，即便流的值 <code>|f|</code> 本身必须是整数。不过，下面的定理将说明，如果使用 Ford-Fulkerson 方法，前述问题不会发生，因此前述结论能够成立。</p> <p>《CLRS》<strong>定理 26.10</strong>（<strong>完整性定理</strong>）：如果容量函数 c 只能取整数值，则 Ford-Fulkerson 方法所生成的最大流 f 满足 <code>|f|</code> 是整数值的性质。而且，对于所有的结点 u 和 v，f(u, v) 的值都是整数。</p> <p>定理 26.10 可以通过对迭代次数进行归纳来证明。下面给出引理 26.9 的一个推论：</p> <p>《CLRS》<strong>推论 26.11</strong>：二分图 G 中的一个最大匹配 M 的基数 等于 其对应的流网络 G' 中某一最大流 f 的值。</p> <p>因此，给定一个无向二分图 G，可以通过创建流网络 G'，在其上运行 Ford-Fulkerson 方法来找到一个最大匹配。这个最大匹配 M 可以直接从找到的整数最大流 f 中获得。由于二分图中任何匹配的基数最大值为 min(L, R) = <code>O(|V|)</code>，G' 中最大流的值为 <code>O(|V|)</code>。又由于 <code>|E'| = \Theta(|E|)</code>，所以可以在 <code>O(|V|·|E'|) = O(|V|·|E|)</code> 时间内找到一个二分图的最大匹配。</p> <h3 id="hopcroft-karp-最大二分匹配算法"><a href="#hopcroft-karp-最大二分匹配算法" class="header-anchor">#</a> Hopcroft-Karp 最大二分匹配算法</h3> <p>目前最快的解决最大二分匹配问题的算法是由 Hopcroft 和 Karp[176] 所发明的，其运行时间为 <code>O(|E|·\sqrt(|V|))</code></p> <p>[176] John E. Hopcroft and Richard M. Karp. An n^{5/2} algorithm for maximum matchings in biparite graphs. <em>SIAM Journal on Computing</em>, 2(4):225-231, 1973.</p> <p>给定一个无向二分图 G = (V, E)，其中 V = L \cup R 并且所有的边都恰有一个端点在集合 L 中，而另一个端点在集合 R 中。设 M 为图 G 的一个匹配。</p> <p>对于图 G 中的一条简单路径 P，如果该路径的起点是 L 中一个未匹配的结点，终结点是集合 R 中的一个未匹配的结点，而路径上的边交替属于 M 和 E-M，则称路径 P 是一条相对于 M 的增广路径（此增广路径的定义与流网络中的增广路径相关，但并不相同）。</p> <p>在这里，将一条路径看作是一系列的边，而不是一系列的结点。一条关于匹配 M 的最短增广路径是一条包含最少边数的增广路径。</p> <p>给定两个集合 A 和 B，<strong>对称差</strong> A \oplus B 定义为 (A-B) \cup (B-A)，即仅在一个集合中出现的元素。</p> <p>详见《CLRS》思考题 26-6</p> <h3 id="完全匹配"><a href="#完全匹配" class="header-anchor">#</a> 完全匹配</h3> <p><strong>完全匹配</strong>是指图中所有的结点都得到匹配的匹配。设 G = (V, E) 是结点划分为 V = L \cup R 的无向二分图，其中 <code>|L| == |R|</code>。对于任意结点子集 $ X \subseteq V $，定义 X 的<strong>邻居</strong>为：N(X) = {y \in V: 对某个 x \in X，(x, y) \in E}，即由与集合 X 中的元素 相邻的结点所构成的集合。</p> <p>关于完全匹配，有 <strong>Hall 定理</strong>：图 G 中存在一个完全匹配 当且仅当 对于每个边子集 $ A \subseteq L $，有 <code>|A| &lt;= |N(A)|</code>。</p> <h3 id="d-正则"><a href="#d-正则" class="header-anchor">#</a> d 正则</h3> <p>对于一个结点划分为 V = L \cup R 的无向二分图 G = (V, E) 而言，如果每个属于结点集合 V 的结点 v 的度数都是自然数 d，则称该二分图是 <strong>d 正则的</strong>。对于每个 d 正则的二分图，都有 <code>|L| == |R|</code>。</p> <p>可以证明：每个 d 正则二分图的匹配基数都是 <code>|L|</code>。</p> <p>证明思路：该二分图对应的流网络的一个最小切割的容量为 <code>|L|</code>。</p> <h2 id="python-代码范例"><a href="#python-代码范例" class="header-anchor">#</a> Python 代码范例</h2> <p>Python 环境：Python 3.7</p> <h3 id="ford-fulkerson-最大流算法"><a href="#ford-fulkerson-最大流算法" class="header-anchor">#</a> Ford-Fulkerson 最大流算法</h3> <ul><li>Ford-Fulkerson 方法
<ul><li>Ford-Fulkerson 算法 O(V |f*|)</li> <li>Edmonds-Karp 算法 O(V E^2)</li></ul></li> <li>Push-Relabel 推送-重贴标签方法
<ul><li>Push-Relabel 通用的推送-重贴标签算法 O(V^2 E)</li> <li>Relabel-To-Front 前置重贴标签算法 O(V^3)</li></ul></li></ul> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment">#!/usr/bin/env python</span>
<span class="token comment"># -*- coding:utf-8 -*-</span>
<span class="token triple-quoted-string string">&quot;&quot;&quot;=================================================
@Project : algorithm/graph_theory/max_flow
@File    : ford-fulkerson.py
@Author  : YuweiYin
@Date    : 2020-06-03
==================================================&quot;&quot;&quot;</span>

<span class="token keyword">import</span> sys
<span class="token keyword">import</span> time
<span class="token keyword">import</span> queue

<span class="token triple-quoted-string string">&quot;&quot;&quot;
最大流 Max-Flow

- Ford-Fulkerson 方法
    - Ford-Fulkerson 算法
    - Edmonds-Karp 算法

参考资料：
Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26
&quot;&quot;&quot;</span>


<span class="token comment"># 边结构体，表达边的信息，可随任务自定义 (增添其它值元素 val 对象)</span>
<span class="token keyword">class</span> <span class="token class-name">Edge</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> from_v<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> to_v<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> weight<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> is_directed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> capacity<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>from_v <span class="token operator">=</span> from_v  <span class="token comment"># 边的起始顶点(关键字/序号)</span>
        self<span class="token punctuation">.</span>to_v <span class="token operator">=</span> to_v      <span class="token comment"># 边的终止顶点(关键字/序号)</span>
        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> weight  <span class="token comment"># (用于最短路)边的权重值 (默认值为 1，如果全部边的权重都相同，那图 G 就是无权图)</span>
        self<span class="token punctuation">.</span>is_directed <span class="token operator">=</span> is_directed  <span class="token comment"># True 则表明此边是有向边，False 为无向边</span>
        <span class="token comment"># 对无向边而言，起始顶点和终止顶点可以互换</span>
        <span class="token triple-quoted-string string">'''下面是用于 Max-Flow 的属性'''</span>
        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity  <span class="token comment"># 此边的最大容量</span>
        self<span class="token punctuation">.</span>flow <span class="token operator">=</span> <span class="token number">0</span>             <span class="token comment"># 此边最大流的流量，初始为 0，取值范围 0 &lt;= flow &lt;= capacity</span>
        <span class="token comment"># 运行过程中的边流量存储于矩阵中，这里的 self.flow 仅存储最终的本条边的流量</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>from_v<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-&gt;'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>to_v<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\t capacity:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\t flow:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>flow<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\t weight:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\t is_directed:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>is_directed<span class="token punctuation">)</span>


<span class="token comment"># 用于邻接矩阵的顶点结构体 (比 VertexList 简单)</span>
<span class="token comment"># 这里是用散列表 (而不是用链表) 来表达某顶点的所有邻接顶点</span>
<span class="token keyword">class</span> <span class="token class-name">VertexMatrix</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> distance<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key            <span class="token comment"># 本顶点的关键字 key (通常为顶点序号、唯一标志符)</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val            <span class="token comment"># 本顶点的值元素 val (可自定义为任意对象，为结点附带的信息)</span>
        <span class="token triple-quoted-string string">'''下面是用于 BFS 的属性'''</span>
        self<span class="token punctuation">.</span>color <span class="token operator">=</span> color        <span class="token comment"># False 为&quot;白色&quot;，表示未被发现；True 为&quot;黑色&quot;，表示已经探索结束</span>
        self<span class="token punctuation">.</span>distance <span class="token operator">=</span> distance  <span class="token comment"># 此结点距离源结点的距离 (最短简单路径的边数)</span>
        self<span class="token punctuation">.</span>p <span class="token operator">=</span> p                <span class="token comment"># 此结点的前驱结点/广度优先搜索树的父结点</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'Vertex key: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span>


<span class="token comment"># (带边权的)邻接矩阵的图结构，通常适合稠密图</span>
<span class="token comment"># 输入顶点结构体列表、边结构体列表</span>
<span class="token keyword">class</span> <span class="token class-name">AdjacencyMatrix</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> edges<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vertices<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>

        <span class="token comment"># self.inf = 0x3f3f3f3f        # 初始各边的权重值均为 inf 无穷</span>
        self<span class="token punctuation">.</span>max_flow <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 经最大流算法后计算出的最大流值</span>
        self<span class="token punctuation">.</span>edges <span class="token operator">=</span> edges           <span class="token comment"># 存储输入的边列表</span>
        self<span class="token punctuation">.</span>key2e_index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment"># 由(起始,终止)顶点的关键字/唯一标志符映射到边数组下标</span>

        self<span class="token punctuation">.</span>vertices <span class="token operator">=</span> vertices     <span class="token comment"># 存储输入的顶点列表 (可以从下标映射到顶点)</span>
        self<span class="token punctuation">.</span>v2index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token comment"># 由顶点映射到其下标 (既是邻接矩阵的行/列下标，也是 vertices 列表的下标)</span>
        self<span class="token punctuation">.</span>key2v_index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment"># 由顶点的关键字/唯一标志符映射到顶点数组下标</span>
        <span class="token keyword">for</span> index<span class="token punctuation">,</span> vertex <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>v2index<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span> <span class="token operator">=</span> index
            self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>vertex<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> index

        <span class="token comment"># 构建邻接矩阵(二维方阵)，adj[x][y] 的值为边 (x, y) 的当前流量，而不是边权重</span>
        <span class="token comment"># 这里用于残存网络 Gf，可以有反平行边。如果 adj[x][y] 为 0 表示没有此边，在 Gf 上运行 BFS</span>
        v_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span>  <span class="token comment"># 顶点数目</span>
        self<span class="token punctuation">.</span>adj_m <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> v_num <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>v_num<span class="token punctuation">)</span><span class="token punctuation">]</span>

        <span class="token comment"># 若 edges 合法，则进行边初始化处理</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> index<span class="token punctuation">,</span> edge <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 断言最大流算法里都是有向边</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span> <span class="token keyword">and</span> edge<span class="token punctuation">.</span>is_directed
                from_v <span class="token operator">=</span> edge<span class="token punctuation">.</span>from_v      <span class="token comment"># 边起点的关键字 key</span>
                to_v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to_v          <span class="token comment"># 边终点的关键字 key</span>
                capacity <span class="token operator">=</span> edge<span class="token punctuation">.</span>capacity  <span class="token comment"># 边的容量</span>
                self<span class="token punctuation">.</span>key2e_index<span class="token punctuation">[</span><span class="token punctuation">(</span>from_v<span class="token punctuation">,</span> to_v<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> index
                <span class="token keyword">if</span> from_v <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_v <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
                    <span class="token comment"># 将顶点关键字 key 转为下标 index，然后初始化 adj[from][to] 为边的最大容量</span>
                    from_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_v<span class="token punctuation">]</span>
                    to_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_v<span class="token punctuation">]</span>
                    <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> from_index <span class="token operator">&lt;</span> v_num <span class="token keyword">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> to_index <span class="token operator">&lt;</span> v_num
                    self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span> <span class="token operator">=</span> capacity

    <span class="token comment"># 判断 key 号为 _key 的顶点是否位于顶点列表中</span>
    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> _key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> _key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index

    <span class="token comment"># 获取图中 key 号为 _key 的顶点，如果没有此顶点则返回 None</span>
    <span class="token keyword">def</span> <span class="token function">get_vertex</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> _key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> _key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>_key<span class="token punctuation">]</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 邻接矩阵 - 图转置</span>
    <span class="token keyword">def</span> <span class="token function">graph_transposition</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> edge <span class="token keyword">in</span> self<span class="token punctuation">.</span>edges<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span>
            <span class="token comment"># 其实如果是无向边，无需处理，但这里还是转了</span>
            <span class="token comment"># 先获取 key</span>
            from_key <span class="token operator">=</span> edge<span class="token punctuation">.</span>from_v
            to_key <span class="token operator">=</span> edge<span class="token punctuation">.</span>to_v
            <span class="token comment"># 交换 key</span>
            edge<span class="token punctuation">.</span>from_v <span class="token operator">=</span> to_key
            edge<span class="token punctuation">.</span>to_v <span class="token operator">=</span> from_key
            <span class="token comment"># 把 key 转成 index</span>
            <span class="token keyword">assert</span> from_key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index
            from_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_key<span class="token punctuation">]</span>
            to_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_key<span class="token punctuation">]</span>
            <span class="token comment"># 修改邻接矩阵</span>
            temp <span class="token operator">=</span> self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">[</span>from_index<span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">[</span>from_index<span class="token punctuation">]</span> <span class="token operator">=</span> temp

    <span class="token comment"># 输出邻接矩阵</span>
    <span class="token keyword">def</span> <span class="token function">print_matrix_info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>adj_m<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> row <span class="token keyword">in</span> self<span class="token punctuation">.</span>adj_m<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>


<span class="token comment"># 广度优先搜索 (Breadth First Search, BFS)</span>
<span class="token keyword">class</span> <span class="token class-name">BFS</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 初始化各个结点距离源结点的距离为 inf 无穷</span>
        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment"># 从源结点 s 到目标结点 v 的一条最短路径上的所有结点(的关键字)</span>
        self<span class="token punctuation">.</span>end_recursion <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 如果此标志为真，则会结束掉递归过程</span>

    <span class="token comment"># 输入：输入图结构默认为邻接矩阵 adj_m，而 start_key 为源顶点的关键字</span>
    <span class="token keyword">def</span> <span class="token function">do_bfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj_m<span class="token punctuation">,</span> start_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span>
        <span class="token comment"># 先把 start_key 源顶点的关键字 转为源结点结构体</span>
        <span class="token keyword">if</span> start_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            start_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>start_key<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> start_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">)</span>
            start_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的 start_key 不是任何顶点的关键字，BFS 失败'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>

        <span class="token comment"># 1. 除了源结点 s 外，将其余所有结点 u 的状态标记为“未被发现”，即 color 为白色 white</span>
        <span class="token comment"># 另外，将 u.d 设置为无穷 inf，表示从源结点不可达结点 u。由于未探索到结点 u，将其前驱结点设置为空 nil</span>
        <span class="token keyword">for</span> v <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
            v<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
            v<span class="token punctuation">.</span>distance <span class="token operator">=</span> self<span class="token punctuation">.</span>inf
            v<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token comment"># 2. 设置源结点 s 的属性。由于已经发现了 s，所以 s.color 设置为灰色 gray。结点 s 到自身的距离为 0</span>
        <span class="token comment"># 结点 s 为 BFS 树的树根，所以前驱/父结点 u.p 为空 nil</span>
        start_v<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
        start_v<span class="token punctuation">.</span>distance <span class="token operator">=</span> <span class="token number">0</span>
        start_v<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token comment"># 3. 将 s 加入辅助队列 Q，成为其唯一成员</span>
        aux_queue <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Python 内建 queue 队列对象</span>
        aux_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>start_v<span class="token punctuation">)</span>

        <span class="token comment"># 4. 在 while 循环中，先进先出地逐个处理队列 Q 中的结点</span>
        <span class="token keyword">while</span> <span class="token keyword">not</span> aux_queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 4.1. 先取出 Q 队首结点 u</span>
            u <span class="token operator">=</span> aux_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span> <span class="token keyword">and</span> u<span class="token punctuation">.</span>key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
            u_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>u<span class="token punctuation">.</span>key<span class="token punctuation">]</span>

            <span class="token comment"># 4.2. 逐个处理 u 的所有邻接结点 v</span>
            <span class="token keyword">for</span> v_index<span class="token punctuation">,</span> edge_flow <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>u_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 邻接矩阵中边流量为 0 表示残存网络中没有此边</span>
                <span class="token keyword">if</span> edge_flow <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                <span class="token comment"># 获取边的终点 v 结构体</span>
                v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>v_index<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>

                <span class="token comment"># 4.3. 如果 v.color 是白色，表示它未被发现，需要被加入到队列 Q 中。在入队之前，需要设置其属性：</span>
                <span class="token comment">#     - v.color 颜色设置为灰色，表示它已被发现，但是尚未被探索完（所谓探索结束，是其邻接结点都已被处理）</span>
                <span class="token comment">#     - v.d 是 v 到源结点 s 的距离，这个距离等于 u.d 距离加上 1</span>
                <span class="token comment">#     - v.p 设置前驱/父结点为 u</span>
                <span class="token comment">#     - 将 v 入队，之后的 while 循环中 会考察 v 的各个邻接结点</span>
                <span class="token keyword">if</span> <span class="token keyword">not</span> v<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                    v<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                    v<span class="token punctuation">.</span>distance <span class="token operator">=</span> u<span class="token punctuation">.</span>distance <span class="token operator">+</span> <span class="token number">1</span>
                    v<span class="token punctuation">.</span>p <span class="token operator">=</span> u
                    aux_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token comment"># 4. for 循环结束，u 的所有邻接结点都被考察了，所以 u 已经被探索结束了。u.color 设置为黑色，保证不会再被加入队列 Q</span>
            <span class="token comment"># u.color = True</span>

    <span class="token comment"># 在计算出 BFS 之后，打印出所有结点(的关键字)及其距离</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">print_vertex_distance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span>
        <span class="token keyword">for</span> v <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>key<span class="token punctuation">,</span> v<span class="token punctuation">.</span>distance<span class="token punctuation">)</span>

    <span class="token comment"># 在计算出 BFS 之后，获取从源结点 s 到目标结点 v 的一条最短路径上的所有结点(的关键字)</span>
    <span class="token comment"># 此处图结构为邻接矩阵 adj_m</span>
    <span class="token keyword">def</span> <span class="token function">get_path</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj_m<span class="token punctuation">,</span> start_key<span class="token punctuation">,</span> end_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># return 'get_path: 输入的参数类型不合法'</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment"># 先把 key 关键字 转为顶点点结构体</span>
        <span class="token keyword">if</span> start_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            start_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>start_key<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> start_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">)</span>
            start_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># return '输入的 start_key 不是任何顶点的关键字'</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">if</span> end_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            end_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>end_key<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> end_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">)</span>
            end_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>end_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>end_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># return '输入的 end_key 不是任何顶点的关键字'</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>end_recursion <span class="token operator">=</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>_get_path<span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> end_v<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>path

    <span class="token keyword">def</span> <span class="token function">_get_path</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start_v<span class="token punctuation">,</span> end_v<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>end_recursion<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        <span class="token keyword">if</span> end_v <span class="token operator">==</span> start_v<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start_v<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>end_v<span class="token punctuation">.</span>p<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># self.path = 'No path from ' + str(start_v.key) + ' to ' + str(end_v.key) + ' exists.'</span>
            self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>end_recursion <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 先获取其前驱结点/父结点的关键字，再获取本结点的关键字</span>
            self<span class="token punctuation">.</span>_get_path<span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> end_v<span class="token punctuation">.</span>p<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>end_v<span class="token punctuation">.</span>key<span class="token punctuation">)</span>


<span class="token comment"># Ford-Fulkerson 最大流算法 - O(VE^2)</span>
<span class="token keyword">class</span> <span class="token class-name">FordFulkerson</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 所有结点的 distance 初始化为 inf</span>

    <span class="token comment"># 计算流网络(邻接矩阵) adj_m 的最大流</span>
    <span class="token keyword">def</span> <span class="token function">do_edmonds_karp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj_m<span class="token punctuation">,</span> source_v_key<span class="token punctuation">,</span> terminal_v_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 首先确认输入的合法性，并将输入的源结点和汇点关键字 转为结点结构体</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> source_v_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> terminal_v_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
        source_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>source_v_key<span class="token punctuation">]</span><span class="token punctuation">]</span>
        terminal_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>terminal_v_key<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>source_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>terminal_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token comment"># 1. 将各边的流量 flow 初始化为 0</span>
        <span class="token keyword">for</span> edge <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>edges<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span>
            edge<span class="token punctuation">.</span>flow <span class="token operator">=</span> <span class="token number">0</span>

        <span class="token comment"># 2. 在 while 循环中，重复在残存网络 Gf 中寻找一条增广路径 p</span>
        <span class="token comment"># 然后使用残存容量 cf(p) 来对路径 p 上的流 flow 进行增加</span>
        <span class="token comment"># 路径 p 上的一条边要么是原来网络中的一条边，要么是原来网络中的边 的反向边</span>
        <span class="token comment"># 在本实现中，adj_m 中的矩阵保存的就是残存网络 Gf 中各个边的流量</span>
        bfs <span class="token operator">=</span> BFS<span class="token punctuation">(</span><span class="token punctuation">)</span>
        is_exist_aug_path <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 循环标志 True 表示当前残存网络 Gf 中存在一条增广路径</span>
        <span class="token keyword">while</span> is_exist_aug_path<span class="token punctuation">:</span>
            <span class="token comment"># 2.1. 找出增广路径 aug_path</span>
            bfs<span class="token punctuation">.</span>do_bfs<span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> source_v<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            aug_path <span class="token operator">=</span> bfs<span class="token punctuation">.</span>get_path<span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> source_v_key<span class="token punctuation">,</span> terminal_v_key<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 如果不存在增广路径，BFS 会返回空列表。如果返回仅含 1 个元素关键字的列表，是异常情况</span>
                <span class="token keyword">break</span>

            <span class="token comment"># 2.2. 找出路径 p 中的最小残存容量 cf(u, v)</span>
            min_cf <span class="token operator">=</span> self<span class="token punctuation">.</span>inf
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 根据 key 获取 index</span>
                from_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                to_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> from_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
                from_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_key<span class="token punctuation">]</span>
                to_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_key<span class="token punctuation">]</span>
                <span class="token comment"># 更新路径上的最小残存容量 min_cf</span>
                <span class="token keyword">if</span> min_cf <span class="token operator">&gt;</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    min_cf <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> min_cf <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>inf  <span class="token comment"># 断言增广路径上的流量值不为 inf</span>

            <span class="token comment"># 2.3. 在 for 循环中，对路径上 p 的每条边 (u, v) 的流量进行更新</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 根据 key 获取 index</span>
                from_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                to_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> from_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
                from_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_key<span class="token punctuation">]</span>
                to_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_key<span class="token punctuation">]</span>

                <span class="token comment"># 如果残存边 (u, v) 是原来流网络中的一条边，则增加其流量 (u, v).f</span>
                <span class="token comment"># 如果残存边 (u, v) 不是原来流网络中的一条边，则减少其反向边 (v, u) 流量 (v, u).f</span>
                <span class="token comment"># 在本实现中，增加边 (u, v) 的流量，等于缩减 (u, v) 的剩余容量、增加反平行边 (v, u) 的剩余容量</span>
                adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span> <span class="token operator">-=</span> min_cf
                adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">[</span>from_index<span class="token punctuation">]</span> <span class="token operator">+=</span> min_cf

        <span class="token comment"># 3. 最后，当 while 循环结束时，不再有增广路径。根据最大流最小切割定理，此时流 flow 就是最大流</span>
        <span class="token comment"># 在本实现中，adj_m 中的矩阵保存的就是残存网络 Gf 中各个边的流量，最终将实际的流量赋予各个结点的 flow 属性</span>
        adj_m<span class="token punctuation">.</span>max_flow <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> from_index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> to_index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                from_node <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span>
                to_node <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>from_node<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>to_node<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
                <span class="token comment"># 如果此边是原图中的边，则赋予该边 flow 属性，表示最大流的流量</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>from_node<span class="token punctuation">.</span>key<span class="token punctuation">,</span> to_node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2e_index<span class="token punctuation">:</span>
                    edge_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2e_index<span class="token punctuation">[</span><span class="token punctuation">(</span>from_node<span class="token punctuation">.</span>key<span class="token punctuation">,</span> to_node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>
                    edge <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>edge_index<span class="token punctuation">]</span>
                    edge<span class="token punctuation">.</span>flow <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>        <span class="token comment"># 赋予此边流量属性 flow</span>
                    adj_m<span class="token punctuation">.</span>max_flow <span class="token operator">+=</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>  <span class="token comment"># 增长图的最大流量值</span>


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造图同《CLRS》图 26-6 的(含边容量的)有向图用于计算最大流</span>
    <span class="token comment"># 用于构造邻接矩阵的顶点的 key/val 信息列表</span>
    matrix_vertices_info <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">]</span>
    <span class="token comment"># 有向边的 from/to/c/is_directed 信息列表</span>
    <span class="token comment"># is_directed 为 True 表示此边为有向边，否则为无向边</span>
    di_edges_info <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span>
    <span class="token punctuation">]</span>

    <span class="token comment"># 根据前述列表信息构造结点列表</span>
    inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 需保证与程序中其它 inf 是相同的值</span>
    matrix_vertices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    di_edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> v <span class="token keyword">in</span> matrix_vertices_info<span class="token punctuation">:</span>
        matrix_vertices<span class="token punctuation">.</span>append<span class="token punctuation">(</span>VertexMatrix<span class="token punctuation">(</span>key<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> distance<span class="token operator">=</span>inf<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> e <span class="token keyword">in</span> di_edges_info<span class="token punctuation">:</span>
        di_edges<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Edge<span class="token punctuation">(</span>from_v<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> to_v<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> capacity<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> is_directed<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 创建邻接矩阵 (用邻接矩阵+有向图 执行最大流算法)</span>
    adj_m <span class="token operator">=</span> AdjacencyMatrix<span class="token punctuation">(</span>matrix_vertices<span class="token punctuation">,</span> di_edges<span class="token punctuation">)</span>

    <span class="token comment"># 执行 O(VE^2) Ford-Fulkerson 最大流算法</span>
    source_v_key<span class="token punctuation">,</span> terminal_v_key <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'t'</span>
    ford_fulkerson <span class="token operator">=</span> FordFulkerson<span class="token punctuation">(</span><span class="token punctuation">)</span>
    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ford_fulkerson<span class="token punctuation">.</span>do_edmonds_karp<span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> source_v_key<span class="token punctuation">,</span> terminal_v_key<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果 &amp; 运行时间</span>
    <span class="token comment"># max_flow: 23</span>
    <span class="token comment"># [0, 4, 2, 0, 0, 0]</span>
    <span class="token comment"># [12, 0, 0, 0, 0, 0]</span>
    <span class="token comment"># [11, 4, 0, 0, 3, 0]</span>
    <span class="token comment"># [0, 12, 9, 0, 7, 1]</span>
    <span class="token comment"># [0, 0, 11, 0, 0, 0]</span>
    <span class="token comment"># [0, 0, 0, 19, 4, 0]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\nmax_flow:'</span><span class="token punctuation">,</span> adj_m<span class="token punctuation">.</span>max_flow<span class="token punctuation">)</span>
    adj_m<span class="token punctuation">.</span>print_matrix_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4a794670.js" defer></script><script src="/assets/js/2.db22a8ef.js" defer></script><script src="/assets/js/43.2f6323ad.js" defer></script>
  </body>
</html>
