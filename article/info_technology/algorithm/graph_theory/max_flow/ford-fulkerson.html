<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Graph Theory - Ford-Fulkerson | YuweiYin</title>
    <meta name="description" content="Homepage of YuweiYin">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/img/YuweiYin.jpeg">
    
    <link rel="preload" href="/assets/css/0.styles.2d4b740c.css" as="style"><link rel="preload" href="/assets/js/app.ff60b80d.js" as="script"><link rel="preload" href="/assets/js/2.db22a8ef.js" as="script"><link rel="preload" href="/assets/js/44.3144e6c6.js" as="script"><link rel="prefetch" href="/assets/js/10.43cb7fc1.js"><link rel="prefetch" href="/assets/js/100.b202406b.js"><link rel="prefetch" href="/assets/js/101.7df82a15.js"><link rel="prefetch" href="/assets/js/102.c361b9f0.js"><link rel="prefetch" href="/assets/js/103.67adeade.js"><link rel="prefetch" href="/assets/js/104.6ca76561.js"><link rel="prefetch" href="/assets/js/105.8520e267.js"><link rel="prefetch" href="/assets/js/106.287ba2f1.js"><link rel="prefetch" href="/assets/js/107.43969f98.js"><link rel="prefetch" href="/assets/js/108.f00ae0a2.js"><link rel="prefetch" href="/assets/js/109.9b2dab62.js"><link rel="prefetch" href="/assets/js/11.3d054225.js"><link rel="prefetch" href="/assets/js/110.a4868526.js"><link rel="prefetch" href="/assets/js/111.2b38d0ce.js"><link rel="prefetch" href="/assets/js/112.9071c6f5.js"><link rel="prefetch" href="/assets/js/113.ec2af34c.js"><link rel="prefetch" href="/assets/js/114.b7fd0ef8.js"><link rel="prefetch" href="/assets/js/115.96e51667.js"><link rel="prefetch" href="/assets/js/116.5d448968.js"><link rel="prefetch" href="/assets/js/117.93458d4e.js"><link rel="prefetch" href="/assets/js/118.48a70bf2.js"><link rel="prefetch" href="/assets/js/119.7eb52262.js"><link rel="prefetch" href="/assets/js/12.cb0421b2.js"><link rel="prefetch" href="/assets/js/120.08b8459f.js"><link rel="prefetch" href="/assets/js/121.6bf62169.js"><link rel="prefetch" href="/assets/js/122.3c945f07.js"><link rel="prefetch" href="/assets/js/123.02d40d25.js"><link rel="prefetch" href="/assets/js/124.50cb9c03.js"><link rel="prefetch" href="/assets/js/125.c8cd1f1f.js"><link rel="prefetch" href="/assets/js/126.15113a24.js"><link rel="prefetch" href="/assets/js/127.73e4b936.js"><link rel="prefetch" href="/assets/js/128.15468dd6.js"><link rel="prefetch" href="/assets/js/129.9878635a.js"><link rel="prefetch" href="/assets/js/13.7aee06ec.js"><link rel="prefetch" href="/assets/js/130.6b782a7a.js"><link rel="prefetch" href="/assets/js/131.fc16811f.js"><link rel="prefetch" href="/assets/js/132.87b1d64d.js"><link rel="prefetch" href="/assets/js/133.2e230efc.js"><link rel="prefetch" href="/assets/js/134.393fb0f5.js"><link rel="prefetch" href="/assets/js/135.6d86de1c.js"><link rel="prefetch" href="/assets/js/136.4c5d3f10.js"><link rel="prefetch" href="/assets/js/137.3a16fa3d.js"><link rel="prefetch" href="/assets/js/138.b571b55e.js"><link rel="prefetch" href="/assets/js/139.af75e7d2.js"><link rel="prefetch" href="/assets/js/14.04ca3795.js"><link rel="prefetch" href="/assets/js/140.540ab500.js"><link rel="prefetch" href="/assets/js/141.136771f7.js"><link rel="prefetch" href="/assets/js/142.0a52fac0.js"><link rel="prefetch" href="/assets/js/143.0c9d5563.js"><link rel="prefetch" href="/assets/js/144.fc43f946.js"><link rel="prefetch" href="/assets/js/145.d54e4586.js"><link rel="prefetch" href="/assets/js/146.2a96bfa4.js"><link rel="prefetch" href="/assets/js/147.c1d9097b.js"><link rel="prefetch" href="/assets/js/148.990ff0a4.js"><link rel="prefetch" href="/assets/js/149.62989821.js"><link rel="prefetch" href="/assets/js/15.4867fa69.js"><link rel="prefetch" href="/assets/js/150.3af257d2.js"><link rel="prefetch" href="/assets/js/151.fd8bb16b.js"><link rel="prefetch" href="/assets/js/152.1a211661.js"><link rel="prefetch" href="/assets/js/153.6ea84c60.js"><link rel="prefetch" href="/assets/js/154.051f1f29.js"><link rel="prefetch" href="/assets/js/155.c7ae1032.js"><link rel="prefetch" href="/assets/js/156.9b7c6e7d.js"><link rel="prefetch" href="/assets/js/157.637d10e0.js"><link rel="prefetch" href="/assets/js/158.08be44de.js"><link rel="prefetch" href="/assets/js/159.91756f38.js"><link rel="prefetch" href="/assets/js/16.62977459.js"><link rel="prefetch" href="/assets/js/160.e9612991.js"><link rel="prefetch" href="/assets/js/161.d497e8da.js"><link rel="prefetch" href="/assets/js/162.c760775e.js"><link rel="prefetch" href="/assets/js/163.a4bff827.js"><link rel="prefetch" href="/assets/js/164.0e75aa8f.js"><link rel="prefetch" href="/assets/js/165.9600328b.js"><link rel="prefetch" href="/assets/js/166.61f2f404.js"><link rel="prefetch" href="/assets/js/167.aaddff92.js"><link rel="prefetch" href="/assets/js/168.6f5cc667.js"><link rel="prefetch" href="/assets/js/169.11b39074.js"><link rel="prefetch" href="/assets/js/17.f9b1f276.js"><link rel="prefetch" href="/assets/js/170.4f509a95.js"><link rel="prefetch" href="/assets/js/171.94175552.js"><link rel="prefetch" href="/assets/js/172.8ee3eb5d.js"><link rel="prefetch" href="/assets/js/173.2dd2c901.js"><link rel="prefetch" href="/assets/js/174.c18d9923.js"><link rel="prefetch" href="/assets/js/175.17944dec.js"><link rel="prefetch" href="/assets/js/176.b07e2384.js"><link rel="prefetch" href="/assets/js/177.1dd1ef4c.js"><link rel="prefetch" href="/assets/js/178.65b359f6.js"><link rel="prefetch" href="/assets/js/179.151c02ba.js"><link rel="prefetch" href="/assets/js/18.e7cdb24c.js"><link rel="prefetch" href="/assets/js/180.0ad165f6.js"><link rel="prefetch" href="/assets/js/181.55e126c1.js"><link rel="prefetch" href="/assets/js/182.c36a7a0a.js"><link rel="prefetch" href="/assets/js/183.eada1656.js"><link rel="prefetch" href="/assets/js/184.6095c63e.js"><link rel="prefetch" href="/assets/js/185.947171fe.js"><link rel="prefetch" href="/assets/js/186.bebb1a9c.js"><link rel="prefetch" href="/assets/js/187.a30d43f0.js"><link rel="prefetch" href="/assets/js/188.2791bc84.js"><link rel="prefetch" href="/assets/js/189.f3fa4e93.js"><link rel="prefetch" href="/assets/js/19.9df357c5.js"><link rel="prefetch" href="/assets/js/190.1841cf95.js"><link rel="prefetch" href="/assets/js/191.2e1a1709.js"><link rel="prefetch" href="/assets/js/192.540e4b78.js"><link rel="prefetch" href="/assets/js/193.41b9a086.js"><link rel="prefetch" href="/assets/js/194.b49490ed.js"><link rel="prefetch" href="/assets/js/195.acacd2e5.js"><link rel="prefetch" href="/assets/js/196.0506d398.js"><link rel="prefetch" href="/assets/js/197.70d491d2.js"><link rel="prefetch" href="/assets/js/198.08c4f488.js"><link rel="prefetch" href="/assets/js/199.b616c7ba.js"><link rel="prefetch" href="/assets/js/20.7cdccd11.js"><link rel="prefetch" href="/assets/js/200.71718b84.js"><link rel="prefetch" href="/assets/js/201.fe99919d.js"><link rel="prefetch" href="/assets/js/202.b14d7819.js"><link rel="prefetch" href="/assets/js/203.fdcb8793.js"><link rel="prefetch" href="/assets/js/204.87fb3990.js"><link rel="prefetch" href="/assets/js/205.0f46092f.js"><link rel="prefetch" href="/assets/js/206.8ee9d80f.js"><link rel="prefetch" href="/assets/js/207.647e3407.js"><link rel="prefetch" href="/assets/js/208.dad99948.js"><link rel="prefetch" href="/assets/js/209.cd7d9c73.js"><link rel="prefetch" href="/assets/js/21.1f5dcd82.js"><link rel="prefetch" href="/assets/js/210.d81f6953.js"><link rel="prefetch" href="/assets/js/211.a01a959b.js"><link rel="prefetch" href="/assets/js/212.6d7705c3.js"><link rel="prefetch" href="/assets/js/213.c9529234.js"><link rel="prefetch" href="/assets/js/214.ee70aa6f.js"><link rel="prefetch" href="/assets/js/215.8bd0ae99.js"><link rel="prefetch" href="/assets/js/216.f3b5c26d.js"><link rel="prefetch" href="/assets/js/217.5703aa6e.js"><link rel="prefetch" href="/assets/js/218.c467e339.js"><link rel="prefetch" href="/assets/js/219.fbdef8e6.js"><link rel="prefetch" href="/assets/js/22.4ed5f8fd.js"><link rel="prefetch" href="/assets/js/220.f3e64c94.js"><link rel="prefetch" href="/assets/js/221.3922221d.js"><link rel="prefetch" href="/assets/js/222.98dad878.js"><link rel="prefetch" href="/assets/js/223.79f5c51d.js"><link rel="prefetch" href="/assets/js/224.f4f65a07.js"><link rel="prefetch" href="/assets/js/225.41e8626e.js"><link rel="prefetch" href="/assets/js/226.41925ef8.js"><link rel="prefetch" href="/assets/js/227.bf793e76.js"><link rel="prefetch" href="/assets/js/228.a3f765c1.js"><link rel="prefetch" href="/assets/js/229.a831ab84.js"><link rel="prefetch" href="/assets/js/23.1251577a.js"><link rel="prefetch" href="/assets/js/230.430d2d07.js"><link rel="prefetch" href="/assets/js/231.334080fd.js"><link rel="prefetch" href="/assets/js/232.5bda65b6.js"><link rel="prefetch" href="/assets/js/233.16155ed3.js"><link rel="prefetch" href="/assets/js/234.23371cc8.js"><link rel="prefetch" href="/assets/js/235.8212e5bc.js"><link rel="prefetch" href="/assets/js/236.9b4c8f5e.js"><link rel="prefetch" href="/assets/js/237.3e1032b1.js"><link rel="prefetch" href="/assets/js/238.7fd96738.js"><link rel="prefetch" href="/assets/js/239.fbd5314a.js"><link rel="prefetch" href="/assets/js/24.a9ddcf60.js"><link rel="prefetch" href="/assets/js/240.f2626593.js"><link rel="prefetch" href="/assets/js/241.3beef2a8.js"><link rel="prefetch" href="/assets/js/242.8fb5d7a5.js"><link rel="prefetch" href="/assets/js/243.881c8130.js"><link rel="prefetch" href="/assets/js/244.78b941c5.js"><link rel="prefetch" href="/assets/js/245.470206ff.js"><link rel="prefetch" href="/assets/js/246.a5d78d47.js"><link rel="prefetch" href="/assets/js/247.74553343.js"><link rel="prefetch" href="/assets/js/248.32af30b7.js"><link rel="prefetch" href="/assets/js/249.0579d7ac.js"><link rel="prefetch" href="/assets/js/25.12a5f08c.js"><link rel="prefetch" href="/assets/js/250.0e5e608a.js"><link rel="prefetch" href="/assets/js/251.1f24a08d.js"><link rel="prefetch" href="/assets/js/252.ebd0d1e1.js"><link rel="prefetch" href="/assets/js/253.0e3c70d3.js"><link rel="prefetch" href="/assets/js/254.f62a52ca.js"><link rel="prefetch" href="/assets/js/255.68a75c88.js"><link rel="prefetch" href="/assets/js/256.912bee56.js"><link rel="prefetch" href="/assets/js/257.cf680638.js"><link rel="prefetch" href="/assets/js/258.2eceaf3f.js"><link rel="prefetch" href="/assets/js/259.f9a2ce98.js"><link rel="prefetch" href="/assets/js/26.fd0e338a.js"><link rel="prefetch" href="/assets/js/260.99213eb6.js"><link rel="prefetch" href="/assets/js/261.e6890550.js"><link rel="prefetch" href="/assets/js/262.07ad2cfe.js"><link rel="prefetch" href="/assets/js/263.cb349ca4.js"><link rel="prefetch" href="/assets/js/264.15690141.js"><link rel="prefetch" href="/assets/js/265.5c62239e.js"><link rel="prefetch" href="/assets/js/266.3a7d1e47.js"><link rel="prefetch" href="/assets/js/267.3040ea98.js"><link rel="prefetch" href="/assets/js/268.f0f9dc89.js"><link rel="prefetch" href="/assets/js/269.e388bab4.js"><link rel="prefetch" href="/assets/js/27.d13df990.js"><link rel="prefetch" href="/assets/js/270.b2ddf1b4.js"><link rel="prefetch" href="/assets/js/271.08fe825f.js"><link rel="prefetch" href="/assets/js/272.5acd800a.js"><link rel="prefetch" href="/assets/js/273.926f2b35.js"><link rel="prefetch" href="/assets/js/274.9e660690.js"><link rel="prefetch" href="/assets/js/275.c438877e.js"><link rel="prefetch" href="/assets/js/276.5f54c667.js"><link rel="prefetch" href="/assets/js/277.55a4acdd.js"><link rel="prefetch" href="/assets/js/278.aeea1f01.js"><link rel="prefetch" href="/assets/js/279.efbc7013.js"><link rel="prefetch" href="/assets/js/28.018d6db0.js"><link rel="prefetch" href="/assets/js/280.8b4f9c70.js"><link rel="prefetch" href="/assets/js/281.01418315.js"><link rel="prefetch" href="/assets/js/282.5d6e1700.js"><link rel="prefetch" href="/assets/js/283.17f4601c.js"><link rel="prefetch" href="/assets/js/284.de4af0ef.js"><link rel="prefetch" href="/assets/js/285.38a7f808.js"><link rel="prefetch" href="/assets/js/286.4b34ffdd.js"><link rel="prefetch" href="/assets/js/287.7b589fcf.js"><link rel="prefetch" href="/assets/js/288.6817b832.js"><link rel="prefetch" href="/assets/js/289.660a34ae.js"><link rel="prefetch" href="/assets/js/29.1b7f43d0.js"><link rel="prefetch" href="/assets/js/290.56437912.js"><link rel="prefetch" href="/assets/js/291.e9934806.js"><link rel="prefetch" href="/assets/js/292.b5205cdf.js"><link rel="prefetch" href="/assets/js/293.90b85f7b.js"><link rel="prefetch" href="/assets/js/294.8fa52e91.js"><link rel="prefetch" href="/assets/js/295.ba671a6a.js"><link rel="prefetch" href="/assets/js/296.c65a7965.js"><link rel="prefetch" href="/assets/js/297.487fd294.js"><link rel="prefetch" href="/assets/js/298.6d8bbba9.js"><link rel="prefetch" href="/assets/js/299.8d6e9c63.js"><link rel="prefetch" href="/assets/js/3.7ccd8009.js"><link rel="prefetch" href="/assets/js/30.81662dbb.js"><link rel="prefetch" href="/assets/js/300.b224fa4f.js"><link rel="prefetch" href="/assets/js/301.4a8832a5.js"><link rel="prefetch" href="/assets/js/302.57c6441c.js"><link rel="prefetch" href="/assets/js/303.0d70cfc8.js"><link rel="prefetch" href="/assets/js/304.a7d6af53.js"><link rel="prefetch" href="/assets/js/305.435cd260.js"><link rel="prefetch" href="/assets/js/306.3ccd7022.js"><link rel="prefetch" href="/assets/js/307.fd76a538.js"><link rel="prefetch" href="/assets/js/308.6a91fb16.js"><link rel="prefetch" href="/assets/js/309.e5264ef5.js"><link rel="prefetch" href="/assets/js/31.e9c1132f.js"><link rel="prefetch" href="/assets/js/310.6f754dc4.js"><link rel="prefetch" href="/assets/js/311.b88d8581.js"><link rel="prefetch" href="/assets/js/312.5707f3f1.js"><link rel="prefetch" href="/assets/js/313.0d4f60bb.js"><link rel="prefetch" href="/assets/js/314.bee808dd.js"><link rel="prefetch" href="/assets/js/315.b37125e7.js"><link rel="prefetch" href="/assets/js/316.9f22fcdc.js"><link rel="prefetch" href="/assets/js/317.356708c0.js"><link rel="prefetch" href="/assets/js/318.6d2ae49f.js"><link rel="prefetch" href="/assets/js/319.aa3da19b.js"><link rel="prefetch" href="/assets/js/32.84edc9a9.js"><link rel="prefetch" href="/assets/js/320.22514d1e.js"><link rel="prefetch" href="/assets/js/33.c378c314.js"><link rel="prefetch" href="/assets/js/34.197e508f.js"><link rel="prefetch" href="/assets/js/35.0724a89a.js"><link rel="prefetch" href="/assets/js/36.bbe6639e.js"><link rel="prefetch" href="/assets/js/37.63b1fa5e.js"><link rel="prefetch" href="/assets/js/38.dd6c3f4b.js"><link rel="prefetch" href="/assets/js/39.6f90cb97.js"><link rel="prefetch" href="/assets/js/4.afea0107.js"><link rel="prefetch" href="/assets/js/40.fe52511f.js"><link rel="prefetch" href="/assets/js/41.b69b6b50.js"><link rel="prefetch" href="/assets/js/42.2ad9bef3.js"><link rel="prefetch" href="/assets/js/43.af324012.js"><link rel="prefetch" href="/assets/js/45.47677dc5.js"><link rel="prefetch" href="/assets/js/46.47c9584c.js"><link rel="prefetch" href="/assets/js/47.9c0729be.js"><link rel="prefetch" href="/assets/js/48.adf34306.js"><link rel="prefetch" href="/assets/js/49.de8744fb.js"><link rel="prefetch" href="/assets/js/5.2b1d7a9b.js"><link rel="prefetch" href="/assets/js/50.3b430030.js"><link rel="prefetch" href="/assets/js/51.2253888b.js"><link rel="prefetch" href="/assets/js/52.1cc1355f.js"><link rel="prefetch" href="/assets/js/53.2fb9de8b.js"><link rel="prefetch" href="/assets/js/54.2e627eb3.js"><link rel="prefetch" href="/assets/js/55.ef0e1284.js"><link rel="prefetch" href="/assets/js/56.e54bc64f.js"><link rel="prefetch" href="/assets/js/57.38d2b0c7.js"><link rel="prefetch" href="/assets/js/58.df501068.js"><link rel="prefetch" href="/assets/js/59.0c9788ad.js"><link rel="prefetch" href="/assets/js/6.b2e2c0cc.js"><link rel="prefetch" href="/assets/js/60.9f70e876.js"><link rel="prefetch" href="/assets/js/61.7682e130.js"><link rel="prefetch" href="/assets/js/62.5a2de9af.js"><link rel="prefetch" href="/assets/js/63.2a46b584.js"><link rel="prefetch" href="/assets/js/64.0f90f259.js"><link rel="prefetch" href="/assets/js/65.52438733.js"><link rel="prefetch" href="/assets/js/66.f8fc2226.js"><link rel="prefetch" href="/assets/js/67.2b7ec3fc.js"><link rel="prefetch" href="/assets/js/68.077917cb.js"><link rel="prefetch" href="/assets/js/69.25287e5b.js"><link rel="prefetch" href="/assets/js/7.c0f9bdfb.js"><link rel="prefetch" href="/assets/js/70.c7d86afc.js"><link rel="prefetch" href="/assets/js/71.91f87289.js"><link rel="prefetch" href="/assets/js/72.059e176c.js"><link rel="prefetch" href="/assets/js/73.301a2c50.js"><link rel="prefetch" href="/assets/js/74.1b3aff18.js"><link rel="prefetch" href="/assets/js/75.6a24c5c7.js"><link rel="prefetch" href="/assets/js/76.4a377869.js"><link rel="prefetch" href="/assets/js/77.3d2480bb.js"><link rel="prefetch" href="/assets/js/78.a9189906.js"><link rel="prefetch" href="/assets/js/79.2c7e2026.js"><link rel="prefetch" href="/assets/js/8.0309212a.js"><link rel="prefetch" href="/assets/js/80.4d6704f8.js"><link rel="prefetch" href="/assets/js/81.9723adca.js"><link rel="prefetch" href="/assets/js/82.4bada3c1.js"><link rel="prefetch" href="/assets/js/83.caf8ee53.js"><link rel="prefetch" href="/assets/js/84.75368b41.js"><link rel="prefetch" href="/assets/js/85.0d9a5b3d.js"><link rel="prefetch" href="/assets/js/86.c8e59a75.js"><link rel="prefetch" href="/assets/js/87.af1d5a02.js"><link rel="prefetch" href="/assets/js/88.9861a5da.js"><link rel="prefetch" href="/assets/js/89.b140c672.js"><link rel="prefetch" href="/assets/js/9.f0304e47.js"><link rel="prefetch" href="/assets/js/90.d93f0f4a.js"><link rel="prefetch" href="/assets/js/91.86dc810c.js"><link rel="prefetch" href="/assets/js/92.104db675.js"><link rel="prefetch" href="/assets/js/93.6152fb48.js"><link rel="prefetch" href="/assets/js/94.87f3ecdc.js"><link rel="prefetch" href="/assets/js/95.4f371d6d.js"><link rel="prefetch" href="/assets/js/96.8360b9e7.js"><link rel="prefetch" href="/assets/js/97.78ab9c55.js"><link rel="prefetch" href="/assets/js/98.b09df9e9.js"><link rel="prefetch" href="/assets/js/99.3692c9a7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2d4b740c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">YuweiYin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></li><li class="dropdown-item"><!----> <a href="/article/physics/" class="nav-link">
  物理宇宙
</a></li><li class="dropdown-item"><!----> <a href="/article/info_technology/" class="nav-link router-link-active">
  信息技术
</a></li><li class="dropdown-item"><!----> <a href="/article/essay/" class="nav-link">
  见闻随笔
</a></li><li class="dropdown-item"><!----> <a href="/article/other/" class="nav-link">
  其它系列
</a></li><li class="dropdown-item"><!----> <a href="/article/reprint/" class="nav-link">
  转载文章
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/home/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="文章" class="dropdown-title"><span class="title">文章</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/mathematics/" class="nav-link">
  数学哲学
</a></li><li class="dropdown-item"><!----> <a href="/article/physics/" class="nav-link">
  物理宇宙
</a></li><li class="dropdown-item"><!----> <a href="/article/info_technology/" class="nav-link router-link-active">
  信息技术
</a></li><li class="dropdown-item"><!----> <a href="/article/essay/" class="nav-link">
  见闻随笔
</a></li><li class="dropdown-item"><!----> <a href="/article/other/" class="nav-link">
  其它系列
</a></li><li class="dropdown-item"><!----> <a href="/article/reprint/" class="nav-link">
  转载文章
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.github.com/YuweiYin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/article/info_technology/" class="sidebar-link">Information Technology</a></li><li><a href="/article/info_technology/computer_science/" class="sidebar-link">Computer Science</a></li><li><a href="/article/info_technology/algorithm/" class="sidebar-link">Algorithm</a></li><li><a href="/article/info_technology/artificial_intelligence/" class="sidebar-link">Artificial Intelligence</a></li><li><a href="/article/info_technology/web_crawler/" class="sidebar-link">Web Crawler</a></li><li><a href="/article/info_technology/web_frontend/" class="sidebar-link">Web Frontend</a></li><li><a href="/article/info_technology/web_backend/" class="sidebar-link">Web Backend</a></li><li><a href="/article/info_technology/web_security/" class="sidebar-link">Web Security</a></li><li><a href="/article/info_technology/system_management/" class="sidebar-link">System Management</a></li><li><a href="/article/info_technology/paper_notes/" class="sidebar-link">Paper Notes</a></li><li><a href="/article/info_technology/other/" class="sidebar-link">Other</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="algorithm-graph-theory-ford-fulkerson"><a href="#algorithm-graph-theory-ford-fulkerson" class="header-anchor">#</a> Algorithm - Graph Theory - Ford-Fulkerson</h1> <p>Create Date: 2020.06.03</p> <p>Last Update Date: 2020.06.03</p> <p>By <a href="https://yuweiyin.github.io/" target="_blank" rel="noopener noreferrer">YuweiYin<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>最大流 Max-Flow</p> <p>Ford-Fulkerson 方法</p> <h3 id="流网络"><a href="#流网络" class="header-anchor">#</a> 流网络</h3> <p>流网络 G = (V, E) 是一个有向图，图中每条边 (u, v) \in E 有一个<strong>非负</strong>的<strong>容量值</strong> c(u, v) &gt;= 0。而且，如果边集合 E 包含一条边 (u, v)，则图中不存在反方向的边 (v, u)。如果 (u, v) \notin E，为方便起见，定义 c(u, v) = 0。并且在图中不允许有自循环/自圈 (u, u)。</p> <p>另外，在流网络的所有结点中，有两个特殊的结点：<strong>源结点</strong> s (source) 和<strong>汇点</strong> t (terminal)。源结点入度为 0、汇点出度为 0。为方便起见，假定 V 中每个结点 v 都位于某条从 s 到 v 的路径上，即有 <code>s ~&gt; v ~&gt; t</code> 路径。</p> <p>因此，流网络图是<strong>弱连通</strong>的。并且由于除源结点 s 外的每个结点都至少有一条进入的边，有 <code>|E| &gt;= |V| - 1</code>。</p> <ul><li>流网络的性质主要如下：
<ul><li>流网络 G = (V, E) 是一个弱连通的有向图</li> <li>所有边的权重为非负值，且每条边的权重值有上界 c(u, v)</li> <li>任意两个结点 u, v \in V，不能同时存在边 (u, v) 和边 (v, u)</li> <li>如果某边 (u, v) 不存在，定义其权重值 c(u, v) = 0</li> <li>图中没有自循环 (u, u)</li> <li>通常来说，源结点 s 的入度为 0，汇点 t 的出度为 0</li> <li>每个结点 v 都处于从 s 到 t 的某条路径上。即：从起点 s 发出的流量可以流经 v 到达终点 t</li></ul></li></ul> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/max-flow-1.png" alt="max-flow-1"></p> <p>这里给出流的形式化定义。设 G = (V, E) 是一个<strong>流网络</strong>，其<strong>容量函数</strong>为 c。设 s 为网络的<strong>源结点</strong>，t 为<strong>汇点</strong>。G 中的<strong>流</strong>是一个<strong>实值函数</strong> f: VxV -&gt; R，满足如下两条性质：</p> <ol><li><strong>容量限制</strong>：（“流量有限额”）对于所有的结点 u, v \in V，要求 0 &lt;= f(u, v) &lt;= c(u, v)</li> <li><strong>流量守恒</strong>：（“流入等于流出”）对于所有的结点 u \in V - {s, t}，要求 $ \sum_{v \in V} f(v, u) = \sum_{v \in V} f(u, v) $
<ul><li>当 (u, v) \notin E 时，从结点 u 到结点 v 之间没有流，因此 f(u, v) == 0</li></ul></li></ol> <p>称非负数值 f(u, v) 为从结点 u 到结点 v 的流。一个流 f 的值 <code>|f|</code> 定义如下：</p> <p>$$ |f| = \sum_{v \in V} f(s, v) = \sum_{v \in V} f(v, s) $$</p> <p>即，流 f 的值时从源结点流出的总流量 减去 流入源结点的总流量。这里符号 <code>|·|</code> 仅用作表达流的值，而不是数的绝对值或者集合的基数值。</p> <p>通常来说，一个流网络不会有任何进入源结点的边，即源结点的入度为 0，故求和项 $ \sum_{v \in V} f(v, s) $ 的值将是 0。但对于有的网络而言（比如<strong>残存网络</strong>），流入源结点的流量十分重要。</p> <p>在<strong>最大流问题</strong>中，给定一个<strong>流网络</strong> G、一个<strong>源结点</strong> s、一个<strong>汇点</strong> t，目标是找到值最大的一个<strong>流</strong>。</p> <h2 id="ford-fulkerson-方法"><a href="#ford-fulkerson-方法" class="header-anchor">#</a> Ford-Fulkerson 方法</h2> <p>常用于解决最大流问题的 Ford-Fulkerson 方法，之所以被称为“方法”而不是“算法”，是因为它主要提供的是一种通用的解决思路，包含了几种运行时间不同的具体算法实现。</p> <p>Ford-Fulkerson 方法依赖于三种重要思想：<strong>残存网络</strong>、<strong>增广路径</strong> 和 <strong>切割</strong>。这三种思想与许多流算法和问题有关，它们是<strong>最大流最小切割定理</strong>（《CLRS》定理 26.6）的精髓。该定理以<strong>流网络的切割</strong>来表述最大流的值。</p> <p>Ford-Fulkerson 方法<strong>循环增加流的值</strong>：</p> <ul><li>在开始的时候，对于所有的结点 u, v \in V，f(u, v) = 0，给出的初始流量为 0。</li> <li>每一次迭代中，将图 G 的流值进行增加，增加的方法就是在一个关联的“残存网络” Gf 中寻找一条“增广路径”
<ul><li>一旦知道图 Gf 中的一条增广路径的边，就可以很容易地辨别出 G 中的一些具体的边，可以对这些边上的流量进行修改，从而增加流的值。</li></ul></li> <li>虽然 Ford-Fulkerson 方法的每次迭代都增加流（整体）的值，但是对于图 G 的一条特定边来说，其流量可能增加，也可能减少。
<ul><li>而且，对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。</li></ul></li> <li>重复对流进行这一过程，知道残存网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法将获得一个最大流。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FORD_FULKERSON_METHOD(G, s, t)
1  initialize flow f to 0
2  while there exists an augmenting path p in the residual network Gf
3      augment flow f along p
4  return f
</code></pre></div><p>为了实现和分析 Ford-Fulkerson 方法，需要引入如下几个新的概念。</p> <h3 id="残存网络"><a href="#残存网络" class="header-anchor">#</a> 残存网络</h3> <p>从直观上看，给定流网络 G 和流量 f，残存网络 Gf 由那些 <strong>仍有空间对流量进行调整的边</strong> 构成。流网络的一条边<strong>可以允许的额外流量</strong>等于 该边的容量 减去 该边上的流量。如果该差值为正，则将该条边置于残存网络图 Gf 中，并将其<strong>残存容量</strong>设置为 cf(u, v) = c(u, v) - f(u, v)。对于图 G 中的边来说，只有能够允许额外流量的边才能被加入到图 Gf 中。如果边 (u, v) 的流量 f(u, v) 等于其容量 c(u, v)，则其 cf(u, v) == 0，该条边将不属于图 Gf。（注意，根据<strong>容量限制</strong>原则，残存容量 cf(u, v) 不可能为负值）</p> <p>残存网络 Gf 中可能包含图 G 中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减，为了表示对一个正流量 f(u, v) 的缩减，将反向边 (v, u) 加入到图 Gf 中，并将其残存容量设置为 cf(v, u) = f(u, v)。即 一条边所能允许的反向流量最多将其正向流量抵消。残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。</p> <p>而将流量从同一条边发送回去等同于<strong>缩减</strong>该条边的流量，这种操作在许多算法中都是必须的。</p> <p>更形式化地说，假定有一个流网络 G = (V, E)，其源结点为 s，汇点为 t。设 f 为图 G 中的一个流，考虑结点对 u, v \in V，定义<strong>残存容量</strong> cf(u, v) 如下：</p> <ul><li>若 (u, v) \in E，则 cf(u, v) = c(u, v) - f(u, v)</li> <li>若 (v, u) \in E，则 cf(u, v) = f(v, u)</li> <li>若是其它情况，则 cf(u, v) = 0</li></ul> <p>由于已经假定在图 G 中边 (u, v) 和边 (v, u) 不能同时出现，故上述三种情况有且仅有一种会发生。</p> <p>举例来说，如果容量限制 c(u, v) = 16，并且当前流量 f(u, v) = 11，则对 f(u, v) 可以增加的量最多为 cf(u, v) = 5，再多就超过边 (u, v) 的容量限制了。同时，允许算法从结点 v 向结点 u 最多返回 11 单位的流量（即全部当前流量），因此残存网络中反向边 cf(v, u) = 11。</p> <hr> <p>给定一个流网络 G = (V, E) 和一个流 f，则由 f 所诱导的图 G 的<strong>残存网络</strong>为 Gf = (V, Ef)，其中边集 Ef = {(u, v) \in V x V: cf(u, v) &gt; 0}</p> <p>即 残存网络的每条边（称为<strong>残存边</strong>），必须允许大于 0 的流量通过。下面图 26-4 中的 (a) 图是前面图 26-1 (b) 的流网络 G 和流量 f 的重新绘制，图 26-4 (b) 描述的是对应的残存网络 Gf。Ef 中的边要么是 E 中原有的边，要么是其反向边，因此有 <code>|Ef| &lt;= 2|E|</code></p> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-1.png" alt="ford-fulkerson-1"></p> <p>残存网络 Gf 类似于一个容量为 cf 的流网络，但是不满足前面对流网络的定义，因为在 Gf 中可以有反平行边。除了反平行边这个区别外，流网络的其他性质 Gf 都有保留，因此可以在残存网络中定义一个流，它满足流的两条性质：<strong>容量限制</strong> 和 <strong>流量守恒</strong>。该流针对的是残存网络 Gf 中的残存容量 cf。</p> <p>残存网络 Gf 中的一个流指出的是一条<strong>路线图</strong>：如何在原来的流网络 G 中增加流。如果 f 是 G 的一个流，f' 是对应的残存网络 Gf 中的一个流，定义 f↑f' 为流 f' 对流 f 的<strong>递增</strong> (augmentation)，它是一个从 V x V 到 R 的函数，具体定义如下：</p> <ul><li>若 (u, v) \in E，则 (f↑f')(u, v) = f(u, v) + f'(u, v) - f'(v, u)</li> <li>其它情况，则 (f↑f')(u, v) = 0</li></ul> <p>该定义背后的直观解释遵循残存网络的定义。因为在残存网络中<strong>将流量发送到反向边</strong> 等同于 在原来的网络中<strong>缩减流量</strong>，所以将边 (u, v) 的流量增加 f'(u, v)，但减少 f'(v, u)。在残存网络中将流量推送回去 也被称为<strong>抵消操作</strong> (cancellation)。</p> <p>举例来说，如果某公司将 5 箱货物从城市 u 发送到城市 v，同时将 2 箱同样的货物从城市 v 发送到城市 u，那么可以(从整体上来说)等价于 将 3 箱货物从城市 u 发送到城市 v。这类<strong>抵消操作</strong>对于任何<strong>最大流算法</strong>来说都是<strong>非常关键</strong>的。</p> <hr> <p>《CLRS》<strong>引理 26.1</strong>：设 G = (V, E) 为一个流网络，源结点为 s，汇点为 t，设 f 为 G 中的一个流。设 Gf 为由流 f 所诱导的 G 的残存网络，设 f' 为 Gf 中的一个流。那么函数 (f↑f') 是 G 的一个流，其值为 <code>|f↑f'| = |f| + |f'|</code>。</p> <p>对引理 26.1 的证明主要有以下四点（具体证明参考《CLRS》Chapter 26.2）：</p> <ol><li>流量非负：(f↑f')(u, v) &gt;= 0</li> <li>容量限制：(f↑f')(u, v) &lt;= c(u, v)</li> <li>流量守恒：对于所有的结点 u \in V - {s, t}，$ \sum_{v \in V} (f↑f')(u, v) = \sum_{v \in V} (f↑f')(v, u) $</li> <li>计算 (f↑f') 的值，确保 <code>|f↑f'| = |f| + |f'|</code></li></ol> <h3 id="增广路径"><a href="#增广路径" class="header-anchor">#</a> 增广路径</h3> <p>给定流网络 G = (V, E) 和流 f，<strong>增广路径</strong> p 是残存网络 Gf 中一条从源结点 s 到汇点 t 的<strong>简单路径</strong>。根据残存网络的定义，对于一条增广路径上的边 (u, v)，可以增加其流量的幅度 最大为 cf(u, v)，再多会违反容量限制。</p> <p>例如前面 图 26-4 (b) 中阴影覆盖的路径是一条增广路径。如果将图中的残存网络 Gf 看作一个流网络，那么可以对这条路径上的<strong>每条边的流量增加</strong> 4 个单位，而不会违反容量限制，因为该条路径上<strong>最小的残存容量</strong>是 cf(v2, v3) = 4。</p> <p>称在一条增广路径 p 上能够为每条边增加的流量的最大值 为路径 p 的<strong>残存容量</strong>，该容量的表达式为：cf(p) = min{cf(u, v): (u, v) 属于路径 p}。下面的引理更加精确地阐述了此论断：</p> <p>《CLRS》<strong>引理 26.2</strong>：设 G = (V, E) 为一个流网络，设 f 为图 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。定义一个函数 fp: V x V -&gt; R 如下：</p> <ul><li>若 (u, v) 在 p 上，则 fp(u, v) = cf(p)</li> <li>若是其它情况，则 fp(u, v) = 0</li></ul> <p>则 fp 是残存网络 Gf 中的一个流，其值为 <code>|fp| = cf(p) &gt; 0</code></p> <hr> <p>下面的推论证明，如果将流 f 增加 fp 的量，则将获得 G 的另一个流，该流的值更加接近最大值。图 26-4 (c) 描述的是对图 26-4 (a) 的流 f 增加图 26-4 (b) 所示的 fp 的量 所获得的结果，而图 26-4 (d) 描述的则是残存网络 Gf。</p> <p>《CLRS》<strong>推论 26.3</strong>：设 G = (V, E) 为一个流网络，设 f 为 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。设 fp 由引理 26.2 所定义，假定将 f 增加 fp 的量，则函数 <code>|f↑fp| = |f| + |fp| &gt; |f|</code>。</p> <h3 id="流网络和切割"><a href="#流网络和切割" class="header-anchor">#</a> 流网络和切割</h3> <p>Ford-Fulkerson 方法的核心就是<strong>沿着增广路径重复增加路径上的流量</strong>，直到找到一个最大流为止。稍后证明的<strong>最大流最小切割定理</strong>表明：一个流是最大流 当且仅当 其残存网络不包含任何增广路径。</p> <p>流网络 G = (V, E) 中的一个切割 (S, T) 将结点集合 V 划分为 S 和 T=V-S 两个不相交集合，且使得源结点 s \in S、汇点 t \in T。这类似于最小生成树 MST 中的切割，不过这里是对有向图的切割，而非无向图。</p> <p>若 f 是一个流，则定义横跨切割 (S, T) 的<strong>净流量</strong> f(S, T) 如下：</p> <p>$$ f(S, T) = \sum_{u \in S} \sum_{v \in T} f(u, v) - \sum_{u \in S} \sum_{v \in T} f(v, u) $$</p> <p>切割 (S, T) 的<strong>容量</strong>是：</p> <p>$$ c(S, T) = \sum_{u \in S} \sum_{v \in T} c(u, v) $$</p> <p>一个网络的<strong>最小切割</strong>是整个网络中<strong>容量最小的切割</strong>。</p> <hr> <p>流的定义和切割容量的定义之间不存在对称性，但这种不对称性是有意而为，并且很重要。对于容量来说，只计算从集合 S 发出、进入集合 T 的边的容量，而忽略反方向边上的容量。对于流，考虑的则是从 S 到 T 的总流量 减去 (反方向)从 T 到 S 的流量。</p> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-2.png" alt="ford-fulkerson-2"></p> <p>下面的引理将证明，对于给定流 f，横跨任何切割的净流量都相同，都等于 <code>|f|</code>，即流的值。</p> <p>《CLRS》<strong>引理 26.4</strong>：设 f 为流网络 G 的一个流，该流网络的源结点为 s，汇点为 t，设 (S, T) 为流网络 G 的<strong>任意切割</strong>，则横跨切割 (S, T) 的净流量为 f(S, T) = <code>|f|</code>。</p> <p>引理 26.4 的如下推论 说明如何使用切割容量来限定一个流的值。</p> <p>《CLRS》<strong>推论 26.5</strong>：流网络 G 中任意流 f 的值不能超过 G 的任意切割的容量。</p> <p>此推论给出的一个直接结论是：<strong>一个流网络中最大流的值不能超过该网络最小切割的容量</strong>。这就是下面要来陈述和证明的非常重要的最大流最小切割定理。该定理表明一个最大流的值 事实上等于一个最小切割的容量。</p> <p>《CLRS》<strong>定理 26.6</strong>（<strong>最大流最小切割定理</strong>）：设 f 为流网络 G = (V, E) 中的一个流，该流网络的源结点为 s，汇点为 t，则下面的条件是等价的：</p> <ol><li>f 是 G 的一个最大流。</li> <li>残存网络 Gf 不包含任何增广路径。
<ul><li>增广路径：残存网络 Gf 中一条从源结点 s 到汇点 t 的简单路径。</li></ul></li> <li>最大流的值 <code>|f|</code> = c(S, T)，其中 (S, T) 是流网络 G 的某个切割。</li></ol> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-3.png" alt="ford-fulkerson-3"></p> <h2 id="基本的-ford-fulkerson-算法"><a href="#基本的-ford-fulkerson-算法" class="header-anchor">#</a> 基本的 Ford-Fulkerson 算法</h2> <p>在 Ford-Fulkerson 方法的每次迭代中，寻找某条增广路径 p，然后使用 p 来对流 f 进行修改（增加）。正如引理 26.2 和推论 26.3 所示，以 f↑fp 来替换 f，从而获得一个值为 <code>|f| + |fp|</code> 的更大的流。</p> <p>在如下算法实现中，通过为每条边 (u, v) \in E 更新流属性 (u, v).f 来计算流网络 G = (V, E) 中的最大流。如果边 (u, v) \notin E，则设置 (u, v).f = 0。另外，假设流网络各边的容量 c(u, v) 都已经给出，如果边 (u, v) \notin E，则设置 c(u, v) = 0。根据如下式子来计算残存容量 cf(u, v)。代码中的表达式 cf(p) 只是一个临时变量，用于存放路径 p 的残存容量。</p> <ul><li>若 (u, v) \in E，则 cf(u, v) = c(u, v) - f(u, v)</li> <li>若 (v, u) \in E，则 cf(u, v) = f(v, u)</li> <li>若是其它情况，则 cf(u, v) = 0</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FORD_FULKERSON(G, s, t)
1  for each edge(u, v) \in G.E
2      (u, v).f = 0
3  while there exists a path p from s to t in the residual network Gf
4      cf(p) = min { cf(u, v): (u, v) is in path p }
5      for each edge(u, v) in p
6          if (u, v) \in E
7              (u, v).f = (u, v).f + cf(p)
8          else
9              (v, u).f = (v, u).f - cf(p)
</code></pre></div><p><code>FORD_FULKERSON(G, s, t)</code> 算法是对 <code>FORD_FULKERSON_METHOD(G, s, t)</code> 方法的简单扩展。算法流程描述如下：</p> <ol><li>在 1～2 行，将流 f 初始化为 0。</li> <li>在 3～9 行的 while 循环中，重复在残存网络 Gf 中寻找一条增广路径 p，然后使用残存容量 cf(p) 来对路径 p 上的流 f 进行增加。路径 p 上的一条边要么是原来网络中的一条边，要么是原来网络中的边 的反向边。
<ul><li>在 4 行，找出路径 p 中的最小残存容量 cf(u, v)。</li> <li>在 5～9 行的 for 循环中，对路径上 p 的每条边 (u, v) 的流量进行更新。</li> <li>在 6～7 行，如果残存边 (u, v) 是原来流网络中的一条边，则增加其流量 (u, v).f</li> <li>在 8～9 行，如果残存边 (u, v) 不是原来流网络中的一条边，则减少其反向边 (v, u) 流量 (v, u).f</li></ul></li> <li>最后，当 while 循环结束时，不再有增广路径。根据最大流最小切割定理，此时流 f 就是最大流。</li></ol> <h3 id="ford-fulkerson-算法的分析"><a href="#ford-fulkerson-算法的分析" class="header-anchor">#</a> Ford-Fulkerson 算法的分析</h3> <p>Ford-Fulkerson 算法的运行时间取决于算法第 3 行是如何寻找增广路径 p 的。如果使用广度优先搜索 BFS 来寻找增广路径，算法的运行时间是多项式数量级。如果选择不好，<code>FORD_FULKERSON</code> <strong>算法</strong>可能不会终止：流的值会随着后续的递增 (augmentation) 而增加，但它却不一定收敛于最大的流值。</p> <p>另外，只有当变得容量为<strong>无理数</strong>时，<code>FORD_FULKERSON_METHOD</code> <strong>方法</strong>才可能无法终止。下面均假定所选择的任意增广路径 p 和所有的容量 c 都是整数值。在实际情况中，最大流问题中的容量常常都是整数。如果容量为有理数，则可以通过乘以某个系数（或者采用近似值）来将其转换为整数。</p> <hr> <p>如果 f* 表示转换后网络中的一个最大流，则在 <code>FORD_FULKERSON</code> 算法的一个直接实现中，执行第 3～9 行的 while 循环的次数最多为 <code>|f*|</code> 次，因为流量值在每次迭代中至少增加一个单位。</p> <p>如果用于实现流网络 G = (V, E) 的数据结构是合理的，并且寻找一条增广路径 p 的算法时间是线性的（比如 DFS 和 BFS），则整个 while 循环的执行将非常高效。假设有一个与有向图 G' = (V, E') 相对应的数据结构，这里 E' = {(u, v): (u, v) \in E 或者 (v, u) \in E}。网络 G 中的边也是网络 G' 中的边，因此在这一数据结构中，保持其容量和流就非常简单了。给定网络 G 的一个流 f，残存网络 Gf 中的边由网络 G' 中所有满足条件 cf(u, v) &gt; 0 的边 (u, v) 所构成，其中 cf 遵守前述残存容量的性质。</p> <p>因此，如果使用深度优先搜索 DFS 或广度优先搜索 BFS，在一个残存网络中找到一条路径的时间应是 <code>O(|V| + |E'|) = O(|E|)</code>。而 while 循环的每一遍执行所需的时间因此为 <code>O(|E|)</code>，这与算法第 1～2 行的初始化成本一样，从而整个 <code>FORD_FULKERSON</code> 算法的运行时间为 <code>O(|E|·|f*|)</code>。</p> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-4.png" alt="ford-fulkerson-4"></p> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-5.png" alt="ford-fulkerson-5"></p> <p>当容量都是整数值且最优的流量值 <code>|f*|</code> 较小时，<code>FORD_FULKERSON</code> 算法的运行时间相等不错。但当最优流量值 <code>|f*|</code> 取值较大时，可能会效率很慢，如图 26-7 示例。</p> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-6.png" alt="ford-fulkerson-6"></p> <h2 id="edmonds-karp-算法"><a href="#edmonds-karp-算法" class="header-anchor">#</a> Edmonds-Karp 算法</h2> <p>可以通过在 <code>FORD_FULKERSON</code> 算法第 3 行寻找增广路径 p 的操作中 使用广度优先搜索 BFS 来改善算法的效率。即 在残存网络中选择的增广路径是一条从源结点 s 到汇点 t 的(无权重)最短路径，BFS 时每条边的权重均为单位距离。称如此实现的 Ford-Fulkerson 方法为 Edmonds-Karp 算法，其运行时间为 <code>O(|V|·|E|^2)</code>，这就与最优流量值 <code>|f*|</code> 的取值大小无关了。</p> <p>对 Edmonds-Karp 算法的分析取决于残存网络 Gf 中结点之间的距离。下面的引理使用符号 df(u, v) 来表示残存网络 Gf 中从结点 u 到结点 v 的(无权重)最短路径距离，其中每条边的权重为单位距离。</p> <p>《CLRS》<strong>引理 26.7</strong>：如果 Edmonds-Karp 算法运行在流网络 G = (V, E) 上，该网络的源结点为 s、汇点为 t，则对于所有的结点 v \in V-{s, t}，残存网络 Gf 中<strong>最短路径距离</strong> df(u, v) 随着每次流量的递增 而<strong>单调递增</strong>。</p> <p>下面的定理给出了 Edmonds-Karp 算法的迭代次数的上界。</p> <p>《CLRS》<strong>定理 26.8</strong>：如果 Edmonds-Karp 算法运行在源结点为 s、汇点为 t 的流网络 G = (V, E) 上，则该算法所执行的流量递增操作的总次数为 <code>O(|V|·|E|)</code>。</p> <p><img src="/img/info_technology/algorithm/graph_theory/max_flow/ford-fulkerson-7.png" alt="ford-fulkerson-7"></p> <p>由于在用广度优先搜索 BFS 寻找增广路径时，<code>FORD_FULKERSON(G, s, t)</code> 中的每次迭代可以在 <code>O(|E|)</code> 时间内实现，所以 Edmonds-Karp 算法的总运行时间为 <code>O(|V|·|E|^2)</code>。</p> <p>而<strong>推送-重贴标签</strong>算法能够取得更好的界，可以达到 <code>O(|V|^2·|E|)</code> 甚至 <code>O(|V|^3)</code>。</p> <h2 id="python-代码范例"><a href="#python-代码范例" class="header-anchor">#</a> Python 代码范例</h2> <p>Python 环境：Python 3.7</p> <h3 id="ford-fulkerson-最大流算法"><a href="#ford-fulkerson-最大流算法" class="header-anchor">#</a> Ford-Fulkerson 最大流算法</h3> <div class="language-python extra-class"><pre class="language-python"><code><span class="token comment">#!/usr/bin/env python</span>
<span class="token comment"># -*- coding:utf-8 -*-</span>
<span class="token triple-quoted-string string">&quot;&quot;&quot;=================================================
@Project : algorithm/graph_theory/max_flow
@File    : ford-fulkerson.py
@Author  : YuweiYin
@Date    : 2020-06-03
==================================================&quot;&quot;&quot;</span>

<span class="token keyword">import</span> sys
<span class="token keyword">import</span> time
<span class="token keyword">import</span> queue

<span class="token triple-quoted-string string">&quot;&quot;&quot;
最大流 Max-Flow

- Ford-Fulkerson 方法
    - Ford-Fulkerson 算法
    - Edmonds-Karp 算法

参考资料：
Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26
&quot;&quot;&quot;</span>


<span class="token comment"># 边结构体，表达边的信息，可随任务自定义 (增添其它值元素 val 对象)</span>
<span class="token keyword">class</span> <span class="token class-name">Edge</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> from_v<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> to_v<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> weight<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> is_directed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> capacity<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>from_v <span class="token operator">=</span> from_v  <span class="token comment"># 边的起始顶点(关键字/序号)</span>
        self<span class="token punctuation">.</span>to_v <span class="token operator">=</span> to_v      <span class="token comment"># 边的终止顶点(关键字/序号)</span>
        self<span class="token punctuation">.</span>weight <span class="token operator">=</span> weight  <span class="token comment"># (用于最短路)边的权重值 (默认值为 1，如果全部边的权重都相同，那图 G 就是无权图)</span>
        self<span class="token punctuation">.</span>is_directed <span class="token operator">=</span> is_directed  <span class="token comment"># True 则表明此边是有向边，False 为无向边</span>
        <span class="token comment"># 对无向边而言，起始顶点和终止顶点可以互换</span>
        <span class="token triple-quoted-string string">'''下面是用于 Max-Flow 的属性'''</span>
        self<span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity  <span class="token comment"># 此边的最大容量</span>
        self<span class="token punctuation">.</span>flow <span class="token operator">=</span> <span class="token number">0</span>             <span class="token comment"># 此边最大流的流量，初始为 0，取值范围 0 &lt;= flow &lt;= capacity</span>
        <span class="token comment"># 运行过程中的边流量存储于矩阵中，这里的 self.flow 仅存储最终的本条边的流量</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>from_v<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'-&gt;'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>to_v<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\t capacity:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>capacity<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\t flow:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>flow<span class="token punctuation">)</span> <span class="token operator">+</span> \
               <span class="token string">'\t weight:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>weight<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\t is_directed:'</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>is_directed<span class="token punctuation">)</span>


<span class="token comment"># 用于邻接矩阵的顶点结构体 (比 VertexList 简单)</span>
<span class="token comment"># 这里是用散列表 (而不是用链表) 来表达某顶点的所有邻接顶点</span>
<span class="token keyword">class</span> <span class="token class-name">VertexMatrix</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造方法</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> distance<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> p<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>key <span class="token operator">=</span> key            <span class="token comment"># 本顶点的关键字 key (通常为顶点序号、唯一标志符)</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val            <span class="token comment"># 本顶点的值元素 val (可自定义为任意对象，为结点附带的信息)</span>
        <span class="token triple-quoted-string string">'''下面是用于 BFS 的属性'''</span>
        self<span class="token punctuation">.</span>color <span class="token operator">=</span> color        <span class="token comment"># False 为&quot;白色&quot;，表示未被发现；True 为&quot;黑色&quot;，表示已经探索结束</span>
        self<span class="token punctuation">.</span>distance <span class="token operator">=</span> distance  <span class="token comment"># 此结点距离源结点的距离 (最短简单路径的边数)</span>
        self<span class="token punctuation">.</span>p <span class="token operator">=</span> p                <span class="token comment"># 此结点的前驱结点/广度优先搜索树的父结点</span>

    <span class="token comment"># 类序列化输出方法</span>
    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'Vertex key: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>key<span class="token punctuation">)</span>


<span class="token comment"># (带边权的)邻接矩阵的图结构，通常适合稠密图</span>
<span class="token comment"># 输入顶点结构体列表、边结构体列表</span>
<span class="token keyword">class</span> <span class="token class-name">AdjacencyMatrix</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> vertices<span class="token punctuation">,</span> edges<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>vertices<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>

        <span class="token comment"># self.inf = 0x3f3f3f3f        # 初始各边的权重值均为 inf 无穷</span>
        self<span class="token punctuation">.</span>max_flow <span class="token operator">=</span> <span class="token number">0</span>            <span class="token comment"># 经最大流算法后计算出的最大流值</span>
        self<span class="token punctuation">.</span>edges <span class="token operator">=</span> edges           <span class="token comment"># 存储输入的边列表</span>
        self<span class="token punctuation">.</span>key2e_index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment"># 由(起始,终止)顶点的关键字/唯一标志符映射到边数组下标</span>

        self<span class="token punctuation">.</span>vertices <span class="token operator">=</span> vertices     <span class="token comment"># 存储输入的顶点列表 (可以从下标映射到顶点)</span>
        self<span class="token punctuation">.</span>v2index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token comment"># 由顶点映射到其下标 (既是邻接矩阵的行/列下标，也是 vertices 列表的下标)</span>
        self<span class="token punctuation">.</span>key2v_index <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment"># 由顶点的关键字/唯一标志符映射到顶点数组下标</span>
        <span class="token keyword">for</span> index<span class="token punctuation">,</span> vertex <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>v2index<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span> <span class="token operator">=</span> index
            self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>vertex<span class="token punctuation">.</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> index

        <span class="token comment"># 构建邻接矩阵(二维方阵)，adj[x][y] 的值为边 (x, y) 的当前流量，而不是边权重</span>
        <span class="token comment"># 这里用于残存网络 Gf，可以有反平行边。如果 adj[x][y] 为 0 表示没有此边，在 Gf 上运行 BFS</span>
        v_num <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>vertices<span class="token punctuation">)</span>  <span class="token comment"># 顶点数目</span>
        self<span class="token punctuation">.</span>adj_m <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> v_num <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>v_num<span class="token punctuation">)</span><span class="token punctuation">]</span>

        <span class="token comment"># 若 edges 合法，则进行边初始化处理</span>
        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> index<span class="token punctuation">,</span> edge <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 断言最大流算法里都是有向边</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span> <span class="token keyword">and</span> edge<span class="token punctuation">.</span>is_directed
                from_v <span class="token operator">=</span> edge<span class="token punctuation">.</span>from_v      <span class="token comment"># 边起点的关键字 key</span>
                to_v <span class="token operator">=</span> edge<span class="token punctuation">.</span>to_v          <span class="token comment"># 边终点的关键字 key</span>
                capacity <span class="token operator">=</span> edge<span class="token punctuation">.</span>capacity  <span class="token comment"># 边的容量</span>
                self<span class="token punctuation">.</span>key2e_index<span class="token punctuation">[</span><span class="token punctuation">(</span>from_v<span class="token punctuation">,</span> to_v<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> index
                <span class="token keyword">if</span> from_v <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_v <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
                    <span class="token comment"># 将顶点关键字 key 转为下标 index，然后初始化 adj[from][to] 为边的最大容量</span>
                    from_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_v<span class="token punctuation">]</span>
                    to_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_v<span class="token punctuation">]</span>
                    <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> from_index <span class="token operator">&lt;</span> v_num <span class="token keyword">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> to_index <span class="token operator">&lt;</span> v_num
                    self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span> <span class="token operator">=</span> capacity

    <span class="token comment"># 判断 key 号为 _key 的顶点是否位于顶点列表中</span>
    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> _key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> _key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index

    <span class="token comment"># 获取图中 key 号为 _key 的顶点，如果没有此顶点则返回 None</span>
    <span class="token keyword">def</span> <span class="token function">get_vertex</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> _key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> _key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>_key<span class="token punctuation">]</span>
            <span class="token keyword">return</span> self<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>

    <span class="token comment"># 邻接矩阵 - 图转置</span>
    <span class="token keyword">def</span> <span class="token function">graph_transposition</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> edge <span class="token keyword">in</span> self<span class="token punctuation">.</span>edges<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span>
            <span class="token comment"># 其实如果是无向边，无需处理，但这里还是转了</span>
            <span class="token comment"># 先获取 key</span>
            from_key <span class="token operator">=</span> edge<span class="token punctuation">.</span>from_v
            to_key <span class="token operator">=</span> edge<span class="token punctuation">.</span>to_v
            <span class="token comment"># 交换 key</span>
            edge<span class="token punctuation">.</span>from_v <span class="token operator">=</span> to_key
            edge<span class="token punctuation">.</span>to_v <span class="token operator">=</span> from_key
            <span class="token comment"># 把 key 转成 index</span>
            <span class="token keyword">assert</span> from_key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_key <span class="token keyword">in</span> self<span class="token punctuation">.</span>key2v_index
            from_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_key<span class="token punctuation">]</span>
            to_index <span class="token operator">=</span> self<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_key<span class="token punctuation">]</span>
            <span class="token comment"># 修改邻接矩阵</span>
            temp <span class="token operator">=</span> self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">[</span>from_index<span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">[</span>from_index<span class="token punctuation">]</span> <span class="token operator">=</span> temp

    <span class="token comment"># 输出邻接矩阵</span>
    <span class="token keyword">def</span> <span class="token function">print_matrix_info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>adj_m<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> row <span class="token keyword">in</span> self<span class="token punctuation">.</span>adj_m<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>


<span class="token comment"># 广度优先搜索 (Breadth First Search, BFS)</span>
<span class="token keyword">class</span> <span class="token class-name">BFS</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 初始化各个结点距离源结点的距离为 inf 无穷</span>
        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token comment"># 从源结点 s 到目标结点 v 的一条最短路径上的所有结点(的关键字)</span>
        self<span class="token punctuation">.</span>end_recursion <span class="token operator">=</span> <span class="token boolean">False</span>  <span class="token comment"># 如果此标志为真，则会结束掉递归过程</span>

    <span class="token comment"># 输入：输入图结构默认为邻接矩阵 adj_m，而 start_key 为源顶点的关键字</span>
    <span class="token keyword">def</span> <span class="token function">do_bfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj_m<span class="token punctuation">,</span> start_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span>
        <span class="token comment"># 先把 start_key 源顶点的关键字 转为源结点结构体</span>
        <span class="token keyword">if</span> start_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            start_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>start_key<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> start_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">)</span>
            start_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'输入的 start_key 不是任何顶点的关键字，BFS 失败'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>

        <span class="token comment"># 1. 除了源结点 s 外，将其余所有结点 u 的状态标记为“未被发现”，即 color 为白色 white</span>
        <span class="token comment"># 另外，将 u.d 设置为无穷 inf，表示从源结点不可达结点 u。由于未探索到结点 u，将其前驱结点设置为空 nil</span>
        <span class="token keyword">for</span> v <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
            v<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">False</span>
            v<span class="token punctuation">.</span>distance <span class="token operator">=</span> self<span class="token punctuation">.</span>inf
            v<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token comment"># 2. 设置源结点 s 的属性。由于已经发现了 s，所以 s.color 设置为灰色 gray。结点 s 到自身的距离为 0</span>
        <span class="token comment"># 结点 s 为 BFS 树的树根，所以前驱/父结点 u.p 为空 nil</span>
        start_v<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
        start_v<span class="token punctuation">.</span>distance <span class="token operator">=</span> <span class="token number">0</span>
        start_v<span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token boolean">None</span>

        <span class="token comment"># 3. 将 s 加入辅助队列 Q，成为其唯一成员</span>
        aux_queue <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Python 内建 queue 队列对象</span>
        aux_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>start_v<span class="token punctuation">)</span>

        <span class="token comment"># 4. 在 while 循环中，先进先出地逐个处理队列 Q 中的结点</span>
        <span class="token keyword">while</span> <span class="token keyword">not</span> aux_queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># 4.1. 先取出 Q 队首结点 u</span>
            u <span class="token operator">=</span> aux_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span> <span class="token keyword">and</span> u<span class="token punctuation">.</span>key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
            u_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>u<span class="token punctuation">.</span>key<span class="token punctuation">]</span>

            <span class="token comment"># 4.2. 逐个处理 u 的所有邻接结点 v</span>
            <span class="token keyword">for</span> v_index<span class="token punctuation">,</span> edge_flow <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>u_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 邻接矩阵中边流量为 0 表示残存网络中没有此边</span>
                <span class="token keyword">if</span> edge_flow <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                <span class="token comment"># 获取边的终点 v 结构体</span>
                v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>v_index<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>

                <span class="token comment"># 4.3. 如果 v.color 是白色，表示它未被发现，需要被加入到队列 Q 中。在入队之前，需要设置其属性：</span>
                <span class="token comment">#     - v.color 颜色设置为灰色，表示它已被发现，但是尚未被探索完（所谓探索结束，是其邻接结点都已被处理）</span>
                <span class="token comment">#     - v.d 是 v 到源结点 s 的距离，这个距离等于 u.d 距离加上 1</span>
                <span class="token comment">#     - v.p 设置前驱/父结点为 u</span>
                <span class="token comment">#     - 将 v 入队，之后的 while 循环中 会考察 v 的各个邻接结点</span>
                <span class="token keyword">if</span> <span class="token keyword">not</span> v<span class="token punctuation">.</span>color<span class="token punctuation">:</span>
                    v<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token boolean">True</span>
                    v<span class="token punctuation">.</span>distance <span class="token operator">=</span> u<span class="token punctuation">.</span>distance <span class="token operator">+</span> <span class="token number">1</span>
                    v<span class="token punctuation">.</span>p <span class="token operator">=</span> u
                    aux_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token comment"># 4. for 循环结束，u 的所有邻接结点都被考察了，所以 u 已经被探索结束了。u.color 设置为黑色，保证不会再被加入队列 Q</span>
            <span class="token comment"># u.color = True</span>

    <span class="token comment"># 在计算出 BFS 之后，打印出所有结点(的关键字)及其距离</span>
    <span class="token decorator annotation punctuation">@staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">print_vertex_distance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span>
        <span class="token keyword">for</span> v <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>key<span class="token punctuation">,</span> v<span class="token punctuation">.</span>distance<span class="token punctuation">)</span>

    <span class="token comment"># 在计算出 BFS 之后，获取从源结点 s 到目标结点 v 的一条最短路径上的所有结点(的关键字)</span>
    <span class="token comment"># 此处图结构为邻接矩阵 adj_m</span>
    <span class="token keyword">def</span> <span class="token function">get_path</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj_m<span class="token punctuation">,</span> start_key<span class="token punctuation">,</span> end_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># return 'get_path: 输入的参数类型不合法'</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment"># 先把 key 关键字 转为顶点点结构体</span>
        <span class="token keyword">if</span> start_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            start_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>start_key<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> start_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">)</span>
            start_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># return '输入的 start_key 不是任何顶点的关键字'</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token keyword">if</span> end_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">:</span>
            end_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>end_key<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> end_index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">)</span>
            end_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>end_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>end_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># return '输入的 end_key 不是任何顶点的关键字'</span>
            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>end_recursion <span class="token operator">=</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>_get_path<span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> end_v<span class="token punctuation">)</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>path

    <span class="token keyword">def</span> <span class="token function">_get_path</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> start_v<span class="token punctuation">,</span> end_v<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>end_recursion<span class="token punctuation">:</span>
            <span class="token keyword">return</span>
        <span class="token keyword">if</span> end_v <span class="token operator">==</span> start_v<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>start_v<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>end_v<span class="token punctuation">.</span>p<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment"># self.path = 'No path from ' + str(start_v.key) + ' to ' + str(end_v.key) + ' exists.'</span>
            self<span class="token punctuation">.</span>path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>end_recursion <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment"># 先获取其前驱结点/父结点的关键字，再获取本结点的关键字</span>
            self<span class="token punctuation">.</span>_get_path<span class="token punctuation">(</span>start_v<span class="token punctuation">,</span> end_v<span class="token punctuation">.</span>p<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>end_v<span class="token punctuation">.</span>key<span class="token punctuation">)</span>


<span class="token comment"># Ford-Fulkerson 最大流算法 - O(VE^2)</span>
<span class="token keyword">class</span> <span class="token class-name">FordFulkerson</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 所有结点的 distance 初始化为 inf</span>

    <span class="token comment"># 计算流网络(邻接矩阵) adj_m 的最大流</span>
    <span class="token keyword">def</span> <span class="token function">do_edmonds_karp</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> adj_m<span class="token punctuation">,</span> source_v_key<span class="token punctuation">,</span> terminal_v_key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 首先确认输入的合法性，并将输入的源结点和汇点关键字 转为结点结构体</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> AdjacencyMatrix<span class="token punctuation">)</span>
        <span class="token keyword">assert</span> source_v_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> terminal_v_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
        source_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>source_v_key<span class="token punctuation">]</span><span class="token punctuation">]</span>
        terminal_v <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>terminal_v_key<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>source_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>terminal_v<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
        <span class="token comment"># 1. 将各边的流量 flow 初始化为 0</span>
        <span class="token keyword">for</span> edge <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>edges<span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>edge<span class="token punctuation">,</span> Edge<span class="token punctuation">)</span>
            edge<span class="token punctuation">.</span>flow <span class="token operator">=</span> <span class="token number">0</span>

        <span class="token comment"># 2. 在 while 循环中，重复在残存网络 Gf 中寻找一条增广路径 p</span>
        <span class="token comment"># 然后使用残存容量 cf(p) 来对路径 p 上的流 flow 进行增加</span>
        <span class="token comment"># 路径 p 上的一条边要么是原来网络中的一条边，要么是原来网络中的边 的反向边</span>
        <span class="token comment"># 在本实现中，adj_m 中的矩阵保存的就是残存网络 Gf 中各个边的流量</span>
        bfs <span class="token operator">=</span> BFS<span class="token punctuation">(</span><span class="token punctuation">)</span>
        is_exist_aug_path <span class="token operator">=</span> <span class="token boolean">True</span>  <span class="token comment"># 循环标志 True 表示当前残存网络 Gf 中存在一条增广路径</span>
        <span class="token keyword">while</span> is_exist_aug_path<span class="token punctuation">:</span>
            <span class="token comment"># 2.1. 找出增广路径 aug_path</span>
            bfs<span class="token punctuation">.</span>do_bfs<span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> source_v<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
            aug_path <span class="token operator">=</span> bfs<span class="token punctuation">.</span>get_path<span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> source_v_key<span class="token punctuation">,</span> terminal_v_key<span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">)</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
                <span class="token comment"># 如果不存在增广路径，BFS 会返回空列表。如果返回仅含 1 个元素关键字的列表，是异常情况</span>
                <span class="token keyword">break</span>

            <span class="token comment"># 2.2. 找出路径 p 中的最小残存容量 cf(u, v)</span>
            min_cf <span class="token operator">=</span> self<span class="token punctuation">.</span>inf
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 根据 key 获取 index</span>
                from_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                to_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> from_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
                from_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_key<span class="token punctuation">]</span>
                to_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_key<span class="token punctuation">]</span>
                <span class="token comment"># 更新路径上的最小残存容量 min_cf</span>
                <span class="token keyword">if</span> min_cf <span class="token operator">&gt;</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                    min_cf <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>
            <span class="token keyword">assert</span> min_cf <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>inf  <span class="token comment"># 断言增广路径上的流量值不为 inf</span>

            <span class="token comment"># 2.3. 在 for 循环中，对路径上 p 的每条边 (u, v) 的流量进行更新</span>
            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aug_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># 根据 key 获取 index</span>
                from_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
                to_key <span class="token operator">=</span> aug_path<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> from_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index <span class="token keyword">and</span> to_key <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2v_index
                from_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>from_key<span class="token punctuation">]</span>
                to_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2v_index<span class="token punctuation">[</span>to_key<span class="token punctuation">]</span>

                <span class="token comment"># 如果残存边 (u, v) 是原来流网络中的一条边，则增加其流量 (u, v).f</span>
                <span class="token comment"># 如果残存边 (u, v) 不是原来流网络中的一条边，则减少其反向边 (v, u) 流量 (v, u).f</span>
                <span class="token comment"># 在本实现中，增加边 (u, v) 的流量，等于缩减 (u, v) 的剩余容量、增加反平行边 (v, u) 的剩余容量</span>
                adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span> <span class="token operator">-=</span> min_cf
                adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span><span class="token punctuation">[</span>from_index<span class="token punctuation">]</span> <span class="token operator">+=</span> min_cf

        <span class="token comment"># 3. 最后，当 while 循环结束时，不再有增广路径。根据最大流最小切割定理，此时流 flow 就是最大流</span>
        <span class="token comment"># 在本实现中，adj_m 中的矩阵保存的就是残存网络 Gf 中各个边的流量，最终将实际的流量赋予各个结点的 flow 属性</span>
        adj_m<span class="token punctuation">.</span>max_flow <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> from_index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">for</span> to_index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                from_node <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span>
                to_node <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>
                <span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>from_node<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>to_node<span class="token punctuation">,</span> VertexMatrix<span class="token punctuation">)</span>
                <span class="token comment"># 如果此边是原图中的边，则赋予该边 flow 属性，表示最大流的流量</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>from_node<span class="token punctuation">.</span>key<span class="token punctuation">,</span> to_node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token keyword">in</span> adj_m<span class="token punctuation">.</span>key2e_index<span class="token punctuation">:</span>
                    edge_index <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>key2e_index<span class="token punctuation">[</span><span class="token punctuation">(</span>from_node<span class="token punctuation">.</span>key<span class="token punctuation">,</span> to_node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span>
                    edge <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>edge_index<span class="token punctuation">]</span>
                    edge<span class="token punctuation">.</span>flow <span class="token operator">=</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>        <span class="token comment"># 赋予此边流量属性 flow</span>
                    adj_m<span class="token punctuation">.</span>max_flow <span class="token operator">+=</span> adj_m<span class="token punctuation">.</span>adj_m<span class="token punctuation">[</span>from_index<span class="token punctuation">]</span><span class="token punctuation">[</span>to_index<span class="token punctuation">]</span>  <span class="token comment"># 增长图的最大流量值</span>


<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 构造图同《CLRS》图 26-6 的(含边容量的)有向图用于计算最大流</span>
    <span class="token comment"># 用于构造邻接矩阵的顶点的 key/val 信息列表</span>
    matrix_vertices_info <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token punctuation">]</span>
    <span class="token comment"># 有向边的 from/to/c/is_directed 信息列表</span>
    <span class="token comment"># is_directed 为 True 表示此边为有向边，否则为无向边</span>
    di_edges_info <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token string">'v1'</span><span class="token punctuation">,</span> <span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token string">'v2'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v3'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'v4'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span>
    <span class="token punctuation">]</span>

    <span class="token comment"># 根据前述列表信息构造结点列表</span>
    inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span>  <span class="token comment"># 需保证与程序中其它 inf 是相同的值</span>
    matrix_vertices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    di_edges <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> v <span class="token keyword">in</span> matrix_vertices_info<span class="token punctuation">:</span>
        matrix_vertices<span class="token punctuation">.</span>append<span class="token punctuation">(</span>VertexMatrix<span class="token punctuation">(</span>key<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> distance<span class="token operator">=</span>inf<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> e <span class="token keyword">in</span> di_edges_info<span class="token punctuation">:</span>
        di_edges<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Edge<span class="token punctuation">(</span>from_v<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> to_v<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> capacity<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> is_directed<span class="token operator">=</span>e<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 创建邻接矩阵 (用邻接矩阵+有向图 执行最大流算法)</span>
    adj_m <span class="token operator">=</span> AdjacencyMatrix<span class="token punctuation">(</span>matrix_vertices<span class="token punctuation">,</span> di_edges<span class="token punctuation">)</span>

    <span class="token comment"># 执行 O(VE^2) Ford-Fulkerson 最大流算法</span>
    source_v_key<span class="token punctuation">,</span> terminal_v_key <span class="token operator">=</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'t'</span>
    ford_fulkerson <span class="token operator">=</span> FordFulkerson<span class="token punctuation">(</span><span class="token punctuation">)</span>
    start <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ford_fulkerson<span class="token punctuation">.</span>do_edmonds_karp<span class="token punctuation">(</span>adj_m<span class="token punctuation">,</span> source_v_key<span class="token punctuation">,</span> terminal_v_key<span class="token punctuation">)</span>
    end <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 输出结果 &amp; 运行时间</span>
    <span class="token comment"># max_flow: 23</span>
    <span class="token comment"># [0, 4, 2, 0, 0, 0]</span>
    <span class="token comment"># [12, 0, 0, 0, 0, 0]</span>
    <span class="token comment"># [11, 4, 0, 0, 3, 0]</span>
    <span class="token comment"># [0, 12, 9, 0, 7, 1]</span>
    <span class="token comment"># [0, 0, 11, 0, 0, 0]</span>
    <span class="token comment"># [0, 0, 0, 19, 4, 0]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\nmax_flow:'</span><span class="token punctuation">,</span> adj_m<span class="token punctuation">.</span>max_flow<span class="token punctuation">)</span>
    adj_m<span class="token punctuation">.</span>print_matrix_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Running Time: %.5f ms'</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">&quot;__main__&quot;</span><span class="token punctuation">:</span>
    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ff60b80d.js" defer></script><script src="/assets/js/2.db22a8ef.js" defer></script><script src="/assets/js/44.3144e6c6.js" defer></script>
  </body>
</html>
