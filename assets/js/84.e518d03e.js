(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{334:function(t,r,o){"use strict";o.r(r);var n=o(28),_=Object(n.a)({},(function(){var t=this,r=t.$createElement,o=t._self._c||r;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"algorithm-sort-linear-time-sort"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-sort-linear-time-sort"}},[t._v("#")]),t._v(" Algorithm - Sort - Linear Time Sort")]),t._v(" "),o("p",[t._v("By "),o("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),o("OutboundLink")],1)]),t._v(" "),o("h2",{attrs:{id:"简介"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),o("h3",{attrs:{id:"线性时间排序"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#线性时间排序"}},[t._v("#")]),t._v(" 线性时间排序")]),t._v(" "),o("p",[o("a",{attrs:{href:"./insertion-sort"}},[t._v("插入排序")]),t._v("、"),o("a",{attrs:{href:"./merge-sort"}},[t._v("归并排序")]),t._v("、"),o("a",{attrs:{href:"./heap-sort"}},[t._v("堆排序")]),t._v("、"),o("a",{attrs:{href:"./quick-sort"}},[t._v("快速排序")]),t._v(" 等算法，都属于"),o("strong",[t._v("比较排序")]),t._v("，其共同点是：在排序的最终结果中，各元素的次序依赖于它们之间的比较。任何比较排序算法的渐近时间复杂度下界是 "),o("code",[t._v("\\Omega (n log n)")]),t._v("。")]),t._v(" "),o("p",[t._v("比较排序可以被抽象为一棵决策树。这是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。排序算法的执行对英于一条从树根到某个叶结点的路径，而每个内部结点表示一次元素比较。")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/sort/linear-time-sort-1.png",alt:"linear-time-sort-1"}})]),t._v(" "),o("p",[t._v("在决策树中，从根结点到任意一个可达叶结点之间的"),o("strong",[t._v("最长")]),t._v("简单路径的长度，就表示对应的排序算法中"),o("strong",[t._v("最坏情况")]),t._v("下的比较次数。因此，一个比较排序算法的最坏情况比较次数就等于其决策树的高度。")]),t._v(" "),o("p",[o("strong",[t._v("定理")]),t._v("：在最坏情况下，任何比较排序算法都需要做 "),o("code",[t._v("\\Omega (n log n)")]),t._v(" 次比较。")]),t._v(" "),o("p",[o("strong",[t._v("证明")]),t._v("：根据前面的讨论，对于一棵每个排列都是一个可达的叶结点的决策树来说，树的高度完全可以被确定。考虑一棵高度为 h、具有 l 个可达叶结点的决策树，它对应一个对 n 个元素所做的比较排序。因为输入数据的 n! 种可能的排列都是叶结点，所以有 n! <= l。由于在一棵高度为 h 的二叉树中，叶结点的数目不多于 2^h （即完美二叉树的情况），于是有 "),o("code",[t._v("n! <= l <= 2^h")]),t._v("，对该式两边取对数，有 "),o("code",[t._v("h >= log(n!) = \\Omega (n log n)")]),t._v("。")]),t._v(" "),o("p",[t._v("其中，对 log(n!) 中的阶乘 n! 可采用 斯特林公式 Stirling's approximation，即 n! 约等于 "),o("code",[t._v("\\sqrt{2n \\pi} (n/e)^n")])]),t._v(" "),o("p",[t._v("如果不使用斯特林公式，可以如下证明："),o("code",[t._v("log(n!) = \\sum_{i=1}^{n} (log i) >= \\sum_{i=n/2}^{n} (log i) >= \\sum_{i=n/2}^{n} (log (n/2)) = (n/2) log n - n")]),t._v("，故 "),o("code",[t._v("h >= log(n!) >= (n/2) (log n - 1) = \\Omega (n log n)")])]),t._v(" "),o("p",[t._v("因此，堆排序和归并排序都是"),o("strong",[t._v("渐进最优")]),t._v("的比较排序算法。（其它比较排序算法都只可能在"),o("strong",[t._v("常数因子")]),t._v("上优于 堆排序和归并排序）。")]),t._v(" "),o("p",[t._v("而线性时间复杂度的排序算法（包括 Counting Sort 计数排序、Radix Sort 基数排序、Bucket Sort 桶排序等）都是用运算而不是比较来确定排序顺序的，因此其渐近时间复杂度下界"),o("strong",[t._v("不再")]),t._v("是 "),o("code",[t._v("\\Omega (n log n)")]),t._v("。")]),t._v(" "),o("h3",{attrs:{id:"计数排序-counting-sort"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#计数排序-counting-sort"}},[t._v("#")]),t._v(" 计数排序 (Counting Sort)")]),t._v(" "),o("p",[o("strong",[t._v("计数排序")]),t._v(" 假设 n 个输入元素中的每一个都是在 "),o("strong",[t._v("0 到 k 区间")]),t._v("内的一个"),o("strong",[t._v("整数")]),t._v("，其中 k 为某个整数。当 k=O(n) 时，排序的运行时间为 "),o("code",[t._v("\\Theta(n)")]),t._v("。")]),t._v(" "),o("p",[t._v("计数排序的"),o("strong",[t._v("基本思想")]),t._v("是：对每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放置到它该在输出数组中的位置，而不用做比较操作。例如，如果有 17 个元素小于 x，则 x 就应该在第 18 个输出位置上。当有几个元素相同时（类似于哈希表出现冲突碰撞），这一方案要略作修改，因为不能把它们放在同一个输出位置上。")]),t._v(" "),o("h3",{attrs:{id:"基数排序-radix-sort"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#基数排序-radix-sort"}},[t._v("#")]),t._v(" 基数排序 (Radix Sort)")]),t._v(" "),o("p",[o("strong",[t._v("基数排序")]),t._v(" 对一些 d 位数排序时，先按最低有效位排序，逐次对各有效位排序，直到最高有效位。每次排序采用 Counting Sort 计数排序，其 k 值仅为 10（因为十进制里面，一位数字有 0, 1, 2,..., 9 这十种可能）。")]),t._v(" "),o("p",[t._v("除了上述进行数字排序的场景，基数排序也可用于对具有多关键字域的记录进行排序。例如，用三个关键字（年、月、日）对日期进行升序排列，则先升序排列日、然后排列月、最后排列年。")]),t._v(" "),o("p",[t._v("保证基数排序正确性的一个关键在于：对每位进行排序的算法必须要是稳定的。而计数排序是稳定的。且在 k 值不大的情况下是高效的，因此基数排序常使用计数排序作为其子过程，以进行每一位的排序。")]),t._v(" "),o("p",[t._v("给定 n 个 d 位数，其中每一个数位有 k 个可能的取值。如果基数排序使用的稳定排序算法耗时 "),o("code",[t._v("\\Theta (n+k)")]),t._v("（比如计数排序），那么它就可以在 "),o("code",[t._v("\\Theta (d(n+k))")]),t._v(" 时间内将这些数排好序。")]),t._v(" "),o("h3",{attrs:{id:"对比基数排序与比较排序"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#对比基数排序与比较排序"}},[t._v("#")]),t._v(" 对比基数排序与比较排序")]),t._v(" "),o("p",[t._v("基数排序是否会比基于比较的排序算法（如快速排序）更好呢？通常情况下，如果 b = O(log n)，而且选择 r 约等于 log n，则基数排序的运行时间为 "),o("code",[t._v("\\Theta (n)")]),t._v("。这一结果看上去要比快速排序的期望运行代价 "),o("code",[t._v("\\Theta (n log n)")]),t._v(" 更好一些。但是，在这两个表达式中，隐藏在 "),o("code",[t._v("\\Theta")]),t._v(" 符号背后的常数项因子是不同的。在处理 n 个关键字时，尽管基数排序执行的循环轮数会比快速排序要少，但每一轮它所耗费的时间要长得多。")]),t._v(" "),o("p",[t._v("哪一个排序算法更合适，依赖于具体实现和底层硬件的特性（例如，快速排序通常可以比基数排序更有效地使用硬件的缓存），以及输入数据的特征。此外，利用计数排序作为中间稳定排序的基数排序不是原址排序（即不能仅通过 O(1) 的辅助空间完成排序），而很多 "),o("code",[t._v("\\Theta (n log n)")]),t._v(" 时间的比较排序是原址排序。因此，当主存的容量比较宝贵时，可能会更倾向于像快速排序这样的原址排序算法。")]),t._v(" "),o("h3",{attrs:{id:"桶排序-bucket-sort"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#桶排序-bucket-sort"}},[t._v("#")]),t._v(" 桶排序 (Bucket Sort)")]),t._v(" "),o("p",[t._v("桶排序 Bucket Sort 假设输入数据服从均匀分布，平均情况下它的时间代价为 O(n)。与计数排序类似，因为"),o("strong",[t._v("对输入数据做了某种假设")]),t._v("，桶排序的速度也很快。")]),t._v(" "),o("p",[t._v("具体来说，计数排序假设数据都属于一个"),o("strong",[t._v("小区间")]),t._v("内的"),o("strong",[t._v("整数")]),t._v("，而桶排序则假设输入是由一个随机过程产生的。该过程将元素"),o("strong",[t._v("均匀、独立")]),t._v("地分布在 [ 0, 1) 区间上。")]),t._v(" "),o("p",[t._v("桶排序将 [ 0, 1) 区间划分为 n 个相同大小的子区间，或称为"),o("strong",[t._v("桶")]),t._v("。然后，将 n 个输入数分别放到各个桶中。因为输入数据是"),o("strong",[t._v("均匀、独立")]),t._v("地分布在 [ 0, 1) 区间上，所以一般不会出现很多数落在同一个桶的情况。")]),t._v(" "),o("p",[t._v("在桶排序的代码中，我们假设输入是一个包含 n 个元素的数组 A，且每个元素 A[i] 满足 0 <= A[i] <= 1。此外，算法还需要一个长度为 n 的临时数组 B[0..n-1] 来存放"),o("strong",[t._v("链表")]),t._v("（即桶），并假设存在一种用于维护这些链表的机制。")]),t._v(" "),o("h3",{attrs:{id:"python"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),o("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),o("ul",[o("li",[o("strong",[t._v("注")]),t._v("：\n"),o("ul",[o("li",[t._v("排序算法的基类 Sort 和元素结构体类 Element 写法与 "),o("a",{attrs:{href:"./sort-base-class"}},[t._v("此文章")]),t._v(" 完全相同，故不在下方赘述。")]),t._v(" "),o("li",[t._v("如果要运行此代码，则还需先将 Sort 类和 Element 类置于本代码中。")]),t._v(" "),o("li",[t._v("Element 类完全可以根据程序需求来自定义，但是需要给出该类中的 key 和 value 属性名。")])])])]),t._v(" "),o("h3",{attrs:{id:"计数排序-counting-sort-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#计数排序-counting-sort-2"}},[t._v("#")]),t._v(" 计数排序 Counting Sort")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/counting-sort.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),o("OutboundLink")],1)]),t._v(" "),o("h3",{attrs:{id:"基数排序-radix-sort-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#基数排序-radix-sort-2"}},[t._v("#")]),t._v(" 基数排序 Radix Sort")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/radix-sort.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),o("OutboundLink")],1)]),t._v(" "),o("h3",{attrs:{id:"桶排序-bucket-sort-2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#桶排序-bucket-sort-2"}},[t._v("#")]),t._v(" 桶排序 Bucket Sort")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/bucket-sort.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),o("OutboundLink")],1)]),t._v(" "),o("h2",{attrs:{id:"参考资料"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),o("ul",[o("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 8")]),t._v(" "),o("li",[t._v("MIT 6.006 Introduction to Algorithms, Fall 2011 - "),o("a",{attrs:{href:"https://www.youtube.com/watch?v=Nz1KZXbghj8",target:"_blank",rel:"noopener noreferrer"}},[t._v("7. Counting Sort, Radix Sort, Lower Bounds for Sorting"),o("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=_.exports}}]);