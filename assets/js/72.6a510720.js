(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{318:function(_,v,e){"use strict";e.r(v);var i=e(28),t=Object(i.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"algorithm-linear-programming-simplex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-linear-programming-simplex"}},[_._v("#")]),_._v(" Algorithm - Linear Programming - Simplex")]),_._v(" "),e("p",[_._v("By "),e("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[_._v("YuweiYin"),e("OutboundLink")],1)]),_._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[_._v("#")]),_._v(" 简介")]),_._v(" "),e("p",[_._v("线性规划 Linear Programming")]),_._v(" "),e("p",[_._v("单纯形算法 Simplex Algorithm")]),_._v(" "),e("h2",{attrs:{id:"单纯形算法-simplex-algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单纯形算法-simplex-algorithm"}},[_._v("#")]),_._v(" 单纯形算法 Simplex Algorithm")]),_._v(" "),e("p",[_._v("单纯形算法是求解线性规划问题的经典方法。虽然它的运行时间在最坏情况下是指数级的，但它在实际中通常相当快速，此外，单纯形算法对深刻理解线性规划很有帮助。")]),_._v(" "),e("p",[_._v("单纯形算法与求解线性方程组的高斯消元法 (Gaussian Elimination) 有些类似。高斯消元法从一个解未知的线性等式系统开始，在每次迭代中，把这个系统重写为具有一些额外结构的等价形式。经过一定次数的迭代后，等式系统已经被重写到一个容易求解的形式了。单纯形算法以一种类似的方式进行，而且可以被看作是"),e("strong",[_._v("在不等式上的高斯消元法")]),_._v("。")]),_._v(" "),e("p",[_._v("在单纯形算法的每轮迭代中，都关联一个“基本解”，很容易从线性规划的松弛型中得到此基本解：将每个非基本变量设为 0，并从等式约束中计算基本变量的值。每轮迭代把一个松弛型转换成一个等价的松弛型。")]),_._v(" "),e("p",[_._v("关联的基本可行解的目标值不会小于上一轮的迭代，通常会更大一些。为了增大目标值，选择一个非基本变量，使得如果从 0 开始增加变量值，目标值也会增加。变量值能够增加的幅度受限于其它的约束条件，将之增加 直到某基本变量变为 0。然后重写松弛型，交换此基本变量和选定的非基本变量。")]),_._v(" "),e("h3",{attrs:{id:"单纯形算法的一个例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单纯形算法的一个例子"}},[_._v("#")]),_._v(" 单纯形算法的一个例子")]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-1.png",alt:"simplex-1"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-2.png",alt:"simplex-2"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-3.png",alt:"simplex-3"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-4.png",alt:"simplex-4"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-5.png",alt:"simplex-5"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-6.png",alt:"simplex-6"}})]),_._v(" "),e("h3",{attrs:{id:"转动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#转动"}},[_._v("#")]),_._v(" 转动")]),_._v(" "),e("p",[_._v("一个"),e("strong",[_._v("转动")]),_._v("选取一个"),e("strong",[_._v("非基本变量")]),_._v(" xe（称为"),e("strong",[_._v("替入变量")]),_._v("）和一个基本变量 xl（称为"),e("strong",[_._v("替出变量")]),_._v("），然后替换二者的角色。")]),_._v(" "),e("p",[_._v("现在形式化主元的过程。下面的过程 "),e("code",[_._v("PIVOT")]),_._v(" 以一个松弛型为输入，给定元组 "),e("code",[_._v("(N, B, A, b, c, v)")]),_._v("、替出变量 xl 的下标 l，以及替入变量 xe 的下标 e。过程返回描述新松弛型的元祖 "),e("code",[_._v("(N', B', A', b', c', v')")]),_._v("。m x n 阶矩阵 A 和 A' 的元素实际上都是松弛型中的系数的相反数。回顾各符号的意义如下：")]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-6.png",alt:"lp-6"}})]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("PIVOT(N, B, A, b, c, v, l, e)\n1  // Compute the coefficients of the equation for new basic variable x_e\n2  let A' be a new m x n matrix\n3  b'_e = b_l / a_le\n4  for each j \\in N-{e}\n5      a'_ej = a_lj / a_le\n6  a'_el = 1 / a_le\n7  // Compute the coefficients of the remaining constraints\n8  for each i \\in B-{l}\n9      b'_i = b_i - a_ie * b'_e\n10     for each j \\in N-{e}\n11         a'_ij = a_ij - a_ie * a'_ej\n12     a'_il = - a_ie * a'_el\n13 // Compute the objective function\n14 v' = v + c_e * b'_e\n15 for each j \\in N-{e}\n16     c'_j = c_j - c_e * a'_ej\n17 c'_l = - c_e * a'_el\n18 // Compute new sets of basic and nonbasic variables\n19 N' = (N - {e}) \\cup {l}\n20 B' = (B - {l}) \\cup {e}\n21 return (N', B', A', b', c', v')\n")])])]),e("p",[_._v("算法过程描述如下：")]),_._v(" "),e("ol",[e("li",[_._v("在 2～6 行，创建新系数矩阵 A'，并通过重写 "),e("code",[_._v("x_l")]),_._v(" 在左边的等式将 "),e("code",[_._v("x_e")]),_._v(" 置于等式左边，来计算 "),e("code",[_._v("x_e")]),_._v(" 的新等式中的系数。")]),_._v(" "),e("li",[_._v("在 8～12 行，通过将每个 "),e("code",[_._v("x_e")]),_._v(" 替换为这个新等式的右边 来更新剩下的等式。")]),_._v(" "),e("li",[_._v("在 14～17 行，对目标函数进行前述同样地替换。")]),_._v(" "),e("li",[_._v("在 19～20 行，更新非基本变量集合 N 和基本变量集合 B。")]),_._v(" "),e("li",[_._v("在 21 行，最后返回新的松弛型。")])]),_._v(" "),e("p",[_._v("如果 "),e("code",[_._v("a_le == 0")]),_._v("，则 "),e("code",[_._v("PIVOT")]),_._v(" 过程会有除 0 错误，因此仅当 "),e("code",[_._v("a_le != 0")]),_._v(" 时调用此过程。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-7.png",alt:"simplex-7"}})]),_._v(" "),e("h3",{attrs:{id:"正式的单纯形算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#正式的单纯形算法"}},[_._v("#")]),_._v(" 正式的单纯形算法")]),_._v(" "),e("p",[_._v("在使用单纯形算法解决线性规划问题前，还需思考当前问题的性质：")]),_._v(" "),e("ul",[e("li",[_._v("如何确定一个线性规划是不是可行的？")]),_._v(" "),e("li",[_._v("如果此线性规划是可行的，但初始基本解不可行，该怎么办？")]),_._v(" "),e("li",[_._v("如何确定一个线性规划是否无界？")]),_._v(" "),e("li",[_._v("如何选择替入变量和替出变量？")])]),_._v(" "),e("p",[_._v("假设有一个过程 "),e("code",[_._v("INITIALIZE_SIMPLEX(A, b, c)")]),_._v("，输入为一个基本的线性规划，即一个 m x n 的矩阵 A = (aij)，一个 m 维向量 b = (bi)，一个 n 维向量 c = (cj)。如果这个问题是不可行的，此过程将报告此线性规划不可行，然后终止。否则此过程返回一个初始基本解可行的松弛型。")]),_._v(" "),e("p",[_._v("如前所述，子过程 "),e("code",[_._v("SIMPLEX")]),_._v(" 以一个标准型的线性规划作为输入，返回一个 n 维向量 x' = (x'_{j}) 为线性规划的一个最优解。")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("SIMPLEX(A, b, c)\n1  (N, B, A, b, c, v) = INITIALIZE_SIMPLEX(A, B, c)\n2  let \\delta be a new vector of length m\n3  while some index j \\in N has c_j > 0\n4      choose an index e \\in N for which c_e > 0\n5      for each index i \\in B\n6          if a_ie > 0\n7              \\delta_i = b_i / a_ie\n8          else\n9              \\delta_i = inf\n10     choose an index l \\in B that minimizes \\delta_l\n11     if \\delta_l == inf\n12         return \"unbounded\"\n13     else\n14         (N, B, A, b, c, v) = PIVOT(N, B, A, b, c, v, l, e)\n15 for i = 1 to n\n16     if i \\in B\n17         x'_i = b_i\n18     else\n19         x'_i = 0\n20 return (x'_1, x'2, ..., x'_n)\n")])])]),e("p",[_._v("算法过程描述如下：")]),_._v(" "),e("ol",[e("li",[_._v("在 1 行，调用过程 "),e("code",[_._v("INITIALIZE_SIMPLEX(A, b, c)")]),_._v("，要么确定这个线性规划是不可行的，要么返回一个初始基本解可行的松弛型。")]),_._v(" "),e("li",[_._v("在 3～14 行的 while 循环是单纯形算法的主体部分，如果目标函数中所有系数 "),e("code",[_._v("c_j")]),_._v(" 都是负值，那么 while 循环将终止。如果进入 while 循环内部，下面进行描述：\n"),e("ul",[e("li",[_._v("在 4 行，在非基本变量集合 N 中选择一个变量 "),e("code",[_._v("x_e")]),_._v(" 作为替出变量，其系数 "),e("code",[_._v("c_e")]),_._v(" 在目标函数中为正值。")]),_._v(" "),e("li",[_._v("在 5～10 行，检查每个约束，然后挑选出一个约束：此约束能够最严格地限制 "),e("code",[_._v("x_e")]),_._v(" 值增加的幅度，而又不违反任何非负约束。与此约束相关联的基本变量是 "),e("code",[_._v("x_l")]),_._v("，它会作为替入变量。")]),_._v(" "),e("li",[_._v("在 11～12 行，如果没有约束能够限制替入变量所增加的幅度，那么算法在 11 行返回“无界”。")]),_._v(" "),e("li",[_._v("在 13～14 行，否则，调用 "),e("code",[_._v("PIVOT")]),_._v(" 过程来交换替出变量与替入变量的角色。")])])]),_._v(" "),e("li",[_._v("在 15～19 行，通过把所有的非基本变量设为 0 以及把每个基本变量 "),e("code",[_._v("x'_i")]),_._v(" 设为 "),e("code",[_._v("b_i")]),_._v("，来计算初始线性规划的一个解向量 "),e("code",[_._v("(x'_1, x'2, ..., x'_n)")]),_._v("。")]),_._v(" "),e("li",[_._v("在 20 行，最后返回解向量。")])]),_._v(" "),e("h3",{attrs:{id:"单纯形算法的正确性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#单纯形算法的正确性"}},[_._v("#")]),_._v(" 单纯形算法的正确性")]),_._v(" "),e("p",[_._v("下面给出一些引理、推论、定理来说明单纯形算法的正确性，包含如下方面：首先（引理 29.2）说明如果 "),e("code",[_._v("SIMPLEX")]),_._v(" 有一个初始可行解 并且 最终会停止，则它要么返回一个可行解，要么确定此线性规划是无解的。然后（引理 29.3～引理 29.7）说明 "),e("code",[_._v("SIMPLEX")]),_._v(" 过程会停止。最后（定理 29.10）说明返回的解是最优的。（关于这些引理和定理的证明，详见《CLRS》Chapter 29）")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.2")]),_._v("：给定一个线性规划 (A, b, c)。假设在 "),e("code",[_._v("SIMPLEX")]),_._v(" 第 1 行中对 "),e("code",[_._v("INITIALIZE_SIMPLEX")]),_._v(" 的调用返回一个基本解可行的松弛型。如果 "),e("code",[_._v("SIMPLEX")]),_._v(" 在第 20 行返回一个解，则这个解是此线性规划的一个可行解。如果 "),e("code",[_._v("SIMPLEX")]),_._v(" 在第 11 行返“无界”，则此线性规划是无界的。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("单纯形算法的每次迭代会增加和基本解关联的目标值 v。"),e("code",[_._v("SIMPLEX")]),_._v(" 的迭代也"),e("strong",[_._v("不会减小")]),_._v("基本解相关联的目标值，但是可惜的是，可能会存在"),e("strong",[_._v("保持目标值 v 不变")]),_._v("的一些迭代，这个现象被称为"),e("strong",[_._v("退化")]),_._v("。")]),_._v(" "),e("p",[_._v("退化会阻止单纯形算法终止，因为它可以引起一种被称为"),e("strong",[_._v("循环")]),_._v(" (cycling) 的现象："),e("code",[_._v("SIMPLEX")]),_._v(" 的两次不同迭代中的松弛型完全一样。因为退化，"),e("code",[_._v("SIMPLEX")]),_._v(" 会选择一个转动操作序列，让目标值不变，但是会在此序列中重复一个松弛型，从而永远循环下去、"),e("code",[_._v("SIMPLEX")]),_._v(" 不会终止。")]),_._v(" "),e("p",[_._v("循环是 "),e("code",[_._v("SIMPLEX")]),_._v(" 唯一可能不会终止的原因。下面先用引理 29.3 和 引理 29.4 证明一个性质，然后在 引理 29.5 证明这一点。")]),_._v(" "),e("p",[_._v("在每一次循环中，除了集合 N、B 以外，"),e("code",[_._v("SIMPLEX")]),_._v(" 还维护了 A、b、c 和 v。尽管维护它们能够高效实现单纯形算法，但不维护它们也能得到最终的解向量。也即是说，基本变量和非基本变量的集合足以唯一确定松弛型。下面引理 29.3 和 引理 29.4 将证明这一点。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.3")]),_._v("：设 I 是一个下标集合。对于每一个 j \\in I，设 aj 和 bj 是实数，并令 xj 是一个实数变量。设 c 是任意的实数。假设对于变量 xj 的任何设置，都有 $ \\sum_{j \\in I} aj·xj == c + \\sum_{j \\in I} bj·xj $，那么对任意的 j \\in I，有 aj == bj 且 c == 0。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.4")]),_._v("：设 (A, b, c) 是一个线性规划的标准形式。给定基本变量的一个集合 B，那么关联的松弛型是唯一确定的。")]),_._v(" "),e("p",[_._v("现在可以说明循环是 "),e("code",[_._v("SIMPLEX")]),_._v(" 可能不会终止的唯一原因。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.5")]),_._v("：如果 "),e("code",[_._v("SIMPLEX")]),_._v(" 在至多 $ C_{n+m}^{m} $ 次迭代内不终止，那么它是循环的。（这里 C 代表组合数）")]),_._v(" "),e("p",[_._v("循环在理论上是可能出现的，但在实际中非常罕见。可以通过小心地选择替入变量和替出变量来避免循环的发生。一种方法是 "),e("strong",[_._v("对输入稍微进行扰动")]),_._v("，使得不太可能有两个解具有相等的目标值。另一种方法是通过 "),e("strong",[_._v("总是选择下标最小的变量")]),_._v(" 来打破相等的目标值，这种策略被称为 "),e("strong",[_._v("Bland 规则")]),_._v("。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.6")]),_._v("：如果 "),e("code",[_._v("SIMPLEX")]),_._v(" 的第 4 行和第 10 行 "),e("strong",[_._v("总是选择具有最小下标的变量")]),_._v(" 来打破目标值不变的局面，那么 "),e("code",[_._v("SIMPLEX")]),_._v(" "),e("strong",[_._v("必然终止")]),_._v("。")]),_._v(" "),e("p",[_._v("下面的引理 29.7 进行了总结：")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.7")]),_._v("：假设 "),e("code",[_._v("INITIALIZE_SIMPLEX")]),_._v(" 返回一个基本解可行的松弛型，则 "),e("code",[_._v("SIMPLEX")]),_._v(" 要么报告一个线性规划是无界的，要么在至多 $ C_{n+m}^{m} $ 次迭代内终止，并得到一个可行解。")]),_._v(" "),e("p",[_._v("根据 Stirling 公式易知，组合数是指数级别的，因此在最坏情况下单纯形算法的渐近运行时间会达到指数阶。不过它在实际中运行高效。")]),_._v(" "),e("h2",{attrs:{id:"对偶性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对偶性"}},[_._v("#")]),_._v(" 对偶性")]),_._v(" "),e("p",[_._v("前面已经证明了在某些假设下 "),e("code",[_._v("SIMPLEX")]),_._v(" 过程会终止，下面说明它计算出的解是线性规划的最优解。为此引入一个有力的概念："),e("strong",[_._v("线性规划对偶性")]),_._v("。")]),_._v(" "),e("p",[_._v("对偶性可以用于证明一个解的确是最优的。在最大流问题中的 "),e("strong",[_._v("最大流最小切割定理")]),_._v(" 就是对偶性的一个例子。假设给定最大流问题的一个实例，如何确定一个流 f 具有最大的流值 "),e("code",[_._v("|f|")]),_._v(" 呢？根据最大流最小切割定理，如果能找到一个切割的值也为 "),e("code",[_._v("|f|")]),_._v("，那么就可以确定 f 的确是一个最大流。这样的关系提供了一个对偶性的例子：给定一个"),e("strong",[_._v("最大化问题")]),_._v("，定义一个"),e("strong",[_._v("相关的最小化问题")]),_._v("，使得这两个问题具有"),e("strong",[_._v("同样的最优目标值")]),_._v("。")]),_._v(" "),e("p",[_._v("给定一个最大化目标的线性规划，考虑如何将其形式化为一个"),e("strong",[_._v("对偶")]),_._v("线性规划，其目标是最小化，而且最优值与初始线性规划的最优值相同。当表示对偶线性规划时，称初始的线性规划为"),e("strong",[_._v("原始")]),_._v(" (primal) 线性规划。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-8.png",alt:"simplex-8"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-9.png",alt:"simplex-9"}})]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-10.png",alt:"simplex-10"}})]),_._v(" "),e("h3",{attrs:{id:"弱对偶性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#弱对偶性"}},[_._v("#")]),_._v(" 弱对偶性")]),_._v(" "),e("p",[e("strong",[_._v("弱对偶性")]),_._v("表明原始线性规划的任意可行解的值 不大于 对偶线性规划的任意可行解的对应值。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.8")]),_._v("（"),e("strong",[_._v("线性规划弱对偶性")]),_._v("）：设 x 表示式 (29.16)～(29.18) 中原始线性规划的任意一个可行解，y 表示式 (29.83)～(29.85) 中对偶问题的任意一个可行解。那么有 $ \\sum_{j=1}^{n} cj·xj = \\sum_{i=1}^{m} bi·yi $")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("推论 29.9")]),_._v("：令 x 表示一个原始线性规划 (A, b, c) 的一个可行解，令 y 表示相应对偶问题的一个可行解。如果 $ \\sum_{j=1}^{n} cj·xj = \\sum_{i=1}^{m} bi·yi $，那么 x 和 y 分别是 原始线性规划 和 对偶线性规划 的最优解。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("定理 29.10")]),_._v("（"),e("strong",[_._v("线性规划对偶性")]),_._v("）：假设 "),e("code",[_._v("SIMPLEX")]),_._v(" 在原始线性规划 (A, b, c) 上返回值 x = (x1, x2, ..., xn)。令 N 和 B 分别表示最终松弛型的 非基本变量集合 和 基本变量集合，令 c' 表示最终松弛型中的系数，令 y = (y1, y2, ..., ym) 定义为：若 (n+i) \\in N 则 yi = - c'_{n+i}，否则 yi = 0。那么，x 是原始线性规划的一个最优解，y 是对偶线性规划的一个最优解，并且有 $ \\sum_{j=1}^{n} cj·xj = \\sum_{i=1}^{m} bi·yi $")]),_._v(" "),e("p",[_._v("上述引理、推论和定理的证明详见《CLRS》Chapter 29.4")]),_._v(" "),e("h2",{attrs:{id:"初始基本可行解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初始基本可行解"}},[_._v("#")]),_._v(" 初始基本可行解")]),_._v(" "),e("h3",{attrs:{id:"找到一个初始解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#找到一个初始解"}},[_._v("#")]),_._v(" 找到一个初始解")]),_._v(" "),e("p",[_._v("假设有一个过程 "),e("code",[_._v("INITIALIZE_SIMPLEX")]),_._v("，它确定一个线性规划是否有任何的可行解，如果有，则给出一个基本解可行的松弛型。")]),_._v(" "),e("p",[_._v("一个线性规划是可行的，而其初始基本解是不可行的，这种情况是可能出现的。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/simplex-11.png",alt:"simplex-11"}})]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("INITIALIZE_SIMPLEX(A, b, c)\n1  let k be the index of the minimum b_i\n2  if b_k >= 0\n3      return ({1, 2, ..., n}, {n+1, n+2, ..., n+m}, A, b, c, 0)\n4  form L_{aux} by adding - x_0 to the left-hand side of each constraint\n       and setting the objective function to - x_0\n5  let (N, B, A, b, c, v) be the resulting slack form for L_{aux}\n6  l = n + k\n7  // L_{aux} has n+1 nonbasic variables and m basic variables\n8  (N, B, A, b, c, v) = PIVOT(N, B, A, b, c, v, l, 0)\n9  // The basic solution is now feasible for L_{aux}\n10 iterate the while loop of lines 3~14 of SIMPLEX until an optimal solution\n       to L_{aux} is found\n11 if the optimal solution to L_{aux} sets x'_0 to 0\n12     if x'_0 is basic\n13         perform one (degenerate) pivot to make it nonbasic\n14     from the final slack form of L_{aux}, remove x_0 from the constaints and\n           restore the original objective function of L, but replace each basic\n           variable in this objective function by the right-hand side of its\n           associated constraint\n15     return the modified final slack form\n16 else\n17     return \"infeasible\"\n")])])]),e("p",[_._v("算法过程描述如下：")]),_._v(" "),e("ol",[e("li",[_._v("在 1～3 行，在给定 N 和 B，对于所有 i \\in B 有 "),e("code",[_._v("x'_i = b_i")]),_._v("，以及对于所有 j \\in N 有 "),e("code",[_._v("x'_j = 0")]),_._v(" 的条件下，隐含地测试 L 的初始松弛型的基本解。\n"),e("ul",[e("li",[_._v("如果第 2 行中发现这个基本解是可行的，即对所有的 i \\in N \\cup B 有 "),e("code",[_._v("x'_j >= 0")]),_._v("，则第 3 行返回这个松弛型。")]),_._v(" "),e("li",[_._v("否则，在第 4 行中，构造辅助线性规划 "),e("code",[_._v("L_{aux}")]),_._v("。")]),_._v(" "),e("li",[_._v("因为 L 的初始基本解是不可行的，所以 "),e("code",[_._v("L_{aux}")]),_._v(" 的松弛型的初始基本解也一定不可行。为了找到一个基本可行解，将执行一个主元 (pivot) 操作。")])])]),_._v(" "),e("li",[_._v("在 6 行，选择 l = n+k 作为基本变量的下标，该基本变量将是下面一个主元操作的替出变量。\n"),e("ul",[e("li",[_._v("因为基本变量是 "),e("code",[_._v("x_{n+1}, x_{n+2}, ..., x_{n+m}")]),_._v("，替出变量 "),e("code",[_._v("x_l")]),_._v(" 将是负值最大的变量。")])])]),_._v(" "),e("li",[_._v("在 8 行，执行对 "),e("code",[_._v("PIVOT")]),_._v(" 的调用，以 "),e("code",[_._v("x_0")]),_._v(" 为替入变量，"),e("code",[_._v("x_l")]),_._v(" 为替出变量。由此 "),e("code",[_._v("PIVOT")]),_._v(" 的调用产生的基本解是可行的。")]),_._v(" "),e("li",[_._v("在 10 行，现在有了一个基本解可行的松弛型，可以在第 10 行重复调用 "),e("code",[_._v("PIVOT")]),_._v(" 来完全求解出辅助线性规划。")]),_._v(" "),e("li",[_._v("在 11 行，测试是否找到了一个 "),e("code",[_._v("x_0")]),_._v(" 项为 0 的 "),e("code",[_._v("L_{aux}")]),_._v(" 的最优解，如果找到了，进入分支：\n"),e("ul",[e("li",[_._v("在 12～14 行，可以生成一个 L 的松弛型，其基本解是可行的。")]),_._v(" "),e("li",[_._v("为了做到这一点，首先在第 12～13 行处理退化情形，其中 "),e("code",[_._v("x_0")]),_._v(" 可能仍然是基本变量，其值为 "),e("code",[_._v("x'_0 = 0")]),_._v("。在此情形下，执行一个转动步骤把 "),e("code",[_._v("x_0")]),_._v(" 从基本解中移除，采用任何满足 "),e("code",[_._v("a_0e != 0")]),_._v(" 的 e \\in N 作为替入变量。")]),_._v(" "),e("li",[_._v("新的基本解仍然可行；退化转动没有改变任何变量的值。")]),_._v(" "),e("li",[_._v("下面从约束中删除所有 "),e("code",[_._v("x_0")]),_._v(" 项，并且恢复 L 的原始目标函数。原始目标函数可能包含了基本变量和非基本变量。")])])]),_._v(" "),e("li",[_._v("在 15 行，返回前述修改后的松弛型。")]),_._v(" "),e("li",[_._v("在 17 行，如果在 11 行发现初始线性规划 L 是不可行的，那么在第 16 行中返回这一信息。")])]),_._v(" "),e("h3",{attrs:{id:"initialize-simplex-的正确性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#initialize-simplex-的正确性"}},[_._v("#")]),_._v(" INITIALIZE_SIMPLEX 的正确性")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("引理 29.12")]),_._v("：如果一个线性规划 L 没有可行解，那么 "),e("code",[_._v("INITIALIZE_SIMPLEX")]),_._v(" 返回“不可行”；否则，它返回一个基本解可行的有效松弛型。")]),_._v(" "),e("h2",{attrs:{id:"线性规划基本定理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线性规划基本定理"}},[_._v("#")]),_._v(" 线性规划基本定理")]),_._v(" "),e("p",[_._v("这里说明过程 "),e("code",[_._v("SIMPLEX")]),_._v(" 的却有效。特别地，任何线性规划要么是不可行的，要么是无界的，要么有一个有限目标值的最优解。在每种情况下，"),e("code",[_._v("SIMPLEX")]),_._v(" 都能做出正确的操作。")]),_._v(" "),e("p",[_._v("《CLRS》"),e("strong",[_._v("定理 29.13")]),_._v("（"),e("strong",[_._v("线性规划基本定理")]),_._v("）：任何以标准型给出的线性规划 L 可能会是如下情形：")]),_._v(" "),e("ol",[e("li",[_._v("有一个有限目标值的最优解。")]),_._v(" "),e("li",[_._v("不可行。")]),_._v(" "),e("li",[_._v("无界。")])]),_._v(" "),e("p",[_._v("如果 L 是不可行的。"),e("code",[_._v("SIMPLEX")]),_._v(" 返回“不可行”。如果 L 是无界的，"),e("code",[_._v("SIMPLEX")]),_._v(" 返回无界。否则，"),e("code",[_._v("SIMPLEX")]),_._v(" 返回一个有限目标值的最优解。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("《CLRS》Chapter 29 思考题的一些概念：线性不等式的可行性、互补松弛性、整数线性规划、Farkas 引理、最小代价流通。")]),_._v(" "),e("h2",{attrs:{id:"代码范例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[_._v("#")]),_._v(" 代码范例")]),_._v(" "),e("h3",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[_._v("#")]),_._v(" Python")]),_._v(" "),e("p",[_._v("Python 环境：Python 3.7")]),_._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/other-topics/linear-programming/simplex.py",target:"_blank",rel:"noopener noreferrer"}},[_._v("GitHub Code Link"),e("OutboundLink")],1)]),_._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),e("ul",[e("li",[_._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 29")])])])}),[],!1,null,null,null);v.default=t.exports}}]);