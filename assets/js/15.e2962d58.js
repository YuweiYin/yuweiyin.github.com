(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{355:function(t,a,r){"use strict";r.r(a);var e=r(28),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"algorithm-sort-hashing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-sort-hashing"}},[t._v("#")]),t._v(" Algorithm - Sort - Hashing")]),t._v(" "),r("p",[t._v("Create Date: 2020.05.11")]),t._v(" "),r("p",[t._v("Last Update Date: 2020.05.11")]),t._v(" "),r("p",[t._v("By "),r("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),r("h3",{attrs:{id:"哈希散列-hashing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#哈希散列-hashing"}},[t._v("#")]),t._v(" 哈希散列 Hashing")]),t._v(" "),r("p",[t._v("许多应用都需要一种动态集合结构，它至少要支持 Insert、Search 和 Delete 这三种"),r("strong",[t._v("字典操作")]),t._v("。例如，用于程序语言编译的编译器维护了一个符号表，其中元素的关键字为任意字符串，它与程序中的标识符相对应。")]),t._v(" "),r("p",[r("strong",[t._v("散列表")]),t._v(" (Hash Table) 是实现字典操作的一种有效数据结构。尽管在最坏情况下，散列表中查找一个元素的时间与链表中查找的时间相同，达到了 "),r("code",[t._v("\\Theta(n)")]),t._v("。然而在"),r("strong",[t._v("实际应用")]),t._v("中，散列表"),r("strong",[t._v("查找的性能是极好的")]),t._v("。在一些"),r("strong",[t._v("合理的假设")]),t._v("下，在散列表中查找一个元素的平均时间是 O(1)。")]),t._v(" "),r("p",[t._v("散列表是普通数组概念的推广。由于对普通数组可以直接寻址，使得能在 O(1) 时间内访问数组中的任一位置。")]),t._v(" "),r("p",[t._v("散列是一种极其有效和实用的技术：基本的字典操作平均只需要 O(1) 的时间。")]),t._v(" "),r("p",[t._v("Python 语言中的内建 dict 字典类型即为一种哈希表。几乎所有的现代高级编程语言中均有内建的字典类型。")]),t._v(" "),r("h3",{attrs:{id:"直接寻址"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直接寻址"}},[t._v("#")]),t._v(" 直接寻址")]),t._v(" "),r("p",[t._v("当关键字的全域 U 比较小时，直接寻址是一种简单而有效的技术。假设某应用要用到一个动态集合，其中每个元素都是取自于全域 "),r("code",[t._v("U={0, 1, ..., m-1}")]),t._v(" 中的一个关键字 key，这里 m 不是一个很大的数。另外，假设没有两个元素具有相同的关键字。")]),t._v(" "),r("p",[t._v("为表示动态集合，用一个数组（"),r("strong",[t._v("直接寻址表")]),t._v(" direct-address table），记为 "),r("code",[t._v("T[0..m-1]")]),t._v("。其中每个位置，或称为 "),r("strong",[t._v("槽")]),t._v(" slot，对应全域 U 中的一个关键字 key。下图描绘了此方法，槽 k 指向集合中一个关键字为 k 的元素。如果该集合中没有关键字为 k 的元素，则 "),r("code",[t._v("T[k]=NIL")]),t._v("。")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/hashing-1.png",alt:"hashing-1"}})]),t._v(" "),r("p",[t._v("如果存储空间允许，可以提供一个数组，为每个可能的关键字保留一个位置，以利用直接寻址技术的优势。")]),t._v(" "),r("p",[t._v("在直接寻址表中，实现字典操作很简单：")]),t._v(" "),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("p",[t._v("上述每一个操作都只需要 O(1) 的时间。")]),t._v(" "),r("p",[t._v("对于某些应用，直接寻址表本身就可以存放动态集合中的元素。即，并"),r("strong",[t._v("不")]),t._v("把每个元素的关键字及其附带的卫星数据都放在直接寻址表外部的一个对象中，再由表中某个槽的指针指向该对象。而是直接把该对象存放在直接寻址表的槽中，从而节省了空间。")]),t._v(" "),r("p",[t._v("使用对象内的一个特殊关键字来表明该槽为空槽即可。而且，通常可不必存储该对象的关键字属性，因为如果知道一个对象在表中的下标，就可以得到它的关键字（因为二者之间是双射）。然而，如果不存储关键字，我们就必须要有某种方法来确定某个槽是否为空槽。")]),t._v(" "),r("p",[r("strong",[t._v("位向量")]),t._v(" (bit vector) 是一个仅包含 0 和 1 的数组。长度为 m 的位向量所占的空间要比包含 m 个指针的数组少得多，因此可以利用一个位向量来表示一个包含不同元素（无附带的卫星数据）的动态集合，在其上的字典操作的运行时间为 O(1)。")]),t._v(" "),r("p",[t._v("如果想要在一个"),r("strong",[t._v("非常大")]),t._v("的数组上，通过直接寻址的方式实现一个字典，对整个数组进行初始化是不太实际的。但是可以利用一个附加数组，其处理方式类似于栈，其大小等于实际存储在字典中的关键字数目，以辅助确定大数组中某个给定的项是否有效。从而也能达到每个操作（初始化、搜索、插入、删除）的时间为 O(1)，并且每个存储对象占用 O(1) 的空间。")]),t._v(" "),r("h3",{attrs:{id:"散列表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#散列表"}},[t._v("#")]),t._v(" 散列表")]),t._v(" "),r("p",[t._v("直接寻址技术的缺点是非常明显的：如果全域 U 很大，则在一台标准的计算机可用内存容量中，要存储大小为 "),r("code",[t._v("|U|")]),t._v(" 的一张表 T 也许不太实际，甚至是无法做到的。另外，实际存储的关键字集合 K 相对于 U 来说可能很小，使得分配给 T 的大部分空间都将被浪费掉。")]),t._v(" "),r("p",[t._v("当实际存储的关键字数目 K 比全部可能的关键字总数 U 要小许多时，采用散列表就能成为直接数组寻址的一种有效替代。因为散列表使用一个长度与实际存储的关键字数目成比例的数组来存储，能将散列表的存储需求降至 "),r("code",[t._v("\\Theta (|K|)")]),t._v("，同时散列表中查找一个元素的优势仍然得到保持，平均只需要 O(1) 的时间。")]),t._v(" "),r("p",[t._v("在直接寻址方式下，具有关键字 k 的元素被存放在槽 k 中。在散列表中，不是直接把关键字作为数组的下标，而是根据关键字（利用"),r("strong",[t._v("散列函数")]),t._v(" hash function）计算出相应的槽下标 h(k)。哈希函数 h 将关键字 k 的全域 U 映射到散列表 "),r("code",[t._v("T[0..m-1]")]),t._v(" 的各槽位上，而 m 一般远小于 "),r("code",[t._v("|U|")]),t._v("。可以说一个具有关键字 k 的元素被 "),r("strong",[t._v("散列")]),t._v(" 到槽 h(k) 上，也可以说 h(k) 是关键字 k 的 "),r("em",[r("strong",[t._v("散列值")])]),t._v("。")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/hashing-2.png",alt:"hashing-2"}})]),t._v(" "),r("h3",{attrs:{id:"链接法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链接法"}},[t._v("#")]),t._v(" 链接法")]),t._v(" "),r("p",[t._v("所谓冲突，就是指多个关键字映射到散列表的同一个下标。即 h(k1) = h(k2)，其中 k1 != k2。")]),t._v(" "),r("p",[t._v("散列表解决 "),r("strong",[t._v("碰撞/冲突")]),t._v(" (collision) 的最简单方式就是 "),r("strong",[t._v("链接")]),t._v(" (chaining) 方法。链接法与 "),r("strong",[r("a",{attrs:{href:"../sort/linear-time-sort"}},[t._v("桶排序")])]),t._v(" (Bucket Sort) 类似，散列表中的一个槽就类似于桶排序中的一个桶。")]),t._v(" "),r("h3",{attrs:{id:"开放寻址法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开放寻址法"}},[t._v("#")]),t._v(" 开放寻址法")]),t._v(" "),r("p",[t._v("开放寻址法 Open Addressing 是处理冲突的另一种方法。")]),t._v(" "),r("h3",{attrs:{id:"完全散列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#完全散列"}},[t._v("#")]),t._v(" 完全散列")]),t._v(" "),r("p",[t._v("完全散列 Perfect Hashing。当关键字集合时静态存储（即关键字集合一旦存入后就不再改变，没有 insert 和 delete 操作，只有 search 操作），完全散列能够在 O(1) 的最坏时间内完成关键字查找。")]),t._v(" "),r("h2",{attrs:{id:"场景描述及分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#场景描述及分析"}},[t._v("#")]),t._v(" 场景描述及分析")]),t._v(" "),r("h3",{attrs:{id:"示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[t._v("#")]),t._v(" 示例")]),t._v(" "),r("h2",{attrs:{id:"设计-细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[t._v("#")]),t._v(" 设计 & 细节")]),t._v(" "),r("h3",{attrs:{id:"算法流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法流程"}},[t._v("#")]),t._v(" 算法流程")]),t._v(" "),r("h3",{attrs:{id:"实现细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现细节"}},[t._v("#")]),t._v(" 实现细节")]),t._v(" "),r("h2",{attrs:{id:"代码范例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),r("h3",{attrs:{id:"python"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),r("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("注")]),t._v("：\n"),r("ul",[r("li",[t._v("排序算法的基类 Sort 和元素结构体类 Element 写法与 "),r("a",{attrs:{href:"./sort-base-class"}},[t._v("此文章")]),t._v(" 完全相同，故不在下方赘述。")]),t._v(" "),r("li",[t._v("如果要运行此代码，则还需先将 Sort 类和 Element 类置于本代码中。")]),t._v(" "),r("li",[t._v("Element 类完全可以根据程序需求来自定义，但是需要给出该类中的 key 和 value 属性名。")])])])]),t._v(" "),r("h3",{attrs:{id:"桶排序-bucket-sort"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#桶排序-bucket-sort"}},[t._v("#")]),t._v(" 桶排序 Bucket Sort")]),t._v(" "),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 11")]),t._v(" "),r("li",[t._v("MIT 6.006 Introduction to Algorithms, Fall 2011\n"),r("ul",[r("li",[r("ol",{attrs:{start:"8"}},[r("li",[r("a",{attrs:{href:"https://www.youtube.com/watch?v=0M_kIqhwbFo",target:"_blank",rel:"noopener noreferrer"}},[t._v("Hashing with Chaining"),r("OutboundLink")],1)])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"9"}},[r("li",[r("a",{attrs:{href:"https://www.youtube.com/watch?v=BRO7mVIFt08",target:"_blank",rel:"noopener noreferrer"}},[t._v("Table Doubling, Karp-Rabin"),r("OutboundLink")],1)])])]),t._v(" "),r("li",[r("ol",{attrs:{start:"10"}},[r("li",[r("a",{attrs:{href:"https://www.youtube.com/watch?v=rvdJDijO2Ro",target:"_blank",rel:"noopener noreferrer"}},[t._v("Open Addressing, Cryptographic Hashing"),r("OutboundLink")],1)])])])])]),t._v(" "),r("li",[t._v("MIT 6.046J Design and Analysis of Algorithms, Spring 2015\n"),r("ul",[r("li",[r("ol",{attrs:{start:"8"}},[r("li",[t._v("Randomization: "),r("a",{attrs:{href:"https://www.youtube.com/watch?v=z0lJ2k0sl1g",target:"_blank",rel:"noopener noreferrer"}},[t._v("Universal & Perfect Hashing"),r("OutboundLink")],1)])])])])]),t._v(" "),r("li",[t._v("MIT 6.854J Advanced Algorithms\n"),r("ul",[r("li",[t._v("Lecture 06, 09/18: "),r("a",{attrs:{href:"https://www.youtube.com/watch?v=z8DD-ikAjzM",target:"_blank",rel:"noopener noreferrer"}},[t._v("Hashing"),r("OutboundLink")],1)])])]),t._v(" "),r("li",[t._v("MIT 6.854 (Advanced Algorithms), Spring 2016\n"),r("ul",[r("li",[t._v("Lecture 3: "),r("a",{attrs:{href:"https://www.youtube.com/watch?v=hM547xRIdzc",target:"_blank",rel:"noopener noreferrer"}},[t._v("Consistent Hashing and Random Trees"),r("OutboundLink")],1)])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);