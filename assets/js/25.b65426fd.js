(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{296:function(t,a,r){"use strict";r.r(a);var _=r(28),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"algorithm-sort-string"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-sort-string"}},[t._v("#")]),t._v(" Algorithm - Sort - String")]),t._v(" "),r("p",[t._v("Create Date: 2020.05.12")]),t._v(" "),r("p",[t._v("Last Update Date: 2020.05.12")]),t._v(" "),r("p",[t._v("By "),r("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),r("p",[t._v("String 字符串相关数据结构与算法")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/string-1.png",alt:"string-1"}})]),t._v(" "),r("p",[t._v("String Matching 字符串匹配任务（子串匹配）。搜索引擎、文本编辑器的 Find 搜索功能、Unix 中的 grep 命令等各种应用都会使用到字符串匹配算法。")]),t._v(" "),r("p",[t._v("这里假设 "),r("strong",[t._v("文本")]),t._v(" document 是一个长度为 n 的数组，T[0..n-1]，而 "),r("strong",[t._v("模式")]),t._v(" pattern string 是一个长度为 m 的数组 P[0..m-1]，其中 m <= n，进一步假设 P 和 T 的元素都是来自于一个 "),r("strong",[t._v("有限字母集")]),t._v(" "),r("code",[t._v("\\Sum")]),t._v(" 的字符。例如 "),r("code",[t._v("\\Sum = {0, 1}")]),t._v(" 或者 "),r("code",[t._v("\\Sum = {a, b, ..., z}")]),t._v("。字符数组 P 和 T 通常被称为 "),r("strong",[t._v("字符串")]),t._v("。")]),t._v(" "),r("p",[t._v("（后文也用 doc 表示长度为 n 的长文本字符串，ptn 表示长度为 m 的待匹配的模式字符串）")]),t._v(" "),r("h2",{attrs:{id:"朴素字符串匹配算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#朴素字符串匹配算法"}},[t._v("#")]),t._v(" 朴素字符串匹配算法")]),t._v(" "),r("p",[t._v("朴素字符串匹配算法是通过一个循环找到所有有效偏移，该循环对 n-m+1 个可能的子串起始位置 s 值进行检测，查看是否满足条件 P[0..m-1] = T[s..s+m-1]，伪代码如下：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("NAIVE-STRING-MATCHER(T, P)\n1 n = T.length\n2 m = P.length\n3 for s = 0 to n-m\n4     if P[0..m] == T[s..s+m-1]\n5         return s\n")])])]),r("p",[t._v("时间复杂度为 O(m(n-m+1))")]),t._v(" "),r("h2",{attrs:{id:"rabin-karp-algorithm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabin-karp-algorithm"}},[t._v("#")]),t._v(" Rabin-Karp Algorithm")]),t._v(" "),r("p",[t._v("在朴素字符串匹配算法的基础上，利用"),r("a",{attrs:{href:"./hashing"}},[t._v("哈希散列技术")]),t._v("，可设计出实际应用中效果良好的 Rabin-Karp 算法。该算法利用了初等数论的一些概念，比如两个数相对于第三个数模等价。")]),t._v(" "),r("p",[t._v("Rabin-Karp 算法需要进行 "),r("code",[t._v("\\Theta(m)")]),t._v(" 时间的预处理。在最坏情况下，整体的运行时间是 "),r("code",[t._v("\\Theta((n-m+1)m)")]),t._v("，但是基于一些假设，在平均情况下，它的运行时间还是比较好的。")]),t._v(" "),r("p",[t._v("该算法将朴素匹配中检查字符串相等的操作，改为哈希表的增/删/查操作。朴素匹配中可以看作是一个长度为 m 的窗口滑过长度为 n 的文档，如果把这个滑动窗口看作是一个动态变化的哈希表，则可以将整体匹配的时间复杂度降到 O(n+m)。")]),t._v(" "),r("p",[t._v("尽管字符串的空间特别大，但是构成字符串的字符数量是比较有限的。")]),t._v(" "),r("p",[t._v("而且此算法处理全局查找（而不是仅找到第一个匹配的）时效率也很高。")]),t._v(" "),r("p",[t._v("观察：当哈希表在文档上滑动时，连续两步之间共享了 m-1 个相同字符，如果能够利用这个特性，让变化后的哈希表计算哈希值的时间（从本应的 O(m)）缩减为 O(1)，则能够达到迅速搜索的目标。")]),t._v(" "),r("p",[t._v("设计此哈希表为抽象数据类型 (Abstract Data Type, ADT)，名为 Rolling Hash Table，简写作 rht。")]),t._v(" "),r("p",[t._v("rht 维护一个字符串 x。rht 执行下面三个函数，时间复杂度均为 O(1)")]),t._v(" "),r("ul",[r("li",[t._v("rht.append(c) 往 x 尾部追加字符 c。模拟往右滑动时，窗口右侧新增的字符。")]),t._v(" "),r("li",[t._v("rht.skip() 删除 x 的首部字符。模拟往右滑动时，窗口左侧丢弃的字符。\n"),r("ul",[r("li",[t._v("类似于 Python list 中的 "),r("code",[t._v("pop(0)")]),t._v(" 或者 collections 中的 "),r("code",[t._v("popleft()")]),t._v("。")])])]),t._v(" "),r("li",[t._v("rht.h(x) 计算字符串 x 的哈希值。")])]),t._v(" "),r("p",[t._v("算法思路如下：")]),t._v(" "),r("ol",[r("li",[t._v("实例化两个 rht 对象 r_doc 和 r_ptn")]),t._v(" "),r("li",[t._v("预处理（耗时 O(m)）：将 ptn 和首个窗口中的各字符转为数字")]),t._v(" "),r("li",[t._v("将模式串 ptn 中的每个字符加入到 r_ptn 中，计算出这 m 个字符组成的字符串（即 ptn）的哈希值 h_ptn = r_ptn.h(x)")]),t._v(" "),r("li",[t._v("将 doc 中的前 m 个字符添加到 r_doc 中，并计算出这前 m 个字符组成的字符串的哈希值 h_doc = r_doc.h(x)")]),t._v(" "),r("li",[t._v("循环：判断哈希值 h_ptn 是否等于 h_doc\n"),r("ul",[r("li",[t._v("A: if 如果相等\n"),r("ul",[r("li",[t._v("此时只能表示两串的哈希值相同，不一定代表这两串一定相同，因为可能会有碰撞冲突。")]),t._v(" "),r("li",[t._v("因此此时需要逐字符检测是否匹配，耗时 O(m)。如果此时匹配成功，函数返回 return；否则往下执行 B 过程")])])]),t._v(" "),r("li",[t._v("B: if 如果不相等，且检索到了尾部，匹配失败，跳出循环 break")]),t._v(" "),r("li",[t._v("C: else 否则\n"),r("ul",[r("li",[t._v("从 r_doc 中移除最左字符，r_doc.skip()")]),t._v(" "),r("li",[t._v("在右侧追加一个字符，r_doc.append(next_c)")]),t._v(" "),r("li",[t._v("重新计算哈希值，h_doc = r_doc.h(x')，继续循环 loop")]),t._v(" "),r("li",[t._v("（核心是要利用重复的信息，保证在 O(1) 时间内计算新串的哈希值）")])])])])]),t._v(" "),r("li",[t._v("匹配成功则返回模式串所在起始下标，否则返回 -1")])]),t._v(" "),r("p",[t._v("因此最坏情况是：长文本 doc 中 所有窗口里的字符串哈希值都和 ptn 模式串的哈希值相等，但是它们实际又不完全逐字符完全匹配，这样每个窗口都要耗费 O(m) 的时间去逐字符匹配，导致总时间为 O((n-m+1)m)。但只要"),r("a",{attrs:{href:"./hashing"}},[t._v("处理好哈希函数")]),t._v("，就能很大程度减少冲突（让冲突出现的概率不超过 1/m，这样逐字符匹配的期望时间就是 O(1)），从而达到 Rabin-Karp 算法的平均时间复杂度 O(n+m)。")]),t._v(" "),r("p",[t._v("Rabin 和 Karp 证明了，即便是最简单的 Division Hashing 除法散列哈希函数 "),r("code",[t._v("h(k) = k \\mod p")]),t._v("，只要 p 是大于等于 m（模式串长度）的 random prime 随机选择的素数，那么此算法就能高效执行。而且 p 选择得越大，哈希冲突出现的概率就越小。")]),t._v(" "),r("p",[t._v("一般而言，模式串 ptn 不会太长，所以大于 m 的素数是容易找到的。至于寻找相当大的素数，可以参考《CLRS》第 31 章"),r("em",[t._v("数论算法")]),t._v("中的 31.8 节"),r("em",[t._v("素数的测试")]),t._v("。")]),t._v(" "),r("h2",{attrs:{id:"设计-细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[t._v("#")]),t._v(" 设计 & 细节")]),t._v(" "),r("h3",{attrs:{id:"算法流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法流程"}},[t._v("#")]),t._v(" 算法流程")]),t._v(" "),r("h3",{attrs:{id:"实现细节"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现细节"}},[t._v("#")]),t._v(" 实现细节")]),t._v(" "),r("h2",{attrs:{id:"代码范例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),r("h3",{attrs:{id:"python"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),r("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),r("h3",{attrs:{id:"朴素字符串匹配算法-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#朴素字符串匹配算法-2"}},[t._v("#")]),t._v(" 朴素字符串匹配算法")]),t._v(" "),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("h3",{attrs:{id:"rabin-karp-algorithm-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rabin-karp-algorithm-2"}},[t._v("#")]),t._v(" Rabin-Karp Algorithm")]),t._v(" "),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("h3",{attrs:{id:"knuth-morris-pratt-algorithm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#knuth-morris-pratt-algorithm"}},[t._v("#")]),t._v(" Knuth-Morris-Pratt Algorithm")]),t._v(" "),r("div",{staticClass:"language-python extra-class"},[r("pre",{pre:!0,attrs:{class:"language-python"}},[r("code",[t._v("\n")])])]),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),r("ul",[r("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 32")]),t._v(" "),r("li",[t._v("MIT 6.006 Introduction to Algorithms, Fall 2011\n"),r("ul",[r("li",[r("ol",{attrs:{start:"9"}},[r("li",[r("a",{attrs:{href:"https://www.youtube.com/watch?v=BRO7mVIFt08",target:"_blank",rel:"noopener noreferrer"}},[t._v("Table Doubling, Karp-Rabin"),r("OutboundLink")],1)])])])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);