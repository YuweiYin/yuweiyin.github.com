(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{273:function(t,a,s){"use strict";s.r(a);var e=s(28),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"algorithm-data-structure-treap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-treap"}},[t._v("#")]),t._v(" Algorithm - Data Structure - Treap")]),t._v(" "),s("p",[t._v("By "),s("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),s("p",[t._v("堆树/树堆 Treap 是由 Seidel 和 Aragon 提出的。它是 LEDA 内字典的默认实现，LEDA 是一组精心实现的数据结构和算法。")]),t._v(" "),s("p",[t._v("如果讲一个含 n 个元素的集合插入到一棵"),s("a",{attrs:{href:"./binary-search-tree"}},[t._v("二叉搜索树")]),t._v(" (Binary Sort/Search Tree, BST) 中，所得到的树可能会相当不平衡，从而导致操作时间变为线性时间复杂度 O(n)。"),s("strong",[t._v("随机构造")]),t._v("二叉搜索树是"),s("strong",[t._v("趋向于平衡的")]),t._v("。因此，一般来说，要为一组固定的元素建立一棵平衡树，可以采用一种策略就是"),s("strong",[t._v("先随机排列")]),t._v("这些元素，然后按照排列的顺序将它们插入到树中。")]),t._v(" "),s("p",[t._v("但是，如果没法同时得到所有的元素，应该如何处理？如果一次收到一个元素，是否仍然能用它们来随机建立一棵二叉搜索树？")]),t._v(" "),s("p",[t._v("一棵 Treap 树是一棵更改了结点排列方式的二叉搜索树。通常，树内的每个结点 x 都有一个关键字值 x.key，用于 BST 排序。另外，还要为每个结点指定 x.priority，它是一个独立选取的随机数。假设所有的优先级都是不同的，而且所有的关键字也是不同的。Treap 树的结点被排列成让关键字遵循二叉搜索树的性质，且优先级遵循最小堆顺序性质：")]),t._v(" "),s("ul",[s("li",[t._v("如果 v 是 u 的左孩子，则 v.key < u.key")]),t._v(" "),s("li",[t._v("如果 v 是 u 的右孩子，则 v.key > u.key")]),t._v(" "),s("li",[t._v("如果 v 是 u 的孩子，则 v.priority > u.priority")])]),t._v(" "),s("p",[t._v("这两个性质的结合就是这种树被称为 Treap 树的原因：它同时具有二叉搜索树和堆的特征。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/treap-1.png",alt:"treap-1"}})]),t._v(" "),s("p",[t._v("假设将已有相应关键字 key 的结点 x1, x2, ..., xn 插入到一棵 Treap 树内，得到的 Treap 树是通过将这些结点及其优先级（"),s("strong",[t._v("随机")]),t._v("选取的值）顺序插入一棵正常的二叉搜索树形成的，即 xi.priority < xj.priority 表示 xi 在 xj 之前被插入。")]),t._v(" "),s("p",[t._v("可以证明：")]),t._v(" "),s("ul",[s("li",[t._v("给定一个已有的相应关键字 key 和优先级 priority（互异）的结点 x1, x2, ..., xn 组成的集合，存在唯一的一棵 Treap 树与这些结点相关联。")]),t._v(" "),s("li",[t._v("Treap 树的期望高度是 O(log n)，因此在 Treap 内查找一个值所花的时间为 O(log n)。")])]),t._v(" "),s("p",[t._v("要将一个新的结点插入到一个已存在的 Treap 树中，要做的第一件事就是将一个随机的优先级赋予这个新结点。然后调用 treap-insert 插入算法，其操作如图所示。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/treap-2.png",alt:"treap-2"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/treap-3.png",alt:"treap-3"}})]),t._v(" "),s("p",[t._v("可以证明：treap-insert 插入算法的期望运行时间是 O(log n)。当在一棵 Treap 树中插入一个结点时，执行旋转的期望次数小于 2。")]),t._v(" "),s("p",[t._v("定义一棵 BST 的"),s("strong",[t._v("左脊柱")]),t._v("（left spine）是从根结点到有最小关键字 key 的结点的简单路径。换句话说，左脊柱是从根结点开始只包含左边缘的简单路径。对称地，BST 的"),s("strong",[t._v("右脊柱")]),t._v("（right spine）是从根结点开始只包含右边缘的简单路径。一条脊柱的长度是它包含的结点数目。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/treap-4.png",alt:"treap-4"}})]),t._v(" "),s("h2",{attrs:{id:"设计-细节"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[t._v("#")]),t._v(" 设计 & 细节")]),t._v(" "),s("h3",{attrs:{id:"建立-treap-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#建立-treap-树"}},[t._v("#")]),t._v(" 建立 Treap 树")]),t._v(" "),s("p",[t._v("以 kv_array 中的每个元素为 [key, value] 数组，构建树结点。树结点设计如下：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" priority"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 键，按键构造 BST 树，并进行搜索/增添/删除")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 值，树结点存储的值，可以为任意对象")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("priority "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" priority   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 结点的优先级，用于构建最小堆")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 左孩子指针")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 右孩子指针")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 父结点指针")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("is_left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# True 则表示自己是父结点的左孩子(默认)，否则为右孩子")]),t._v("\n")])])]),s("p",[t._v("Treap 类成员属性如下（这里利用的是最小堆，但最大堆也可以）：")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Treap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 构造 Treap")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" kv_array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bst "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 二叉搜索树结构，树根")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("inf "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0x3f3f3f3f")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 0..inf 是优先级的随机选择范围")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("used_priority "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 集合，存储当前已经使用过的优先级")]),t._v("\n        self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sorted_key_list "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 已排好序的 key 列表")]),t._v("\n")])])]),s("p",[t._v("与 "),s("a",{attrs:{href:"avl-tree"}},[t._v("AVL")]),t._v("、"),s("a",{attrs:{href:"./red-black-tree"}},[t._v("RBT")]),t._v(" 树的建立方式相同，Treap 也是循环调用插入函数，逐步建立 Treap 树。时间复杂度 O(n log n)")]),t._v(" "),s("h3",{attrs:{id:"搜索"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#搜索"}},[t._v("#")]),t._v(" 搜索")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("treap_search")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" search_key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"辅助操作：左旋"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：左旋"}},[t._v("#")]),t._v(" 辅助操作：左旋")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("left_rotate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node_x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("与 RBT 的左旋操作完全相同。只有 AVL 树在旋转时要维护结点的高度属性")]),t._v(" "),s("li",[t._v("对 node 结点 x 而言，将 x 左旋，意味着：\n"),s("ul",[s("li",[t._v("让 x 的右孩子 y (x.right) 成为 x 的父结点，且 x 等于 y.left。")]),t._v(" "),s("li",[t._v("而 y 结点原本的左孩子变为新 x 的右孩子")]),t._v(" "),s("li",[t._v("注意：如果将 BST 树根旋下来了，则需要更换树根")])])])]),t._v(" "),s("h3",{attrs:{id:"辅助操作：右旋"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：右旋"}},[t._v("#")]),t._v(" 辅助操作：右旋")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("right_rotate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node_x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("与 RBT 的右旋操作完全相同。只有 AVL 树在旋转时要维护结点的高度属性")]),t._v(" "),s("li",[t._v("对 node 结点 x 而言，将 x 右旋，意味着：\n"),s("ul",[s("li",[t._v("让 x 的左孩子 y (x.left) 成为 x 的父结点，且 x 等于 y.right。")]),t._v(" "),s("li",[t._v("而 y 结点原本的右孩子变为新 x 的左孩子")]),t._v(" "),s("li",[t._v("注意：如果将 BST 树根旋下来了，则需要更换树根")])])])]),t._v(" "),s("h3",{attrs:{id:"辅助操作：新建并返回具有随机优先级的结点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：新建并返回具有随机优先级的结点"}},[t._v("#")]),t._v(" 辅助操作：新建并返回具有随机优先级的结点")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("create_new_node")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" new_key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" new_val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"辅助操作：插入结点后维护最小堆性质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：插入结点后维护最小堆性质"}},[t._v("#")]),t._v(" 辅助操作：插入结点后维护最小堆性质")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("_treap_priority_fixup")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("ul",[s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("h3",{attrs:{id:"插入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入"}},[t._v("#")]),t._v(" 插入")]),t._v(" "),s("ul",[s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("treap_insert")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" insert_key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" insert_val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"删除"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除"}},[t._v("#")]),t._v(" 删除")]),t._v(" "),s("ul",[s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("treap_delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" delete_key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("实际执行的删除函数，可能递归")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("_treap_delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" delete_key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"最小值-min-bst-root"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最小值-min-bst-root"}},[t._v("#")]),t._v(" 最小值 min_bst(root)")]),t._v(" "),s("ul",[s("li",[t._v("找到一棵以 root 为根的 BST/Treap 中的最小值结点（一路向左）")]),t._v(" "),s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("h3",{attrs:{id:"最大值-max-bst-root"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最大值-max-bst-root"}},[t._v("#")]),t._v(" 最大值 max_bst(root)")]),t._v(" "),s("ul",[s("li",[t._v("找到一棵以 root 为根的 BST/Treap 中的最大值结点（一路向右）")]),t._v(" "),s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("h3",{attrs:{id:"前驱-predecessor-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前驱-predecessor-node"}},[t._v("#")]),t._v(" 前驱 predecessor(node)")]),t._v(" "),s("ul",[s("li",[t._v("找到在 BST 中 node 结点的前驱结点，即：其左子树中的最大值")]),t._v(" "),s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("h3",{attrs:{id:"后继-successor-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后继-successor-node"}},[t._v("#")]),t._v(" 后继 successor(node)")]),t._v(" "),s("ul",[s("li",[t._v("找到在 BST 中 node 结点的后继结点，即：其右子树中的最小值")]),t._v(" "),s("li",[t._v("时间复杂度 O(log n) 与树高有关")])]),t._v(" "),s("h3",{attrs:{id:"检测是否为-bst-check-bst-root"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#检测是否为-bst-check-bst-root"}},[t._v("#")]),t._v(" 检测是否为 BST check_bst(root)")]),t._v(" "),s("ul",[s("li",[t._v("检查一棵以 root 为根的二叉树是否为 BST")]),t._v(" "),s("li",[t._v("时间复杂度 O(n)")])]),t._v(" "),s("h2",{attrs:{id:"代码范例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),s("h3",{attrs:{id:"python"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),s("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/treap.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("ul",[s("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 13 思考题 13-4")])])])}),[],!1,null,null,null);a.default=r.exports}}]);