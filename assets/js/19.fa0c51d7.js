(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{295:function(t,e,a){"use strict";a.r(e);var r=a(28),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"algorithm-data-structure-interval-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-interval-tree"}},[t._v("#")]),t._v(" Algorithm - Data Structure - Interval Tree")]),t._v(" "),a("p",[t._v("Create Date: 2020.05.24")]),t._v(" "),a("p",[t._v("Last Update Date: 2020.05.25")]),t._v(" "),a("p",[t._v("By "),a("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[t._v("区间树 (Interval Tree)")]),t._v(" "),a("p",[t._v("与 "),a("a",{attrs:{href:"./order-statistic-tree"}},[t._v("顺序统计树")]),t._v(" (Order Statistic Tree, OST) 相似，区间树也是基于 "),a("a",{attrs:{href:"./red-black-tree"}},[t._v("红黑树")]),t._v(" (Red Black Tree, RBT) 数据结构的扩张，用于支持由区间构成的动态集合上的一些操作。")]),t._v(" "),a("p",[t._v("实数域 R 上的 "),a("strong",[t._v("闭区间")]),t._v(" (closed interval) 是一个实数的有序对 [t1, t2]，其中 t1 <= t2。区间 [t1, t2] 表示了集合 $ {t \\in R: t1 <= t <= t2} $。"),a("strong",[t._v("开")]),t._v("(open)区间 和 "),a("strong",[t._v("半开")]),t._v("(half-open)区间 分别略去了集合的两个和一个端点。在此后的讨论中，均假设区间都是闭的。")]),t._v(" "),a("p",[t._v("区间便于表示占用一个连续时间段的一些事件。例如：查询一个由时间区间数据（左右断点 pair）构成的数据库，找出给定时间区间内发生了什么事件。")]),t._v(" "),a("h2",{attrs:{id:"设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计"}},[t._v("#")]),t._v(" 设计")]),t._v(" "),a("p",[t._v("把闭区间 [t1, t2] 表示成一个对象 inter，其中属性 inter.low = t1 为"),a("strong",[t._v("低端点")]),t._v("(low endpoint)，属性 inter.high = t2 为"),a("strong",[t._v("高端点")]),t._v("(high endpoint)。如果两个对象 inter1 和 inter2 的区间"),a("strong",[t._v("交集不为空")]),t._v("，则称这两个"),a("strong",[t._v("区间重叠")]),t._v("(overlap)。对对象属性而言，重叠意味着 inter1.low <= inter2.high 并且 inter2.low <= inter1.high。")]),t._v(" "),a("p",[t._v("任何两个区间 inter1 和 inter2 满足"),a("strong",[t._v("区间三分律")]),t._v(" (interval trichotomy)，即下述三条性质有且仅有其一成立：")]),t._v(" "),a("ol",[a("li",[t._v("inter1 和 inter2 重叠。\n"),a("ul",[a("li",[t._v("即：inter1.low <= inter2.high 并且 inter2.low <= inter1.high")])])]),t._v(" "),a("li",[t._v("inter1 在 inter2 左边。\n"),a("ul",[a("li",[t._v("即：inter1.high < inter2.low")])])]),t._v(" "),a("li",[t._v("inter1 在 inter2 右边。\n"),a("ul",[a("li",[t._v("即：inert1.low > inter2.high")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/interval-tree-1.png",alt:"interval-tree-1"}})]),t._v(" "),a("p",[t._v("区间查询 Range Query 任务中，与区间树类似的比如 "),a("a",{attrs:{href:"./segment-tree"}},[t._v("线段树")]),t._v(" (Segment Tree, ST)。但线段树一般是针对静态的数据，一旦数据量变化，就需要花费 O(n) 的时间重建。而区间树是一种基于红黑树的动态集合数据结构。")]),t._v(" "),a("p",[t._v("区间树中每个树结点 x 都包含一个区间属性 inter，此属性可以设置为一个元组对象 tuple 或者一种新的结构体对象，视具体需求而定。")]),t._v(" "),a("p",[t._v("区间树主要支持如下操作：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("interval_insert(T, x)")]),t._v(" "),a("ul",[a("li",[t._v("将包含区间属性 inter 的元素 x 插入到区间树 T 中")])])]),t._v(" "),a("li",[a("code",[t._v("interval_delete(T, x)")]),t._v(" "),a("ul",[a("li",[t._v("从区间树 T 中删除元素 x")])])]),t._v(" "),a("li",[a("code",[t._v("interval_search(T, target_inter)")]),t._v(" "),a("ul",[a("li",[t._v("返回一个指向区间树 T 中元素 x 的指针，使 x.inter 与 target_inter 重叠")]),t._v(" "),a("li",[t._v("若此元素不存在，则返回 None")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/interval-tree-2.png",alt:"interval-tree-2"}})]),t._v(" "),a("h3",{attrs:{id:"扩张步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩张步骤"}},[t._v("#")]),t._v(" 扩张步骤")]),t._v(" "),a("ol",[a("li",[t._v("基础数据结构：\n"),a("ul",[a("li",[t._v("选择红黑树作为基础数据结构，其每个结点 x 包含一个区间属性 x.inter，且 x 的关键字 key 为区间的低端点 x.inter.low。")]),t._v(" "),a("li",[t._v("因此，该数据结构按中序遍历列出的就是按低端点的次序排列的各区间。")])])]),t._v(" "),a("li",[t._v("附加信息：\n"),a("ul",[a("li",[t._v("每个结点 x 中除了自身的区间信息 以及红黑树本身的信息外，还包含一个数值 x.max，表示以 x 为根的子树中所有区间端点的最大值。")])])]),t._v(" "),a("li",[t._v("对信息的维护：\n"),a("ul",[a("li",[t._v("通过给定区间的 x.inter 和结点 x 的子结点的 max 值，可以确定 x.max 值")]),t._v(" "),a("li",[t._v("x.max = max(x.inter.high, x.left.max, x.right.max)")]),t._v(" "),a("li",[t._v("由于更新 x 的附加信息仅依赖于本结点及其孩子结点 这 3 个结点的信息，所以可以保证插入和删除时对附加信息的维护也是 O(log n) 时间的。")])])]),t._v(" "),a("li",[t._v("设计新的操作：\n"),a("ul",[a("li",[t._v("对于插入和删除，只需维护 max 信息即可")]),t._v(" "),a("li",[t._v("利用附加信息 max，可以设计的新操作是 "),a("code",[t._v("interval_search(T, target_inter)")]),t._v(" 找出区间树 T 中与区间 target_inter 重叠的那个结点。若此元素不存在，则返回 None")])])])]),t._v(" "),a("h3",{attrs:{id:"建立区间树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立区间树"}},[t._v("#")]),t._v(" 建立区间树")]),t._v(" "),a("p",[t._v("以 kv_array 中的每个元素为 [key, value] 数组，构建树结点。树结点设计如下：")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" inter_low"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" inter_high"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" color"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" inter_low  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 键，区间树的关键字 key 即为区间的低端点")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 值，树结点存储的值，可以为任意对象")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("color "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" color    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 结点的颜色，True 代表红色(默认)，False 代表黑色")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 左孩子指针")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 右孩子指针")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 父结点指针")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v("'''上面是红黑树原本的所需的树结点属性'''")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v("'''下面是顺序统计树扩张红黑树功能所需的属性'''")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("inter "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("inter_low"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" inter_high"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# interval 区间属性 (这里默认为闭区间)")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("max_end "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" inter_high             "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 以本结点为根的子树的 所有区间端点的最大值")]),t._v("\n")])])]),a("h2",{attrs:{id:"代码范例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),a("h3",{attrs:{id:"python"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),a("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[t._v("\n")])])]),a("h2",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ul",[a("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 14")])])])}),[],!1,null,null,null);e.default=n.exports}}]);