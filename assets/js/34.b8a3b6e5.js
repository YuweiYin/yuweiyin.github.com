(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{459:function(v,_,i){"use strict";i.r(_);var t=i(28),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"algorithm-dynamic-programming"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-dynamic-programming"}},[v._v("#")]),v._v(" Algorithm - Dynamic Programming")]),v._v(" "),i("p",[v._v("By "),i("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[v._v("YuweiYin"),i("OutboundLink")],1)]),v._v(" "),i("h2",{attrs:{id:"目录"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),i("ul",[i("li",[v._v("四边形不等式理论")]),v._v(" "),i("li",[v._v("不完全状态记录\n"),i("ul",[i("li",[v._v("青蛙过河问题")]),v._v(" "),i("li",[v._v("利用区间 DP")])])]),v._v(" "),i("li",[v._v("背包类问题\n"),i("ul",[i("li",[v._v("0-1 背包 (经典问题)")]),v._v(" "),i("li",[v._v("无限背包 (经典问题)")]),v._v(" "),i("li",[v._v("判定性背包问题")]),v._v(" "),i("li",[v._v("带附属关系的背包问题")]),v._v(" "),i("li",[v._v("+/-1 背包问题")]),v._v(" "),i("li",[v._v("双背包求最优值")]),v._v(" "),i("li",[v._v("构造三角形问题")]),v._v(" "),i("li",[v._v("带上下界限制的背包问题 (012背包)")])])]),v._v(" "),i("li",[v._v("线性的动态规划问题\n"),i("ul",[i("li",[v._v("积木游戏问题")]),v._v(" "),i("li",[v._v("决斗（判定性问题）")]),v._v(" "),i("li",[v._v("圆的最大多边形问题")]),v._v(" "),i("li",[v._v("统计单词个数问题")]),v._v(" "),i("li",[v._v("棋盘分割")]),v._v(" "),i("li",[v._v("日程安排问题")]),v._v(" "),i("li",[v._v("最小逼近问题 (求出两数之比最接近某数 / 两数之和等于某数等等)")]),v._v(" "),i("li",[v._v("方块消除游戏 (某区间可以连续消去求最大效益)")]),v._v(" "),i("li",[v._v("资源分配问题")]),v._v(" "),i("li",[v._v("数字三角形问题")]),v._v(" "),i("li",[v._v("漂亮的打印")]),v._v(" "),i("li",[v._v("邮局问题与构造答案")]),v._v(" "),i("li",[v._v("最高积木问题")]),v._v(" "),i("li",[v._v("两段连续和最大")]),v._v(" "),i("li",[v._v("2 次幂和问题")]),v._v(" "),i("li",[v._v("N 个数的最大 M 段子段和")]),v._v(" "),i("li",[v._v("交叉最大数问题")])])]),v._v(" "),i("li",[v._v("判定性问题的 DP (如判定整除、判定可达性等)\n"),i("ul",[i("li",[v._v("模 K 问题的 DP")]),v._v(" "),i("li",[v._v("特殊的模 K 问题，求最大(最小)模 K 的数")]),v._v(" "),i("li",[v._v("变换数问题")])])]),v._v(" "),i("li",[v._v("单调性优化的动态规划\n"),i("ul",[i("li",[v._v("1-SUM 问题")]),v._v(" "),i("li",[v._v("2-SUM 问题")]),v._v(" "),i("li",[v._v("序列划分问题 (单调队列优化)")])])]),v._v(" "),i("li",[v._v("剖分问题 (多边形剖分/石子合并/圆的剖分/乘积最大)\n"),i("ul",[i("li",[v._v("凸多边形的三角剖分问题")]),v._v(" "),i("li",[v._v("乘积最大问题")]),v._v(" "),i("li",[v._v("多边形游戏 (多边形边上是操作符，顶点有权值)")]),v._v(" "),i("li",[v._v("石子合并 (N^3 / N^2 / NLogN 各种优化)")])])]),v._v(" "),i("li",[v._v("贪心的动态规划\n"),i("ul",[i("li",[v._v("最优装载问题")]),v._v(" "),i("li",[v._v("部分背包问题")]),v._v(" "),i("li",[v._v("乘船问题")]),v._v(" "),i("li",[v._v("贪心策略")]),v._v(" "),i("li",[v._v("双机调度问题 Johnson 算法")])])]),v._v(" "),i("li",[v._v("状态 DP\n"),i("ul",[i("li",[v._v("牛仔射击问题(博弈类)")]),v._v(" "),i("li",[v._v("哈密顿路径的状态 DP")]),v._v(" "),i("li",[v._v("两支点天平平衡问题")]),v._v(" "),i("li",[v._v("一个有向图的最接近二部图")])])]),v._v(" "),i("li",[v._v("树型 DP\n"),i("ul",[i("li",[v._v("完美服务器问题 (每个节点有 3 种状态)")]),v._v(" "),i("li",[v._v("小胖守皇宫问题")]),v._v(" "),i("li",[v._v("网络收费问题")]),v._v(" "),i("li",[v._v("树中漫游问题")]),v._v(" "),i("li",[v._v("树上的博弈")]),v._v(" "),i("li",[v._v("树的最大独立集问题")]),v._v(" "),i("li",[v._v("树的最大平衡值问题")]),v._v(" "),i("li",[v._v("构造树的最小环")])])])]),v._v(" "),i("h2",{attrs:{id:"动态规划"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[v._v("#")]),v._v(" 动态规划")]),v._v(" "),i("ul",[i("li",[v._v("动态规划基础\n"),i("ul",[i("li",[i("a",{attrs:{href:"./max-subarray-sum"}},[v._v("连续子数组的最大和")])]),v._v(" "),i("li",[i("a",{attrs:{href:"./cut-rod"}},[v._v("钢条切割")])]),v._v(" "),i("li",[i("a",{attrs:{href:"./matrix-chain-order"}},[v._v("矩阵链乘法")])]),v._v(" "),i("li",[i("a",{attrs:{href:"./longest-common-subsequence"}},[v._v("最长公共子序列")])]),v._v(" "),i("li",[i("a",{attrs:{href:"./optimal-binary-search-tree"}},[v._v("最优二叉搜索树")])])])]),v._v(" "),i("li",[v._v("《CLRS》 Chapter 15 思考题\n"),i("ul",[i("li",[v._v("有向无环图中的最长简单路径")]),v._v(" "),i("li",[v._v("最长回文子序列")]),v._v(" "),i("li",[v._v("双调欧几里得旅行商问题")]),v._v(" "),i("li",[v._v("整齐打印")]),v._v(" "),i("li",[v._v("编辑距离")]),v._v(" "),i("li",[v._v("公司聚会计划")]),v._v(" "),i("li",[v._v("译码算法")]),v._v(" "),i("li",[v._v("基于接缝裁剪的图像压缩")]),v._v(" "),i("li",[v._v("字符串拆分")]),v._v(" "),i("li",[v._v("投资策略规划")]),v._v(" "),i("li",[v._v("库存规划")]),v._v(" "),i("li",[v._v("签约棒球自由球员")])])])]),v._v(" "),i("p",[i("strong",[v._v("动态规划")]),v._v(" (Dynamic Programming, DP) 与分治法相似，都是通过组合子问题的解来求解原问题。注意，“Dynamic Programming”里的 Programming 指的是一种"),i("strong",[v._v("表格法")]),v._v("，而非编写计算机程序。")]),v._v(" "),i("p",[i("strong",[v._v("分治法")]),v._v("将问题划分为"),i("strong",[v._v("互不相交的子问题")]),v._v("，递归地求解子问题 直到易于求解的基本情况，再将子问题的解组合起来，求出原问题的解。与之相反，动态规划应用于"),i("strong",[v._v("子问题重叠")]),v._v("（难以拆解子问题使得它们之间没有相互依赖）的情况，即不同的子问题具有一些公共的“子子问题”。")]),v._v(" "),i("p",[v._v("在这种情况下，如果选择分治算法，那么分治法往往会做出许多不必要的工作，比如反复求解那些公共子问题。而动态规划算法"),i("strong",[v._v("对每个子问题只求解一次")]),v._v("，将其"),i("strong",[v._v("保存在一个表格中")]),v._v("，从而无需每次求解一个子子问题时都要重新计算。往往能将指数级别的计算时间复杂度降到多项式级别。(0 维 DP 用一个标量，1 维 DP 用一个数组、2 维 DP 用一个矩阵/二维数组)")]),v._v(" "),i("p",[v._v("动态规划方法通常用来求解"),i("strong",[v._v("最优化问题")]),v._v(" (Optimization Problem)。这类问题可以有很多可行解，每个解都有一个值，目标往往是寻找具有"),i("strong",[v._v("最优值")]),v._v(" (某特性的最小值或最大值) 的解，被称为问题的"),i("strong",[v._v("一个最优解")]),v._v(" (an optimal solution)，而不是最优解 (the optimal solution)，因为可能有多个解都达到了最优值。")]),v._v(" "),i("p",[v._v("注意，“解”和“值”往往是不同的。比如，在图论问题里，某个可行解/最优解可能是某一条路径 (结点的有序序列)，而对应的值/最优值可能是这条路径的总加权和。")]),v._v(" "),i("ul",[i("li",[v._v("有时候问题只需要给出最优值，有时候需要把最优值和最优解都给出来。")]),v._v(" "),i("li",[v._v("另外，可能有多个最优解对应了问题的最优值。有时候问题要求把这些所有最优解都求出来。")])]),v._v(" "),i("p",[v._v("通常按照如下 4 个步骤来设计一个动态规划算法：")]),v._v(" "),i("ol",[i("li",[v._v("刻画一个最优解的结构特征。（拆分子问题 并分析子问题间的关联依赖）")]),v._v(" "),i("li",[v._v("递归地定义最优解的值。（动态规划 状态转移方程）")]),v._v(" "),i("li",[v._v("计算最优解的值(最优值)。（通常采用自底向上的方法）")]),v._v(" "),i("li",[v._v("利用计算出的(表格中的)信息(回溯地)构造一个最优解。")])]),v._v(" "),i("p",[v._v("如果仅需最优值，可以忽略第 4 步。如果确实需要第 4 步，有时就需要在执行第 3 步的过程中维护一些额外信息，以便用来构造一个最优解。")]),v._v(" "),i("p",[v._v("而且一般来说，如果问题只求最优值、无需求解最优解，那么 DP 表格往往可以减少一个维度。比如原本需要一个二维数组才能回溯求解出最优解，如果不需要求最优解，一维数组就够求出最优值了（原理：覆盖掉那些不再使用的表格信息）。")]),v._v(" "),i("h3",{attrs:{id:"子问题图"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#子问题图"}},[v._v("#")]),v._v(" 子问题图")]),v._v(" "),i("p",[v._v("分析动态规划问题时，由于子问题之间存在依赖关系，所以要对此依赖关联进行分析。")]),v._v(" "),i("p",[v._v("问题的"),i("strong",[v._v("子问题图")]),v._v("表达了子问题之间的依赖关系。它是一个有向图，每个顶点唯一地对应一个子问题 (也对应于递归树中的结点)。若求解子问题 x 的最优解/值时需要直接用到子问题 y 的最优解/值，那么在子问题中就会有一条从 x 到 y 的有向边。")]),v._v(" "),i("p",[v._v("以 "),i("a",{attrs:{href:"./cut-rod"}},[v._v("钢条切割")]),v._v(" 问题为例，有如下子问题图：")]),v._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/dynamic-programming/dp-1.png",alt:"dp-1"}})]),v._v(" "),i("p",[v._v("自底向上的动态规划方法处理子问题图中顶点的顺序为：对于一个给定的子问题 x，在求解它之前求解邻接至它的所有子问题（邻接关系是单向的）。用图论中的术语来说，自底向上动态规划算法是按 "),i("strong",[v._v("逆拓扑序")]),v._v(" (Reverse Topological Sort) 或 "),i("strong",[v._v("反序的拓扑序")]),v._v(" (Topological Sort of the Transpose) 来处理子问题图中的顶点。也即：对于任何子问题 x，直至它依赖的所有子问题均已求解完成，x 才会被求解。")]),v._v(" "),i("p",[v._v("往往可以用带"),i("strong",[v._v("备忘录")]),v._v("的 "),i("strong",[v._v("深度优先搜索")]),v._v(" (Depth-First Search) 自顶向下动态规划算法处理子问题图的顺序。")]),v._v(" "),i("p",[v._v("子问题图 G=(V, E) 的规模可以帮助分析确定动态规划算法的运行时间。由于每个子问题只求解一次，因此算法运行时间等于每个子问题求解时间之和。通常，一个子问题求解时间与子问题图中对应顶点的 degree "),i("strong",[v._v("度")]),v._v(" (出射边的数目) 成正比，而子问题的数目等于子问题图中的顶点数。因此，通常情况下，动态规划算法的运行时间与顶点和边的数量呈线性关系。")]),v._v(" "),i("h2",{attrs:{id:"动态规划原理"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#动态规划原理"}},[v._v("#")]),v._v(" 动态规划原理")]),v._v(" "),i("p",[v._v("适合应用动态规划方法求解的最优化问题应该具备两个要素/性质："),i("strong",[v._v("最优子结构")]),v._v("、"),i("strong",[v._v("重叠子问题")]),v._v("。")]),v._v(" "),i("h3",{attrs:{id:"最优子结构"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#最优子结构"}},[v._v("#")]),v._v(" 最优子结构")]),v._v(" "),i("p",[v._v("用动态规划方法求解最优化问题的第一步就是刻画最优解的结构。如果一个问题的最优解包含(蕴含)其子问题的最优解，就称此问题具有"),i("strong",[v._v("最优子结构性质")]),v._v("。当然，具有最优子结构性质的问题 可能也适合用贪心算法求解。")]),v._v(" "),i("p",[v._v("使用动态规划方法时，用子问题的最优解来构造原问题的最优解，因此需要确保考察了最优解中用到的所有子问题。")]),v._v(" "),i("p",[v._v("在发掘最优子结构性质的过程中，往往遵循了如下的通用模式：")]),v._v(" "),i("ol",[i("li",[v._v("证明问题最优解的"),i("strong",[v._v("第一个组成成分是做出一个选择")]),v._v("。\n"),i("ul",[i("li",[v._v("例如，钢条切割问题中选择第一次切割的位置，矩阵链乘问题中选择矩阵链的第一次划分位置等。")]),v._v(" "),i("li",[v._v("做出这次选择会产生一个或多个待解的(可能不同规模的)子问题。")])])]),v._v(" "),i("li",[v._v("对于一个给定问题，在其可能的第一步选择中，"),i("strong",[v._v("假定已经知道哪种选择才会得到最优解")]),v._v("。")]),v._v(" "),i("li",[v._v("给定可获得最优解的选择后，确定这次选择"),i("strong",[v._v("会产生哪些子问题")]),v._v("，以及如何"),i("strong",[v._v("最好地刻画子问题空间")]),v._v("。")]),v._v(" "),i("li",[v._v("利用“"),i("strong",[v._v("剪切-粘贴")]),v._v("” (cut-and-paste) 技术证明：作为构成原问题最优解的组成成分，"),i("strong",[v._v("每个子问题的解就是子问题本身的最优解")]),v._v("。\n"),i("ul",[i("li",[v._v("证明这一点往往是利用"),i("strong",[v._v("反证法")]),v._v("：假定子问题的解不是其自身的最优解，那么就可以从原问题的解中“剪切”掉这些非最优解，将最优解“粘贴”进去，从而得到原问题的一个更优的解，这与“最初的解是原问题最优解”的前提假设 相矛盾。")]),v._v(" "),i("li",[v._v("如果原问题的最优解包含多个子问题，通常他们都很相似，可以将针对某一个子问题的“剪切-粘贴”论证方法稍加修改，用于其它子问题。")])])])]),v._v(" "),i("p",[v._v("一个刻画子问题空间的好经验是："),i("strong",[v._v("保持子问题空间尽可能简单，只在必要时才扩展它。")])]),v._v(" "),i("p",[v._v("对于不同问题领域，最优子结构的不同体现在两个方面：")]),v._v(" "),i("ol",[i("li",[v._v("原问题的最优解中涉及多少个子问题")]),v._v(" "),i("li",[v._v("在确定最优解使用哪些子问题时，需要考察多少种选择")])]),v._v(" "),i("p",[v._v("例如，钢条切割问题的最优切割方案仅使用一个子问题（长度为 n-i 的子钢条的最优切割问题），但必须要考察 i 的 n 种不同取值，来确定哪一个 i 会产生最优解。而在矩阵链乘问题中，最优解使用两个子问题（被 k 切分的两部分），而且两个子问题都必须求解最优方案。一旦确定了子问题的最优解，就可以在 j-i 个候选的 k 值中选取最优者。")]),v._v(" "),i("p",[v._v("可以用子问题的总数 和 每个子问题需要考察多少种选择 这两者的乘积来粗略分析动态规划算法的运行时间。对于钢条切割问题，共有 $ \\Theta(n) $ 个子问题，每个子问题最多需要考察 n 种选择，因此运行时间为 O(n^2)。矩阵链乘问题共有 $ \\Theta(n^2) $ 个子问题，每个子问题最多需要考察 n-1 种选择，因此运行时间为 O(n^3)。")]),v._v(" "),i("p",[v._v("子问题图也可以用来做同样的分析。图中每个顶点对应一个子问题，而该子问题需要考察的选择数目 对应关联到该顶点的边数。")]),v._v(" "),i("p",[v._v("在动态规划方法中，通常"),i("strong",[v._v("自底向上")]),v._v("地使用最优子结构。首先求得子问题的解，然后求原问题的解。")]),v._v(" "),i("p",[v._v("在尝试使用动态规划方法时，要特别注意问题考察问题是否具有最优子结构性质。比如下面这两个图论问题的对比。其中都是给定一个有向图 G = (V, E) 和两个顶点 $ u, v \\in V $。图中的顶点和边均是"),i("strong",[v._v("无权")]),v._v(" (unweighted) 的，或者可以说所有的顶点权重相等、所有边权重相等。")]),v._v(" "),i("ul",[i("li",[i("strong",[v._v("无权最短路径")]),v._v("：找到一条从 u 到 v 的"),i("strong",[v._v("边数最少的路径")]),v._v("。这条路径必然是简单路径，因为如果路径中包含环，那么将此环去掉 会减少边的数目。\n"),i("ul",[i("li",[v._v("该问题具有最优子结构性质。")])])]),v._v(" "),i("li",[i("strong",[v._v("无权最长路径")]),v._v("：找到一条从 u 到 v 的"),i("strong",[v._v("边数最多的简单路径")]),v._v("。\n"),i("ul",[i("li",[v._v("此问题看似与前一个问题相似，但它并不具有最优子结构性质，即子问题的最优解 并不是 原问题最优解 的必要条件。")]),v._v(" "),i("li",[v._v("实际上，无权最长路径问题是 NP 完全的，目前并没有找到多项式时间求解方法。")])])])]),v._v(" "),i("p",[v._v("造成前述两个问题有别的原因在于：最长简单路径问题的子问题是彼此"),i("strong",[v._v("相关")]),v._v("的，但最短路径问题的子问题之间是"),i("strong",[v._v("无关")]),v._v("的 (independent)。子问题无关，是指同一个原问题的子问题的解 不影响另一个子问题的解。")]),v._v(" "),i("h3",{attrs:{id:"重叠子问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#重叠子问题"}},[v._v("#")]),v._v(" 重叠子问题")]),v._v(" "),i("p",[v._v("适合用动态规划方法求解的最优化问题应该具备的第二个性质是"),i("strong",[v._v("子问题空间必须足够“小”")]),v._v("，即问题的递归算法会反复地求解相同的公共子问题，而不是一直在生成新的子问题。一般来讲，不同子问题的总数是输入规模的多项式函数为好。")]),v._v(" "),i("p",[v._v("如果递归算法反复求解相同的子问题，就称最优化问题具有"),i("strong",[v._v("重叠子问题")]),v._v(" (overlapping subproblems) 性质。与之相对的，适合用分治方法求解的问题 通常在递归的每一步都产生新的子问题。")]),v._v(" "),i("ul",[i("li",[v._v("注意：一个问题是否适合用动态规划求解同时依赖于子问题的"),i("strong",[v._v("无关性")]),v._v("和"),i("strong",[v._v("重叠性")]),v._v("，这并不冲突。\n"),i("ul",[i("li",[i("strong",[v._v("无关性")]),v._v("是指"),i("strong",[v._v("同一原问题的几个子问题之间")]),v._v("是没有资源共享的，即递归树中"),i("strong",[v._v("某一个结点的几个直接子结点 之间")]),v._v("没有问题相交的部分。")]),v._v(" "),i("li",[i("strong",[v._v("重叠性")]),v._v("是指"),i("strong",[v._v("不同原问题的子问题")]),v._v("可能是"),i("strong",[v._v("同一个子问题")]),v._v("，即递归树中"),i("strong",[v._v("不同结点的直接子结点")]),v._v(" 可能是"),i("strong",[v._v("同一个")]),v._v("子结点。")])])])]),v._v(" "),i("p",[v._v("对于重叠的子问题，动态规划的通常处理方式就是表格法：只对每个子问题求解一次，将解/值存入一个表中，当再次需要这个子问题的解/值时直接查表，而查表的代价为常数时间。（数组的直接命中）")]),v._v(" "),i("h3",{attrs:{id:"重构最优解"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#重构最优解"}},[v._v("#")]),v._v(" 重构最优解")]),v._v(" "),i("p",[v._v("从实际考虑，通常将每个子问题所做的最优选择存储在一个表中（一般而言，有别于存储最优值的备忘录），便于(更高效地)回溯构造出原问题的最优解。")]),v._v(" "),i("p",[v._v("通常希望将每次重构一个选择的时间复杂度降到 O(1)。")]),v._v(" "),i("h3",{attrs:{id:"备忘录"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#备忘录"}},[v._v("#")]),v._v(" 备忘录")]),v._v(" "),i("p",[v._v("应用动态规划时，除了自底向上的循环处理策略，也可以采用带备忘录的自顶向下策略。思路是对自然但低效的递归算法加入"),i("strong",[v._v("备忘机制")]),v._v("，维护一个"),i("strong",[v._v("公共表格")]),v._v("记录子问题的解，供每级递归过程(各个子问题)调用。一旦某子问题已经有最优解/值，则直接查表返回，不再重复计算。")]),v._v(" "),i("p",[v._v("注意：这种提前构建表格的方法，是假定预先知道了所有可能的子问题空间(参数)，于是在表项和子问题间建立起一一对应关系。另一个更通用的备忘方法是使用"),i("strong",[v._v("散列技术")]),v._v("，以子问题参数为关键字。")]),v._v(" "),i("p",[v._v("而且一般来说，自底向上的循环算法 往往比 带备忘录的自顶向下递归算法 快一些，虽然两者的渐近时间复杂度是同一量级，但是后者有递归调用的时空开销。")]),v._v(" "),i("p",[v._v("不过也不是自底向上的循环算法一定更好。在某些问题中，子问题空间中的某些子问题完全不必求解，所以备忘录方法就体现出优势了：它只会求解那些(为了解出原问题而)必要的子问题，不会去解与目标问题无关的子问题。")])])}),[],!1,null,null,null);_.default=l.exports}}]);