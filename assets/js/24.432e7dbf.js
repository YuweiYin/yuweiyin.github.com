(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{304:function(t,r,e){"use strict";e.r(r);var a=e(28),_=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"algorithm-data-structure-segment-tree"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-segment-tree"}},[t._v("#")]),t._v(" Algorithm - Data Structure - Segment Tree")]),t._v(" "),e("p",[t._v("By "),e("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("线段树 (Segment Tree, ST)")]),t._v(" "),e("h2",{attrs:{id:"场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[t._v("#")]),t._v(" 场景")]),t._v(" "),e("p",[t._v("线段树常用作于求 array 中区间最大值/最小值、区间的和，这类区间的"),e("strong",[t._v("某种特性值")]),t._v("。")]),t._v(" "),e("ul",[e("li",[t._v("array：依下标 index 连续存储的"),e("strong",[t._v("数值")]),t._v("数组/列表")]),t._v(" "),e("li",[t._v("update：修改 array 中某个下标 index 对应的数值")]),t._v(" "),e("li",[t._v("query：查询 array 中某一个下标区间 [left, right) 中的"),e("strong",[t._v("某种特性值")]),t._v("（比如：区间最值、区间的和）")])]),t._v(" "),e("p",[t._v("注意：")]),t._v(" "),e("ol",[e("li",[t._v("array 中存储的也可以不是数值，而是某种结构体，但是该结构体一定要两两可以比较序关系（"),e("strong",[t._v("全序")]),t._v("关系）")]),t._v(" "),e("li",[t._v("update 和 query 可以有"),e("strong",[t._v("很多次")]),t._v("。")])]),t._v(" "),e("h2",{attrs:{id:"场景分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景分析"}},[t._v("#")]),t._v(" 场景分析")]),t._v(" "),e("h3",{attrs:{id:"数组-列表结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组-列表结构"}},[t._v("#")]),t._v(" 数组/列表结构")]),t._v(" "),e("p",[t._v("如果采用普通的数组/列表结构进行处理，那么 update 操作的时间复杂度为 O(1)，query 操作的时间复杂度为 O(n)，其中 n 为 array 的长度。")]),t._v(" "),e("p",[t._v("设有 u 次 update、q 次 query，则整体时间复杂度为 O(u + qn)")]),t._v(" "),e("p",[t._v("在 query 较多较频繁的场景下，该结构的整体时间复杂度较高。")]),t._v(" "),e("h3",{attrs:{id:"线段树结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线段树结构"}},[t._v("#")]),t._v(" 线段树结构")]),t._v(" "),e("p",[t._v("而线段树通过维护不同粒度的区间特性值，其形状是完全二叉树（树高为 O(log n)），以二分查找的思路来加速 query 操作，使其时间复杂度降低到了 O(log n)。")]),t._v(" "),e("p",[t._v("为了维护不同粒度的区间特性值，线段树在 update 操作时是从叶向上逐级更新，时间复杂度增加到了 O(log n)。")]),t._v(" "),e("p",[t._v("设有 u 次 update、q 次 query，则整体时间复杂度为 O(u log n + q log n) = O((u + q) log n)")]),t._v(" "),e("p",[t._v("但是，一旦 array 长度变化，线段树就需要重建了，每次重建的时间复杂度为 O(n)。")]),t._v(" "),e("p",[t._v("因此，在 n 值较大（数组较长）、且数组长度不频繁变动的情况下，线段树对 query 操作效率的提升效果显著。")]),t._v(" "),e("h2",{attrs:{id:"设计-细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[t._v("#")]),t._v(" 设计 & 细节")]),t._v(" "),e("h3",{attrs:{id:"求区间特性值-merge"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#求区间特性值-merge"}},[t._v("#")]),t._v(" 求区间特性值 merge")]),t._v(" "),e("p",[t._v("merge(left, right) 函数用于计算下标为 [ left, right ] 的闭区间的“区间特性值”，比如最小值。")]),t._v(" "),e("ul",[e("li",[t._v("注意：\n"),e("ul",[e("li",[t._v("通常来说，merge 操作需要做到常数时间复杂度，即 O(1)。")]),t._v(" "),e("li",[t._v("下文均以求区间最小值为例展开论述。")]),t._v(" "),e("li",[t._v("array 的长度 n 目前暂假定为 2 的自然数幂次，之后会讨论其他情况。")])])])]),t._v(" "),e("h3",{attrs:{id:"st-建立"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#st-建立"}},[t._v("#")]),t._v(" ST 建立")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("建树思路：")]),t._v(" "),e("ul",[e("li",[t._v("线段树的叶结点均为 array 数组中的各个值。")]),t._v(" "),e("li",[t._v("从叶结点开始，相邻两两结点 merge 出父结点的值，直至根结点。")])])]),t._v(" "),e("li",[e("p",[t._v("可以看出：")]),t._v(" "),e("ul",[e("li",[t._v("最终结点数目为 n + n/2 + n/4 + ... + 1 = 2n-1。")]),t._v(" "),e("li",[t._v("建树需对 array 扫描一遍，时间复杂度为 O(n)")])])])]),t._v(" "),e("p",[t._v("我们用一个长度为 2n 的大数组来存储所有结点值，其中下标较大的最末 n 个位置存放原 array 的值，作为叶结点值。")]),t._v(" "),e("p",[t._v("随后从后往前扫描，对叶结点两两分组，进行 merge 操作，计算出的值为其父结点的值，保存于下标为 (int)(left / 2) 的位置。")]),t._v(" "),e("ul",[e("li",[t._v("以 array = [1, 5, 3, 7] 为例：\n"),e("ul",[e("li",[t._v("构造大数组 st = [inf, inf, inf, inf, 1, 5, 3, 7]。其中 inf 为预设的数字最大值，因为目前假定 merge 是求区间最小值。")]),t._v(" "),e("li",[t._v("从后往前扫描，两两 merge：\n"),e("ul",[e("li",[t._v("[3, 7] -> 3: st = [inf, inf, inf, 3, 1, 5, 3, 7]")]),t._v(" "),e("li",[t._v("[1, 5] -> 1: st = [inf, inf, 1, 3, 1, 5, 3, 7]")]),t._v(" "),e("li",[t._v("[1, 3] -> 1: st = [inf, 1, 1, 3, 1, 5, 3, 7]")])])]),t._v(" "),e("li",[t._v("最终得到线段树（大数组）为 [inf, 1, 1, 3, 1, 5, 3, 7]，建树完毕。")])])])]),t._v(" "),e("p",[t._v("以 array = [1, 5, 3, 7, 3, 2, 5, 7] 为例：")]),t._v(" "),e("ol",[e("li",[t._v("初始 st 大数组：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-0.png",alt:"segment-tree-0"}})]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("构造完毕的 st：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-1.png",alt:"segment-tree-1"}})]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("st 各结点存储的区间信息如下：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-2.png",alt:"segment-tree-2"}})]),t._v(" "),e("h3",{attrs:{id:"更新-update"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更新-update"}},[t._v("#")]),t._v(" 更新 update")]),t._v(" "),e("p",[t._v("更新 array 的值时，修改叶结点的值，并逐级向上 merge。")]),t._v(" "),e("p",[t._v("因为树高为 O(log n)，因此 update 操作的时间复杂度为 O(log n)。")]),t._v(" "),e("p",[t._v("以 array = [1, 5, 3, 7, 3, 2, 5, 7] 为例，更新其 index=5 的值为 6，即操作 update(5, 6)：")]),t._v(" "),e("ol",[e("li",[t._v("先修改叶结点：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-3.png",alt:"segment-tree-3"}})]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("再逐级向上更新：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-4.png",alt:"segment-tree-4"}})]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("直至树根，更新完毕：")])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-5.png",alt:"segment-tree-5"}})]),t._v(" "),e("h3",{attrs:{id:"查询-query"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#查询-query"}},[t._v("#")]),t._v(" 查询 query")]),t._v(" "),e("p",[t._v("查询某一区间 [ left, right ] 的“区间特性值”（比如最小值），执行操作 query(left, right)。")]),t._v(" "),e("p",[t._v("这里 [ left, right ] 为闭区间，变量取值范围为 0 <= left <= right <= n-1")]),t._v(" "),e("ul",[e("li",[t._v("从叶结点开始查询。查询时，有三种情况：\n"),e("ul",[e("li",[t._v("case 1. 当前结点所代表的区间完全位于 query 区间 [ left, right ] 之外（与闭区间无交集），则不应考虑当前结点。")]),t._v(" "),e("li",[t._v("case 2. 当前结点所代表的区间完全位于 query 区间 [ left, right ] 之内（含边界值）\n"),e("ul",[e("li",[t._v("case 2.1. 当前结点的父结点所代表的区间也完全位于 query 区间 [ left, right ] 之内（含边界值），则可以直接查询其父结点值，减少查询量。")]),t._v(" "),e("li",[t._v("case 2.2. 当前结点的父结点所代表的区间部分位于 query 区间 [ left, right ] 之内、部分在外，则分段考虑：先处理位于 query 区间外的部分；后处理位于 query 区间内的部分。")])])])])])]),t._v(" "),e("p",[t._v("以 array = [1, 5, 3, 7, 3, 2, 5, 7] 为例，查询区间 [ 1, 6 ] 的最小值 query(1, 6)：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-6.png",alt:"segment-tree-6"}})]),t._v(" "),e("ul",[e("li",[t._v("分析：\n"),e("ul",[e("li",[t._v("从叶结点开始查询，下标为 0 和下标为 7 的叶结点都与 query 区间 [ 1, 6 ] 无交集，属于情况 1，排除之。")]),t._v(" "),e("li",[t._v("下标为 1 和下标为 6 的结点完全位于 query 区间 [ left, right ] 之内，属于情况 2。但是其父结点所代表的区间不完全位于 query 区间内，所以属于情况 2.2。")]),t._v(" "),e("li",[t._v("下标为 2 至下标为 5 的结点属于情况 2.1，因此只需观察其父结点即可。")])])])]),t._v(" "),e("p",[t._v("实现时，为了避免重复处理那些 query 区间外的、已被排除的值，可采用对撞指针、区间夹逼的思想。query 时间复杂度 O(log n)。")]),t._v(" "),e("p",[t._v("更多例子：以 update 后的 array = [1, 5, 3, 7, 3, 6, 5, 7] 为例，查询区间 [ 1, 6 ] 的最小值 query(1, 6)：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-7.png",alt:"segment-tree-7"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-8.png",alt:"segment-tree-8"}})]),t._v(" "),e("h3",{attrs:{id:"n-power-of-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#n-power-of-2"}},[t._v("#")]),t._v(" n != power of 2")]),t._v(" "),e("p",[t._v("若 array 长度 n 不为 2 的自然数幂次，树的结构看似比较乱，当前算法看似无法正常运行。")]),t._v(" "),e("p",[t._v("一个简单的考虑是将 array 填充 inf 直至某个 2 的自然数幂次，但这可能会带来很大的存储负担，增加了时空复杂度。")]),t._v(" "),e("p",[t._v("实际上，本算法能够处理"),e("strong",[t._v("任意正整数")]),t._v(" n 长度的 array，即便是奇数也没问题。")]),t._v(" "),e("p",[t._v("以 array = [4, 3, 9, 1, 6, 7] 为例：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/segment-tree-9.png",alt:"segment-tree-9"}})]),t._v(" "),e("h2",{attrs:{id:"代码范例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),e("h3",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),e("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/segment-tree.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.youtube.com/watch?v=Oq2E2yGadnU",target:"_blank",rel:"noopener noreferrer"}},[t._v("Youtube - Efficient Segment Tree Tutorial"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"http://codeforces.com/blog/entry/18051",target:"_blank",rel:"noopener noreferrer"}},[t._v("CF Blog"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=_.exports}}]);