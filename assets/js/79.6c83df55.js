(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{322:function(t,a,n){"use strict";n.r(a);var r=n(28),o=Object(r.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"algorithm-linear-programming-fast-fourier-transform"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-linear-programming-fast-fourier-transform"}},[t._v("#")]),t._v(" Algorithm - Linear Programming - Fast Fourier Transform")]),t._v(" "),n("p",[t._v("By "),n("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),n("ul",[n("li",[t._v("多项式与快速傅立叶变换 Polynomial & FFT\n"),n("ul",[n("li",[t._v("离散傅立叶变换 (Discrete Fourier Transform, DFT)")]),t._v(" "),n("li",[t._v("快速傅立叶变换 (Fast Fourier Transform, FFT)")])])])]),t._v(" "),n("h2",{attrs:{id:"dft-fft"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dft-fft"}},[t._v("#")]),t._v(" DFT & FFT")]),t._v(" "),n("p",[t._v("如果使用单位复数根，可以在 $ \\Theta(n log n) $ 时间内完成求值与插值运算。本节给出单位复数根的定义，并研究其性质，以及定义 DFT，然后说明如何仅用 $ \\Theta(n log n) $ 时间就可以计算出 DFT 和它的逆。")]),t._v(" "),n("h3",{attrs:{id:"单位复数根"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#单位复数根"}},[t._v("#")]),t._v(" 单位复数根")]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-1.png",alt:"dft-fft-1"}})]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-2.png",alt:"dft-fft-2"}})]),t._v(" "),n("h3",{attrs:{id:"离散傅立叶变换-dft"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#离散傅立叶变换-dft"}},[t._v("#")]),t._v(" 离散傅立叶变换 DFT")]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-3.png",alt:"dft-fft-3"}})]),t._v(" "),n("h3",{attrs:{id:"快速傅立叶变换-fft"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#快速傅立叶变换-fft"}},[t._v("#")]),t._v(" 快速傅立叶变换 FFT")]),t._v(" "),n("p",[t._v("FFT 加速的核心思想就是利用"),n("strong",[t._v("分治策略")]),t._v("，同时也利用了类似"),n("strong",[t._v("快速幂")]),t._v("的技术。")]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-4.png",alt:"dft-fft-4"}})]),t._v(" "),n("p",[t._v("如下伪代码完成的任务是：递归求解次数界为 n 的多项式在 n 次单位复数根处的值。注意：这里的长度 n 实际上是 2n，因为在求值前 加倍给定多项式的次数界。因此实际处理的是 2n 次单位根。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("RECURSIVE_FFT(a)\n1  n = a.length  // n is a power of 2\n2  if n == 1\n3      return a\n4  w_n = e^{2 i \\pi / n}\n5  w = 1\n6  a^{0} = (a_0, a_2, ..., a_{n-2})\n7  a^{1} = (a_1, a_3, ..., a_{n-1})\n8  y^{0} = RECURSIVE_FFT(a^{0})\n9  y^{1} = RECURSIVE_FFT(a^{1})\n10 for k = 0 to (n/2)-1\n11     y_k = y_k^{0} + w * y_k^{1}\n12     y_{k + (n/2)} = y_k^{0} - w * y_k^{1}\n13     w = w * w_n\n14 return y  // y is assumed to be a column vector\n")])])]),n("p",[t._v("算法过程描述如下：")]),t._v(" "),n("ol",[n("li",[t._v("在 1 行，获取当前递归的子问题规模 n。")]),t._v(" "),n("li",[t._v("在 2～3 行，处理基本情况，一个元素的 DFT 就是该元素自身，因为此时 "),n("code",[t._v("y_0 = a_0 * w_1^{0} = a_0 * 1 = a_0")]),t._v("。")]),t._v(" "),n("li",[t._v("在 4～5 行，设置主 n 次单位复数根 "),n("code",[t._v("w_n")]),t._v("，以及初始 w 值为 1。")]),t._v(" "),n("li",[t._v("在 6～7 行，定义以偶数下标元素组成的多项式的系数向量 "),n("code",[t._v("a^{0}")]),t._v("，下标为奇数时是 "),n("code",[t._v("a^{1}")]),t._v("。")]),t._v(" "),n("li",[t._v("在 8～9 行，递归计算子问题 $ DFT_{n/2} $，对于 k = 0, 1, ..., (n/2) - 1，有：\n- $ y_k^{0} = A^{0} (w_{n/2}^{k}) $\n- $ y_k^{1} = A^{1} (w_{n/2}^{k}) $\n"),n("ul",[n("li",[t._v("或者根据消去引理（$ w_{n/2}^{k} = w_{n/2}^{2k} $）有：\n"),n("ul",[n("li",[t._v("$ y_k^{0} = A^{0} (w_{n}^{2k}) $")]),t._v(" "),n("li",[t._v("$ y_k^{1} = A^{1} (w_{n}^{2k}) $")])])])])]),t._v(" "),n("li",[t._v("在 10～13 行的循环中，综合了递归 $ DFT_{n/2} $ 的计算结果：\n"),n("ul",[n("li",[t._v("第 11 行推出了 $ y_k^{0} = A(w_{n}^{k}) $")]),t._v(" "),n("li",[t._v("第 12 行推出了 $ y_{k + (n/2)} = A(w_{n}^{k + (n/2)}) $")]),t._v(" "),n("li",[t._v("第 4、5 和 13 行保证 w 可以正确更新")])])]),t._v(" "),n("li",[t._v("在 14 行，最后，返回计算结果 y，即输入的多项式系数向量 a 的 DFT 向量。")])]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-5.png",alt:"dft-fft-5"}})]),t._v(" "),n("h3",{attrs:{id:"在单位复数根处插值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在单位复数根处插值"}},[t._v("#")]),t._v(" 在单位复数根处插值")]),t._v(" "),n("p",[t._v("插值是把一个多项式从(DFT)点值表达形式转换回系数表达形式。插值思路：把 DFT 写成一个矩阵方程，然后再观察其逆矩阵的形式。")]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-6.png",alt:"dft-fft-6"}})]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-7.png",alt:"dft-fft-7"}})]),t._v(" "),n("h2",{attrs:{id:"高效的-fft-实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#高效的-fft-实现"}},[t._v("#")]),t._v(" 高效的 FFT 实现")]),t._v(" "),n("p",[t._v("从渐近时间复杂度的角度来说，可以说 FFT 已经达到了极限。但是 DFT & FFT 的实际应用（如信号处理）中需要尽可能快的速度，因此考虑减小隐藏在渐近符号中的常数因子、提升实际运行速度。")]),t._v(" "),n("h3",{attrs:{id:"fft-的一种迭代实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fft-的一种迭代实现"}},[t._v("#")]),t._v(" FFT 的一种迭代实现")]),t._v(" "),n("p",[t._v("在 "),n("code",[t._v("RECURSIVE_FFT")]),t._v(" 中，第 10～13 行的 for 循环中包含了 2 次重复的 "),n("code",[t._v("w_n^k * y_k^{1}")]),t._v(" 计算（在编译术语中，该值被称为"),n("strong",[t._v("公用子表达式")]),t._v(" (common subexpression)），而此计算并不像简单的加法那么迅速，因此考虑仅计算此表达式一次，并将其值存放在临时变量中。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("10 for k = 0 to (n/2)-1\n11     temp = w * y_k^{1}\n12     y_k = y_k^{0} + temp\n13     y_{k + (n/2)} = y_k^{0} - temp\n14     w = w * w_n\n")])])]),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-8.png",alt:"dft-fft-8"}})]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-9.png",alt:"dft-fft-9"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("1  for s = 1 to log_2 (n)\n2      for k = 0 to n-1 by 2^s\n3          combine the two 2^{s-1} element DFTs in\n               A[k..k+2^{s-1}-1] and A[k+2^{s-1}..k+2^{s}-1]\n               into one 2^{s} element DFT in A[k..k+2^{s}-1]\n")])])]),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-10.png",alt:"dft-fft-10"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("ITERATIVE_FFT(a)\n1  BIT_REVERSE_COPY(a, A)\n2  n = a.length  // n is a power of 2\n3  for s = 1 to log_2 (n)\n4      m = 2^{s}\n5      w_m = e^{2 i \\pi / n}\n6      for k = 0 to n-1 by m\n7          w = 1\n8          for j = 0 to (m/2)-1\n9              temp = w * A[k + j + (m/2)]\n10             u = A[k + j]\n11             A[k + j] = u + t\n12             A[k + j + (m/2)] = u - t\n13             w = w * w_n\n14 return A\n")])])]),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-11.png",alt:"dft-fft-11"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("BIT_REVERSE_COPY(a, A)\n1  n = a.length\n2  for k = 0 to n-1\n3      A[rev(k)] = a_k\n")])])]),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-12.png",alt:"dft-fft-12"}})]),t._v(" "),n("h2",{attrs:{id:"并行-fft-电路"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并行-fft-电路"}},[t._v("#")]),t._v(" 并行 FFT 电路")]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-13.png",alt:"dft-fft-13"}})]),t._v(" "),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/polynomial-fft/dft-fft-14.png",alt:"dft-fft-14"}})]),t._v(" "),n("h2",{attrs:{id:"代码范例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),n("h3",{attrs:{id:"python"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),n("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/other-topics/polynomial-fft/fast-fourier-transform.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"参考资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),n("ul",[n("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 30")])])])}),[],!1,null,null,null);a.default=o.exports}}]);