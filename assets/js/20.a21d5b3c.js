(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{267:function(r,a,_){"use strict";_.r(a);var e=_(28),t=Object(e.a)({},(function(){var r=this,a=r.$createElement,_=r._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[_("h1",{attrs:{id:"algorithm-data-structure-range-minimum-maximum-query"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-range-minimum-maximum-query"}},[r._v("#")]),r._v(" Algorithm - Data Structure - Range Minimum/Maximum Query")]),r._v(" "),_("p",[r._v("By "),_("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[r._v("YuweiYin"),_("OutboundLink")],1)]),r._v(" "),_("h2",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[r._v("#")]),r._v(" 简介")]),r._v(" "),_("p",[r._v("区间最值查询 Sparse Table (Range Minimum/Maximum Query, RMQ)")]),r._v(" "),_("h2",{attrs:{id:"场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#场景"}},[r._v("#")]),r._v(" 场景")]),r._v(" "),_("p",[r._v("RMQ 主要用作于求 array 中区间最大值/最小值，在 O(n log n) 时间复杂度的预处理（运用动态规划思想）后，求区间最值的操作能达到 O(1) 的时间复杂度！不过代价是修改或者增删 array 数组时，需要重新用 O(n log n) 的时间复杂度进行预处理。")]),r._v(" "),_("p",[r._v("预处理（构建 Sparse Table）的空间复杂度为 O(n log n)，而非 O(n^2)。因为只存储长度为 2 的自然数幂次（1、2、4、8...）的区间最值。")]),r._v(" "),_("ul",[_("li",[r._v("array：依下标 index 连续存储的"),_("strong",[r._v("数值")]),r._v("数组/列表")]),r._v(" "),_("li",[r._v("update：修改 array 中某个下标 index 对应的数值")]),r._v(" "),_("li",[r._v("query(from, to)：查询 array 中某一个下标区间 [from, to) 中的"),_("strong",[r._v("区间最值")])])]),r._v(" "),_("p",[r._v("注意：")]),r._v(" "),_("ol",[_("li",[r._v("array 中存储的也可以不是数值，而是某种结构体，但是该结构体一定要两两可以比较序关系（"),_("strong",[r._v("全序")]),r._v("关系）")]),r._v(" "),_("li",[r._v("update 和 query 可以有"),_("strong",[r._v("很多次")]),r._v("。")])]),r._v(" "),_("h2",{attrs:{id:"场景分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#场景分析"}},[r._v("#")]),r._v(" 场景分析")]),r._v(" "),_("h3",{attrs:{id:"数组-列表结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组-列表结构"}},[r._v("#")]),r._v(" 数组/列表结构")]),r._v(" "),_("ul",[_("li",[r._v("建数组的时间复杂度为 O(n)，array 长度变化的数组修改时间为 O(1)")]),r._v(" "),_("li",[r._v("update 时间复杂度为 O(1)")]),r._v(" "),_("li",[r._v("query 查询区间最值/区间和 的时间复杂度为 O(n)")])]),r._v(" "),_("h3",{attrs:{id:"线段树结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线段树结构"}},[r._v("#")]),r._v(" "),_("a",{attrs:{href:"./segment-tree"}},[r._v("线段树结构")])]),r._v(" "),_("ul",[_("li",[r._v("建树时间复杂度为 O(n)，一旦 array 长度变化，需要重新建树")]),r._v(" "),_("li",[r._v("update 时间复杂度为 O(log n)")]),r._v(" "),_("li",[r._v("query 查询区间最值/区间和 的时间复杂度为 O(log n)")])]),r._v(" "),_("h3",{attrs:{id:"sparse-table-rmq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sparse-table-rmq"}},[r._v("#")]),r._v(" Sparse Table RMQ")]),r._v(" "),_("ul",[_("li",[r._v("建表时间复杂度为 O(n log n)，空间复杂度为 O(n log n)，一旦 array 长度变化，需要重新建表")]),r._v(" "),_("li",[r._v("update 操作后也需要重新建表，时间复杂度为 O(n log n)")]),r._v(" "),_("li",[r._v("query 查询区间最值 的时间复杂度为 O(1)")])]),r._v(" "),_("p",[r._v("从以上对比很明显可以看出，Sparse Table RMQ 适合于这样的场景：array 很长、且几乎不改变，并且需要处理大量的区间最值 query 操作。")]),r._v(" "),_("h2",{attrs:{id:"设计-细节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[r._v("#")]),r._v(" 设计 & 细节")]),r._v(" "),_("p",[r._v("以计算区间最小值为例，展开下文叙述。")]),r._v(" "),_("h3",{attrs:{id:"建表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#建表"}},[r._v("#")]),r._v(" 建表")]),r._v(" "),_("p",[r._v("Sparse Table 只预先计算并存储长度为 2 的自然数幂次（1、2、4、8...）的区间最值。")]),r._v(" "),_("p",[r._v("以 array = [5, 2, 4, 7, 6, 3, 1, 2] 为例，处理过程如下：")]),r._v(" "),_("ol",[_("li",[r._v("计算长度为 2^0 = 1 的区间最值：以步长为 1、窗口大小为 1 的滑动窗口扫过 array，结果即为原 array\n"),_("ul",[_("li",[r._v("结果：res_0 = [5, 2, 4, 7, 6, 3, 1, 2]")])])]),r._v(" "),_("li",[r._v("计算长度为 2^1 = 2 的区间最值：以步长为 1、窗口大小为 2 的滑动窗口扫过 array。"),_("strong",[r._v("注意尾部为空，记为 -。")]),r._v(" "),_("ul",[_("li",[r._v("结果：res_1 = [2, 2, 4, 6, 3, 1, 1, -] （在求区间最小值的场景下，可以将 - 预设为 inf 无穷大）")])])]),r._v(" "),_("li",[r._v("计算长度为 2^2 = 4 的区间最值：以步长为 1、窗口大小为 4 的滑动窗口扫过 array。\n"),_("ul",[_("li",[r._v("结果：res_2 = [2, 2, 3, 1, 1, -, -, -]")])])]),r._v(" "),_("li",[r._v("计算长度为 2^3 = 8 的区间最值：以步长为 1、窗口大小为 8 的滑动窗口扫过 array。\n"),_("ul",[_("li",[r._v("结果：res_3 = [1, -, -, -, -, -, -, -]")])])]),r._v(" "),_("li",[r._v("长度 2^4 = 16 > 8，结束扫描，前述结果的整体（二维数组 / 矩阵）即为 Sparse Table。")])]),r._v(" "),_("p",[_("strong",[r._v("Sparse Table 的含义")]),r._v("：res_i[j] 表示从 array 的下标 j 开始、长度为 2^i 的区间的最值。")]),r._v(" "),_("ul",[_("li",[r._v("求窗口最值的优化策略：\n"),_("ul",[_("li",[r._v("按前述的滑动窗口描述，每次都以步长为 1 扫过原始 array，但窗口会逐渐变大。")]),r._v(" "),_("li",[r._v("如果计算窗口的最值时都是线性扫描，则会导致复杂度很高，额外做了很多重复的加法。")]),r._v(" "),_("li",[r._v("因此可以用动态规划的思想、利用之前的输出值，来优化求区间最值的过程。")])])])]),r._v(" "),_("p",[_("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/rmq-0.png",alt:"rmq-0"}})]),r._v(" "),_("ol",[_("li",[r._v("计算长度为 2^0 = 1 的区间最值：以步长为 1、窗口大小为 1 的滑动窗口扫过 array，结果即为原 array\n"),_("ul",[_("li",[r._v("结果：res_0 = [5, 2, 4, 7, 6, 3, 1, 2]")])])]),r._v(" "),_("li",[r._v("计算长度为 2^1 = 2 的区间最值：以步长为 1、窗口大小为 2 的滑动窗口扫过 array。窗口大小仅为 2，所以正常调用 min/max 函数即可。\n"),_("ul",[_("li",[r._v("结果：res_1 = [2, 2, 4, 6, 3, 1, 1, -]")])])]),r._v(" "),_("li",[r._v("计算长度为 2^2 = 4 的区间最值：以步长为 1、窗口大小为 4 的滑动窗口扫过 array。计算窗口最值时，要利用 res_1 的结果。\n"),_("ul",[_("li",[r._v("比如：计算 res_2[3] 时，即需要计算从 index=3 开始、长度为 2^2 的区间的最值，也就等于 res_1[3] + res_1[3 + 2^1]")]),r._v(" "),_("li",[r._v("即："),_("strong",[r._v("状态转移方程")]),r._v("为 res_i[j] = min( res_{i-1}[j], res_{i-1}[j + 2^{i-1}] )")]),r._v(" "),_("li",[r._v("注意：计算到 res_2[5] 时，发现 res_1[7] 为 -，便停止计算、进行下一轮。")]),r._v(" "),_("li",[r._v("结果：res_2 = [2, 2, 3, 1, 1, -, -, -]")])])]),r._v(" "),_("li",[r._v("计算长度为 2^3 = 8 的区间最值：以步长为 1、窗口大小为 8 的滑动窗口扫过 array。计算窗口最值时，要利用 res_2 的结果。\n"),_("ul",[_("li",[r._v("res_3[0] = min( res_2[0], res_2[0 + 2^2] ) = min(2, 1) = 1")]),r._v(" "),_("li",[r._v("结果：res_3 = [1, -, -, -, -, -, -, -]")])])]),r._v(" "),_("li",[r._v("长度 2^4 = 16 > 8，结束扫描，前述结果的整体（二维数组 / 矩阵）即为 Sparse Table。")])]),r._v(" "),_("h3",{attrs:{id:"查询-query-left-right"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查询-query-left-right"}},[r._v("#")]),r._v(" 查询 query(left, right)")]),r._v(" "),_("p",[r._v("以 array = [5, 2, 4, 7, 6, 3, 1, 2] 为例，查询闭区间 [ 1, 6 ] 的区间最小值 query(1, 6)：")]),r._v(" "),_("ul",[_("li",[r._v("先将 query 闭区间拆为两个子区间 sub1 和 sub2\n"),_("ul",[_("li",[r._v("希望这两个子区间有如下两个性质：\n"),_("ol",[_("li",[r._v("两个子区间等长，其长度为 2 的自然数幂次；")]),r._v(" "),_("li",[r._v("两区间的并集恰好覆盖整个 query 区间。")])])]),r._v(" "),_("li",[r._v("计算 query 区间的长度的 log_2  对数值（下取整）为 (int) log_2 (6 - 1) = 2")]),r._v(" "),_("li",[r._v("则子区间长度 len(sub1) = len(sub2) = 2^2 = 4")]),r._v(" "),_("li",[r._v("现在需确定这两个区间的起始位置：\n"),_("ul",[_("li",[r._v("sub1 从 left（即 index=1）开始")]),r._v(" "),_("li",[r._v("sub1 从 right - 2^2 + 1（即 index=3）开始")])])]),r._v(" "),_("li",[r._v("两个子区间的区间最小值可以直接通过索引 Sparse Table 得到：\n"),_("ul",[_("li",[r._v("range_min(sub1) = SparseTable[2][1]")]),r._v(" "),_("li",[r._v("range_min(sub1) = SparseTable[2][3]")])])]),r._v(" "),_("li",[r._v("用 min 函数计算这两个“最小值”的较小者，即可得到整个 query 区间的最小值")])])])]),r._v(" "),_("h3",{attrs:{id:"更新-update-index-value"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#更新-update-index-value"}},[r._v("#")]),r._v(" 更新 update(index, value)")]),r._v(" "),_("p",[r._v("由于更新 array 中的一个值，或者增删一个元素，其影响往往都不止一条路径。")]),r._v(" "),_("p",[r._v("因此 Sparse Table 不像线段树、树状数组那样，更新操作的时间复杂度只是树高量级，即 O(log n)。")]),r._v(" "),_("p",[r._v("每次更新都需要重新建 Sparse Table，时间复杂度为 O(n log n)。")]),r._v(" "),_("h2",{attrs:{id:"代码范例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[r._v("#")]),r._v(" 代码范例")]),r._v(" "),_("h3",{attrs:{id:"python"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[r._v("#")]),r._v(" Python")]),r._v(" "),_("p",[r._v("Python 环境：Python 3.7")]),r._v(" "),_("p",[_("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/range-min-max-query.py",target:"_blank",rel:"noopener noreferrer"}},[r._v("GitHub Code Link"),_("OutboundLink")],1)]),r._v(" "),_("h2",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[r._v("#")]),r._v(" 参考资料")]),r._v(" "),_("p",[_("a",{attrs:{href:"https://www.youtube.com/watch?v=9FLPwDn6L08",target:"_blank",rel:"noopener noreferrer"}},[r._v("Youtube - Sparse Table Tutorial / RMQ"),_("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=t.exports}}]);