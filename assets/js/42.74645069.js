(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{288:function(v,_,r){"use strict";r.r(_);var t=r(28),o=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h1",{attrs:{id:"algorithm-graph-theory-ford-fulkerson"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-graph-theory-ford-fulkerson"}},[v._v("#")]),v._v(" Algorithm - Graph Theory - Ford-Fulkerson")]),v._v(" "),r("p",[v._v("By "),r("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[v._v("YuweiYin"),r("OutboundLink")],1)]),v._v(" "),r("h2",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),r("p",[v._v("最大流 Max-Flow")]),v._v(" "),r("p",[v._v("Ford-Fulkerson 方法")]),v._v(" "),r("h3",{attrs:{id:"流网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流网络"}},[v._v("#")]),v._v(" 流网络")]),v._v(" "),r("p",[v._v("流网络 G = (V, E) 是一个有向图，图中每条边 (u, v) \\in E 有一个"),r("strong",[v._v("非负")]),v._v("的"),r("strong",[v._v("容量值")]),v._v(" c(u, v) >= 0。而且，如果边集合 E 包含一条边 (u, v)，则图中不存在反方向的边 (v, u)。如果 (u, v) \\notin E，为方便起见，定义 c(u, v) = 0。并且在图中不允许有自循环/自圈 (u, u)。")]),v._v(" "),r("p",[v._v("另外，在流网络的所有结点中，有两个特殊的结点："),r("strong",[v._v("源结点")]),v._v(" s (source) 和"),r("strong",[v._v("汇点")]),v._v(" t (terminal)。源结点入度为 0、汇点出度为 0。为方便起见，假定 V 中每个结点 v 都位于某条从 s 到 v 的路径上，即有 "),r("code",[v._v("s ~> v ~> t")]),v._v(" 路径。")]),v._v(" "),r("p",[v._v("因此，流网络图是"),r("strong",[v._v("弱连通")]),v._v("的。并且由于除源结点 s 外的每个结点都至少有一条进入的边，有 "),r("code",[v._v("|E| >= |V| - 1")]),v._v("。")]),v._v(" "),r("ul",[r("li",[v._v("流网络的性质主要如下：\n"),r("ul",[r("li",[v._v("流网络 G = (V, E) 是一个弱连通的有向图")]),v._v(" "),r("li",[v._v("所有边的权重为非负值，且每条边的权重值有上界 c(u, v)")]),v._v(" "),r("li",[v._v("任意两个结点 u, v \\in V，不能同时存在边 (u, v) 和边 (v, u)")]),v._v(" "),r("li",[v._v("如果某边 (u, v) 不存在，定义其权重值 c(u, v) = 0")]),v._v(" "),r("li",[v._v("图中没有自循环 (u, u)")]),v._v(" "),r("li",[v._v("通常来说，源结点 s 的入度为 0，汇点 t 的出度为 0")]),v._v(" "),r("li",[v._v("每个结点 v 都处于从 s 到 t 的某条路径上。即：从起点 s 发出的流量可以流经 v 到达终点 t")])])])]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/max-flow-1.png",alt:"max-flow-1"}})]),v._v(" "),r("p",[v._v("这里给出流的形式化定义。设 G = (V, E) 是一个"),r("strong",[v._v("流网络")]),v._v("，其"),r("strong",[v._v("容量函数")]),v._v("为 c。设 s 为网络的"),r("strong",[v._v("源结点")]),v._v("，t 为"),r("strong",[v._v("汇点")]),v._v("。G 中的"),r("strong",[v._v("流")]),v._v("是一个"),r("strong",[v._v("实值函数")]),v._v(" f: VxV -> R，满足如下两条性质：")]),v._v(" "),r("ol",[r("li",[r("strong",[v._v("容量限制")]),v._v("：（“流量有限额”）对于所有的结点 u, v \\in V，要求 0 <= f(u, v) <= c(u, v)")]),v._v(" "),r("li",[r("strong",[v._v("流量守恒")]),v._v("：（“流入等于流出”）对于所有的结点 u \\in V - {s, t}，要求 $ \\sum_{v \\in V} f(v, u) = \\sum_{v \\in V} f(u, v) $\n"),r("ul",[r("li",[v._v("当 (u, v) \\notin E 时，从结点 u 到结点 v 之间没有流，因此 f(u, v) == 0")])])])]),v._v(" "),r("p",[v._v("称非负数值 f(u, v) 为从结点 u 到结点 v 的流。一个流 f 的值 "),r("code",[v._v("|f|")]),v._v(" 定义如下：")]),v._v(" "),r("p",[v._v("$$ |f| = \\sum_{v \\in V} f(s, v) = \\sum_{v \\in V} f(v, s) $$")]),v._v(" "),r("p",[v._v("即，流 f 的值时从源结点流出的总流量 减去 流入源结点的总流量。这里符号 "),r("code",[v._v("|·|")]),v._v(" 仅用作表达流的值，而不是数的绝对值或者集合的基数值。")]),v._v(" "),r("p",[v._v("通常来说，一个流网络不会有任何进入源结点的边，即源结点的入度为 0，故求和项 $ \\sum_{v \\in V} f(v, s) $ 的值将是 0。但对于有的网络而言（比如"),r("strong",[v._v("残存网络")]),v._v("），流入源结点的流量十分重要。")]),v._v(" "),r("p",[v._v("在"),r("strong",[v._v("最大流问题")]),v._v("中，给定一个"),r("strong",[v._v("流网络")]),v._v(" G、一个"),r("strong",[v._v("源结点")]),v._v(" s、一个"),r("strong",[v._v("汇点")]),v._v(" t，目标是找到值最大的一个"),r("strong",[v._v("流")]),v._v("。")]),v._v(" "),r("h2",{attrs:{id:"ford-fulkerson-方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ford-fulkerson-方法"}},[v._v("#")]),v._v(" Ford-Fulkerson 方法")]),v._v(" "),r("p",[v._v("常用于解决最大流问题的 Ford-Fulkerson 方法，之所以被称为“方法”而不是“算法”，是因为它主要提供的是一种通用的解决思路，包含了几种运行时间不同的具体算法实现。")]),v._v(" "),r("p",[v._v("Ford-Fulkerson 方法依赖于三种重要思想："),r("strong",[v._v("残存网络")]),v._v("、"),r("strong",[v._v("增广路径")]),v._v(" 和 "),r("strong",[v._v("切割")]),v._v("。这三种思想与许多流算法和问题有关，它们是"),r("strong",[v._v("最大流最小切割定理")]),v._v("（《CLRS》定理 26.6）的精髓。该定理以"),r("strong",[v._v("流网络的切割")]),v._v("来表述最大流的值。")]),v._v(" "),r("p",[v._v("Ford-Fulkerson 方法"),r("strong",[v._v("循环增加流的值")]),v._v("：")]),v._v(" "),r("ul",[r("li",[v._v("在开始的时候，对于所有的结点 u, v \\in V，f(u, v) = 0，给出的初始流量为 0。")]),v._v(" "),r("li",[v._v("每一次迭代中，将图 G 的流值进行增加，增加的方法就是在一个关联的“残存网络” Gf 中寻找一条“增广路径”\n"),r("ul",[r("li",[v._v("一旦知道图 Gf 中的一条增广路径的边，就可以很容易地辨别出 G 中的一些具体的边，可以对这些边上的流量进行修改，从而增加流的值。")])])]),v._v(" "),r("li",[v._v("虽然 Ford-Fulkerson 方法的每次迭代都增加流（整体）的值，但是对于图 G 的一条特定边来说，其流量可能增加，也可能减少。\n"),r("ul",[r("li",[v._v("而且，对某些边的流进行缩减可能是必要的，以便让算法可以将更多的流从源结点发送到汇点。")])])]),v._v(" "),r("li",[v._v("重复对流进行这一过程，知道残存网络中不再存在增广路径为止。最大流最小切割定理将说明在算法终结时，该算法将获得一个最大流。")])]),v._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[v._v("FORD_FULKERSON_METHOD(G, s, t)\n1  initialize flow f to 0\n2  while there exists an augmenting path p in the residual network Gf\n3      augment flow f along p\n4  return f\n")])])]),r("p",[v._v("为了实现和分析 Ford-Fulkerson 方法，需要引入如下几个新的概念。")]),v._v(" "),r("h3",{attrs:{id:"残存网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#残存网络"}},[v._v("#")]),v._v(" 残存网络")]),v._v(" "),r("p",[v._v("从直观上看，给定流网络 G 和流量 f，残存网络 Gf 由那些 "),r("strong",[v._v("仍有空间对流量进行调整的边")]),v._v(" 构成。流网络的一条边"),r("strong",[v._v("可以允许的额外流量")]),v._v("等于 该边的容量 减去 该边上的流量。如果该差值为正，则将该条边置于残存网络图 Gf 中，并将其"),r("strong",[v._v("残存容量")]),v._v("设置为 cf(u, v) = c(u, v) - f(u, v)。对于图 G 中的边来说，只有能够允许额外流量的边才能被加入到图 Gf 中。如果边 (u, v) 的流量 f(u, v) 等于其容量 c(u, v)，则其 cf(u, v) == 0，该条边将不属于图 Gf。（注意，根据"),r("strong",[v._v("容量限制")]),v._v("原则，残存容量 cf(u, v) 不可能为负值）")]),v._v(" "),r("p",[v._v("残存网络 Gf 中可能包含图 G 中不存在的边。算法对流量进行操作的目标是增加总流量，为此，算法可能对某些特定边上的流量进行缩减，为了表示对一个正流量 f(u, v) 的缩减，将反向边 (v, u) 加入到图 Gf 中，并将其残存容量设置为 cf(v, u) = f(u, v)。即 一条边所能允许的反向流量最多将其正向流量抵消。残存网络中的这些反向边允许算法将已经发送出来的流量发送回去。")]),v._v(" "),r("p",[v._v("而将流量从同一条边发送回去等同于"),r("strong",[v._v("缩减")]),v._v("该条边的流量，这种操作在许多算法中都是必须的。")]),v._v(" "),r("p",[v._v("更形式化地说，假定有一个流网络 G = (V, E)，其源结点为 s，汇点为 t。设 f 为图 G 中的一个流，考虑结点对 u, v \\in V，定义"),r("strong",[v._v("残存容量")]),v._v(" cf(u, v) 如下：")]),v._v(" "),r("ul",[r("li",[v._v("若 (u, v) \\in E，则 cf(u, v) = c(u, v) - f(u, v)")]),v._v(" "),r("li",[v._v("若 (v, u) \\in E，则 cf(u, v) = f(v, u)")]),v._v(" "),r("li",[v._v("若是其它情况，则 cf(u, v) = 0")])]),v._v(" "),r("p",[v._v("由于已经假定在图 G 中边 (u, v) 和边 (v, u) 不能同时出现，故上述三种情况有且仅有一种会发生。")]),v._v(" "),r("p",[v._v("举例来说，如果容量限制 c(u, v) = 16，并且当前流量 f(u, v) = 11，则对 f(u, v) 可以增加的量最多为 cf(u, v) = 5，再多就超过边 (u, v) 的容量限制了。同时，允许算法从结点 v 向结点 u 最多返回 11 单位的流量（即全部当前流量），因此残存网络中反向边 cf(v, u) = 11。")]),v._v(" "),r("hr"),v._v(" "),r("p",[v._v("给定一个流网络 G = (V, E) 和一个流 f，则由 f 所诱导的图 G 的"),r("strong",[v._v("残存网络")]),v._v("为 Gf = (V, Ef)，其中边集 Ef = {(u, v) \\in V x V: cf(u, v) > 0}")]),v._v(" "),r("p",[v._v("即 残存网络的每条边（称为"),r("strong",[v._v("残存边")]),v._v("），必须允许大于 0 的流量通过。下面图 26-4 中的 (a) 图是前面图 26-1 (b) 的流网络 G 和流量 f 的重新绘制，图 26-4 (b) 描述的是对应的残存网络 Gf。Ef 中的边要么是 E 中原有的边，要么是其反向边，因此有 "),r("code",[v._v("|Ef| <= 2|E|")])]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-1.png",alt:"ford-fulkerson-1"}})]),v._v(" "),r("p",[v._v("残存网络 Gf 类似于一个容量为 cf 的流网络，但是不满足前面对流网络的定义，因为在 Gf 中可以有反平行边。除了反平行边这个区别外，流网络的其他性质 Gf 都有保留，因此可以在残存网络中定义一个流，它满足流的两条性质："),r("strong",[v._v("容量限制")]),v._v(" 和 "),r("strong",[v._v("流量守恒")]),v._v("。该流针对的是残存网络 Gf 中的残存容量 cf。")]),v._v(" "),r("p",[v._v("残存网络 Gf 中的一个流指出的是一条"),r("strong",[v._v("路线图")]),v._v("：如何在原来的流网络 G 中增加流。如果 f 是 G 的一个流，f' 是对应的残存网络 Gf 中的一个流，定义 f↑f' 为流 f' 对流 f 的"),r("strong",[v._v("递增")]),v._v(" (augmentation)，它是一个从 V x V 到 R 的函数，具体定义如下：")]),v._v(" "),r("ul",[r("li",[v._v("若 (u, v) \\in E，则 (f↑f')(u, v) = f(u, v) + f'(u, v) - f'(v, u)")]),v._v(" "),r("li",[v._v("其它情况，则 (f↑f')(u, v) = 0")])]),v._v(" "),r("p",[v._v("该定义背后的直观解释遵循残存网络的定义。因为在残存网络中"),r("strong",[v._v("将流量发送到反向边")]),v._v(" 等同于 在原来的网络中"),r("strong",[v._v("缩减流量")]),v._v("，所以将边 (u, v) 的流量增加 f'(u, v)，但减少 f'(v, u)。在残存网络中将流量推送回去 也被称为"),r("strong",[v._v("抵消操作")]),v._v(" (cancellation)。")]),v._v(" "),r("p",[v._v("举例来说，如果某公司将 5 箱货物从城市 u 发送到城市 v，同时将 2 箱同样的货物从城市 v 发送到城市 u，那么可以(从整体上来说)等价于 将 3 箱货物从城市 u 发送到城市 v。这类"),r("strong",[v._v("抵消操作")]),v._v("对于任何"),r("strong",[v._v("最大流算法")]),v._v("来说都是"),r("strong",[v._v("非常关键")]),v._v("的。")]),v._v(" "),r("hr"),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("引理 26.1")]),v._v("：设 G = (V, E) 为一个流网络，源结点为 s，汇点为 t，设 f 为 G 中的一个流。设 Gf 为由流 f 所诱导的 G 的残存网络，设 f' 为 Gf 中的一个流。那么函数 (f↑f') 是 G 的一个流，其值为 "),r("code",[v._v("|f↑f'| = |f| + |f'|")]),v._v("。")]),v._v(" "),r("p",[v._v("对引理 26.1 的证明主要有以下四点（具体证明参考《CLRS》Chapter 26.2）：")]),v._v(" "),r("ol",[r("li",[v._v("流量非负：(f↑f')(u, v) >= 0")]),v._v(" "),r("li",[v._v("容量限制：(f↑f')(u, v) <= c(u, v)")]),v._v(" "),r("li",[v._v("流量守恒：对于所有的结点 u \\in V - {s, t}，$ \\sum_{v \\in V} (f↑f')(u, v) = \\sum_{v \\in V} (f↑f')(v, u) $")]),v._v(" "),r("li",[v._v("计算 (f↑f') 的值，确保 "),r("code",[v._v("|f↑f'| = |f| + |f'|")])])]),v._v(" "),r("h3",{attrs:{id:"增广路径"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#增广路径"}},[v._v("#")]),v._v(" 增广路径")]),v._v(" "),r("p",[v._v("给定流网络 G = (V, E) 和流 f，"),r("strong",[v._v("增广路径")]),v._v(" p 是残存网络 Gf 中一条从源结点 s 到汇点 t 的"),r("strong",[v._v("简单路径")]),v._v("。根据残存网络的定义，对于一条增广路径上的边 (u, v)，可以增加其流量的幅度 最大为 cf(u, v)，再多会违反容量限制。")]),v._v(" "),r("p",[v._v("例如前面 图 26-4 (b) 中阴影覆盖的路径是一条增广路径。如果将图中的残存网络 Gf 看作一个流网络，那么可以对这条路径上的"),r("strong",[v._v("每条边的流量增加")]),v._v(" 4 个单位，而不会违反容量限制，因为该条路径上"),r("strong",[v._v("最小的残存容量")]),v._v("是 cf(v2, v3) = 4。")]),v._v(" "),r("p",[v._v("称在一条增广路径 p 上能够为每条边增加的流量的最大值 为路径 p 的"),r("strong",[v._v("残存容量")]),v._v("，该容量的表达式为：cf(p) = min{cf(u, v): (u, v) 属于路径 p}。下面的引理更加精确地阐述了此论断：")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("引理 26.2")]),v._v("：设 G = (V, E) 为一个流网络，设 f 为图 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。定义一个函数 fp: V x V -> R 如下：")]),v._v(" "),r("ul",[r("li",[v._v("若 (u, v) 在 p 上，则 fp(u, v) = cf(p)")]),v._v(" "),r("li",[v._v("若是其它情况，则 fp(u, v) = 0")])]),v._v(" "),r("p",[v._v("则 fp 是残存网络 Gf 中的一个流，其值为 "),r("code",[v._v("|fp| = cf(p) > 0")])]),v._v(" "),r("hr"),v._v(" "),r("p",[v._v("下面的推论证明，如果将流 f 增加 fp 的量，则将获得 G 的另一个流，该流的值更加接近最大值。图 26-4 (c) 描述的是对图 26-4 (a) 的流 f 增加图 26-4 (b) 所示的 fp 的量 所获得的结果，而图 26-4 (d) 描述的则是残存网络 Gf。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("推论 26.3")]),v._v("：设 G = (V, E) 为一个流网络，设 f 为 G 中的一个流，设 p 为残存网络 Gf 中的一条增广路径。设 fp 由引理 26.2 所定义，假定将 f 增加 fp 的量，则函数 "),r("code",[v._v("|f↑fp| = |f| + |fp| > |f|")]),v._v("。")]),v._v(" "),r("h3",{attrs:{id:"流网络和切割"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流网络和切割"}},[v._v("#")]),v._v(" 流网络和切割")]),v._v(" "),r("p",[v._v("Ford-Fulkerson 方法的核心就是"),r("strong",[v._v("沿着增广路径重复增加路径上的流量")]),v._v("，直到找到一个最大流为止。稍后证明的"),r("strong",[v._v("最大流最小切割定理")]),v._v("表明：一个流是最大流 当且仅当 其残存网络不包含任何增广路径。")]),v._v(" "),r("p",[v._v("流网络 G = (V, E) 中的一个切割 (S, T) 将结点集合 V 划分为 S 和 T=V-S 两个不相交集合，且使得源结点 s \\in S、汇点 t \\in T。这类似于最小生成树 MST 中的切割，不过这里是对有向图的切割，而非无向图。")]),v._v(" "),r("p",[v._v("若 f 是一个流，则定义横跨切割 (S, T) 的"),r("strong",[v._v("净流量")]),v._v(" f(S, T) 如下：")]),v._v(" "),r("p",[v._v("$$ f(S, T) = \\sum_{u \\in S} \\sum_{v \\in T} f(u, v) - \\sum_{u \\in S} \\sum_{v \\in T} f(v, u) $$")]),v._v(" "),r("p",[v._v("切割 (S, T) 的"),r("strong",[v._v("容量")]),v._v("是：")]),v._v(" "),r("p",[v._v("$$ c(S, T) = \\sum_{u \\in S} \\sum_{v \\in T} c(u, v) $$")]),v._v(" "),r("p",[v._v("一个网络的"),r("strong",[v._v("最小切割")]),v._v("是整个网络中"),r("strong",[v._v("容量最小的切割")]),v._v("。")]),v._v(" "),r("hr"),v._v(" "),r("p",[v._v("流的定义和切割容量的定义之间不存在对称性，但这种不对称性是有意而为，并且很重要。对于容量来说，只计算从集合 S 发出、进入集合 T 的边的容量，而忽略反方向边上的容量。对于流，考虑的则是从 S 到 T 的总流量 减去 (反方向)从 T 到 S 的流量。")]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-2.png",alt:"ford-fulkerson-2"}})]),v._v(" "),r("p",[v._v("下面的引理将证明，对于给定流 f，横跨任何切割的净流量都相同，都等于 "),r("code",[v._v("|f|")]),v._v("，即流的值。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("引理 26.4")]),v._v("：设 f 为流网络 G 的一个流，该流网络的源结点为 s，汇点为 t，设 (S, T) 为流网络 G 的"),r("strong",[v._v("任意切割")]),v._v("，则横跨切割 (S, T) 的净流量为 f(S, T) = "),r("code",[v._v("|f|")]),v._v("。")]),v._v(" "),r("p",[v._v("引理 26.4 的如下推论 说明如何使用切割容量来限定一个流的值。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("推论 26.5")]),v._v("：流网络 G 中任意流 f 的值不能超过 G 的任意切割的容量。")]),v._v(" "),r("p",[v._v("此推论给出的一个直接结论是："),r("strong",[v._v("一个流网络中最大流的值不能超过该网络最小切割的容量")]),v._v("。这就是下面要来陈述和证明的非常重要的最大流最小切割定理。该定理表明一个最大流的值 事实上等于一个最小切割的容量。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("定理 26.6")]),v._v("（"),r("strong",[v._v("最大流最小切割定理")]),v._v("）：设 f 为流网络 G = (V, E) 中的一个流，该流网络的源结点为 s，汇点为 t，则下面的条件是等价的：")]),v._v(" "),r("ol",[r("li",[v._v("f 是 G 的一个最大流。")]),v._v(" "),r("li",[v._v("残存网络 Gf 不包含任何增广路径。\n"),r("ul",[r("li",[v._v("增广路径：残存网络 Gf 中一条从源结点 s 到汇点 t 的简单路径。")])])]),v._v(" "),r("li",[v._v("最大流的值 "),r("code",[v._v("|f|")]),v._v(" = c(S, T)，其中 (S, T) 是流网络 G 的某个切割。")])]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-3.png",alt:"ford-fulkerson-3"}})]),v._v(" "),r("h2",{attrs:{id:"基本的-ford-fulkerson-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本的-ford-fulkerson-算法"}},[v._v("#")]),v._v(" 基本的 Ford-Fulkerson 算法")]),v._v(" "),r("p",[v._v("在 Ford-Fulkerson 方法的每次迭代中，寻找某条增广路径 p，然后使用 p 来对流 f 进行修改（增加）。正如引理 26.2 和推论 26.3 所示，以 f↑fp 来替换 f，从而获得一个值为 "),r("code",[v._v("|f| + |fp|")]),v._v(" 的更大的流。")]),v._v(" "),r("p",[v._v("在如下算法实现中，通过为每条边 (u, v) \\in E 更新流属性 (u, v).f 来计算流网络 G = (V, E) 中的最大流。如果边 (u, v) \\notin E，则设置 (u, v).f = 0。另外，假设流网络各边的容量 c(u, v) 都已经给出，如果边 (u, v) \\notin E，则设置 c(u, v) = 0。根据如下式子来计算残存容量 cf(u, v)。代码中的表达式 cf(p) 只是一个临时变量，用于存放路径 p 的残存容量。")]),v._v(" "),r("ul",[r("li",[v._v("若 (u, v) \\in E，则 cf(u, v) = c(u, v) - f(u, v)")]),v._v(" "),r("li",[v._v("若 (v, u) \\in E，则 cf(u, v) = f(v, u)")]),v._v(" "),r("li",[v._v("若是其它情况，则 cf(u, v) = 0")])]),v._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[v._v("FORD_FULKERSON(G, s, t)\n1  for each edge(u, v) \\in G.E\n2      (u, v).f = 0\n3  while there exists a path p from s to t in the residual network Gf\n4      cf(p) = min { cf(u, v): (u, v) is in path p }\n5      for each edge(u, v) in p\n6          if (u, v) \\in E\n7              (u, v).f = (u, v).f + cf(p)\n8          else\n9              (v, u).f = (v, u).f - cf(p)\n")])])]),r("p",[r("code",[v._v("FORD_FULKERSON(G, s, t)")]),v._v(" 算法是对 "),r("code",[v._v("FORD_FULKERSON_METHOD(G, s, t)")]),v._v(" 方法的简单扩展。算法流程描述如下：")]),v._v(" "),r("ol",[r("li",[v._v("在 1～2 行，将流 f 初始化为 0。")]),v._v(" "),r("li",[v._v("在 3～9 行的 while 循环中，重复在残存网络 Gf 中寻找一条增广路径 p，然后使用残存容量 cf(p) 来对路径 p 上的流 f 进行增加。路径 p 上的一条边要么是原来网络中的一条边，要么是原来网络中的边 的反向边。\n"),r("ul",[r("li",[v._v("在 4 行，找出路径 p 中的最小残存容量 cf(u, v)。")]),v._v(" "),r("li",[v._v("在 5～9 行的 for 循环中，对路径上 p 的每条边 (u, v) 的流量进行更新。")]),v._v(" "),r("li",[v._v("在 6～7 行，如果残存边 (u, v) 是原来流网络中的一条边，则增加其流量 (u, v).f")]),v._v(" "),r("li",[v._v("在 8～9 行，如果残存边 (u, v) 不是原来流网络中的一条边，则减少其反向边 (v, u) 流量 (v, u).f")])])]),v._v(" "),r("li",[v._v("最后，当 while 循环结束时，不再有增广路径。根据最大流最小切割定理，此时流 f 就是最大流。")])]),v._v(" "),r("h3",{attrs:{id:"ford-fulkerson-算法的分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ford-fulkerson-算法的分析"}},[v._v("#")]),v._v(" Ford-Fulkerson 算法的分析")]),v._v(" "),r("p",[v._v("Ford-Fulkerson 算法的运行时间取决于算法第 3 行是如何寻找增广路径 p 的。如果使用广度优先搜索 BFS 来寻找增广路径，算法的运行时间是多项式数量级。如果选择不好，"),r("code",[v._v("FORD_FULKERSON")]),v._v(" "),r("strong",[v._v("算法")]),v._v("可能不会终止：流的值会随着后续的递增 (augmentation) 而增加，但它却不一定收敛于最大的流值。")]),v._v(" "),r("p",[v._v("另外，只有当变得容量为"),r("strong",[v._v("无理数")]),v._v("时，"),r("code",[v._v("FORD_FULKERSON_METHOD")]),v._v(" "),r("strong",[v._v("方法")]),v._v("才可能无法终止。下面均假定所选择的任意增广路径 p 和所有的容量 c 都是整数值。在实际情况中，最大流问题中的容量常常都是整数。如果容量为有理数，则可以通过乘以某个系数（或者采用近似值）来将其转换为整数。")]),v._v(" "),r("hr"),v._v(" "),r("p",[v._v("如果 f* 表示转换后网络中的一个最大流，则在 "),r("code",[v._v("FORD_FULKERSON")]),v._v(" 算法的一个直接实现中，执行第 3～9 行的 while 循环的次数最多为 "),r("code",[v._v("|f*|")]),v._v(" 次，因为流量值在每次迭代中至少增加一个单位。")]),v._v(" "),r("p",[v._v("如果用于实现流网络 G = (V, E) 的数据结构是合理的，并且寻找一条增广路径 p 的算法时间是线性的（比如 DFS 和 BFS），则整个 while 循环的执行将非常高效。假设有一个与有向图 G' = (V, E') 相对应的数据结构，这里 E' = {(u, v): (u, v) \\in E 或者 (v, u) \\in E}。网络 G 中的边也是网络 G' 中的边，因此在这一数据结构中，保持其容量和流就非常简单了。给定网络 G 的一个流 f，残存网络 Gf 中的边由网络 G' 中所有满足条件 cf(u, v) > 0 的边 (u, v) 所构成，其中 cf 遵守前述残存容量的性质。")]),v._v(" "),r("p",[v._v("因此，如果使用深度优先搜索 DFS 或广度优先搜索 BFS，在一个残存网络中找到一条路径的时间应是 "),r("code",[v._v("O(|V| + |E'|) = O(|E|)")]),v._v("。而 while 循环的每一遍执行所需的时间因此为 "),r("code",[v._v("O(|E|)")]),v._v("，这与算法第 1～2 行的初始化成本一样，从而整个 "),r("code",[v._v("FORD_FULKERSON")]),v._v(" 算法的运行时间为 "),r("code",[v._v("O(|E|·|f*|)")]),v._v("。")]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-4.png",alt:"ford-fulkerson-4"}})]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-5.png",alt:"ford-fulkerson-5"}})]),v._v(" "),r("p",[v._v("当容量都是整数值且最优的流量值 "),r("code",[v._v("|f*|")]),v._v(" 较小时，"),r("code",[v._v("FORD_FULKERSON")]),v._v(" 算法的运行时间相等不错。但当最优流量值 "),r("code",[v._v("|f*|")]),v._v(" 取值较大时，可能会效率很慢，如图 26-7 示例。")]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-6.png",alt:"ford-fulkerson-6"}})]),v._v(" "),r("h2",{attrs:{id:"edmonds-karp-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#edmonds-karp-算法"}},[v._v("#")]),v._v(" Edmonds-Karp 算法")]),v._v(" "),r("p",[v._v("可以通过在 "),r("code",[v._v("FORD_FULKERSON")]),v._v(" 算法第 3 行寻找增广路径 p 的操作中 使用广度优先搜索 BFS 来改善算法的效率。即 在残存网络中选择的增广路径是一条从源结点 s 到汇点 t 的(无权重)最短路径，BFS 时每条边的权重均为单位距离。称如此实现的 Ford-Fulkerson 方法为 Edmonds-Karp 算法，其运行时间为 "),r("code",[v._v("O(|V|·|E|^2)")]),v._v("，这就与最优流量值 "),r("code",[v._v("|f*|")]),v._v(" 的取值大小无关了。")]),v._v(" "),r("p",[v._v("对 Edmonds-Karp 算法的分析取决于残存网络 Gf 中结点之间的距离。下面的引理使用符号 df(u, v) 来表示残存网络 Gf 中从结点 u 到结点 v 的(无权重)最短路径距离，其中每条边的权重为单位距离。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("引理 26.7")]),v._v("：如果 Edmonds-Karp 算法运行在流网络 G = (V, E) 上，该网络的源结点为 s、汇点为 t，则对于所有的结点 v \\in V-{s, t}，残存网络 Gf 中"),r("strong",[v._v("最短路径距离")]),v._v(" df(u, v) 随着每次流量的递增 而"),r("strong",[v._v("单调递增")]),v._v("。")]),v._v(" "),r("p",[v._v("下面的定理给出了 Edmonds-Karp 算法的迭代次数的上界。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("定理 26.8")]),v._v("：如果 Edmonds-Karp 算法运行在源结点为 s、汇点为 t 的流网络 G = (V, E) 上，则该算法所执行的流量递增操作的总次数为 "),r("code",[v._v("O(|V|·|E|)")]),v._v("。")]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/ford-fulkerson-7.png",alt:"ford-fulkerson-7"}})]),v._v(" "),r("p",[v._v("由于在用广度优先搜索 BFS 寻找增广路径时，"),r("code",[v._v("FORD_FULKERSON(G, s, t)")]),v._v(" 中的每次迭代可以在 "),r("code",[v._v("O(|E|)")]),v._v(" 时间内实现，所以 Edmonds-Karp 算法的总运行时间为 "),r("code",[v._v("O(|V|·|E|^2)")]),v._v("。")]),v._v(" "),r("p",[v._v("而"),r("strong",[v._v("推送-重贴标签")]),v._v("算法能够取得更好的界，可以达到 "),r("code",[v._v("O(|V|^2·|E|)")]),v._v(" 甚至 "),r("code",[v._v("O(|V|^3)")]),v._v("。")]),v._v(" "),r("h2",{attrs:{id:"最大二分匹配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最大二分匹配"}},[v._v("#")]),v._v(" 最大二分匹配")]),v._v(" "),r("p",[v._v("一些组合问题可以很容易地标注为最大流问题，例如多源结点多汇点的最大流问题。其它一些组合问题在表面上看似与流网络没有什么关系，但实际上却能够归约到最大流问题，比如"),r("strong",[v._v("最大二分匹配")]),v._v("问题：在一个二分图(或称“二部图”)中找出一个最大匹配。")]),v._v(" "),r("p",[v._v("解决此问题 将用到由 Ford-Fulkerson 方法所提供的完整性性质 (integrality property)。使用 Ford-Fulkerson 方法能够在 "),r("code",[v._v("O(|V|·|E|)")]),v._v(" 时间内解决图 G = (V, E) 的最大二分匹配问题。")]),v._v(" "),r("h3",{attrs:{id:"最大二分匹配问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#最大二分匹配问题"}},[v._v("#")]),v._v(" 最大二分匹配问题")]),v._v(" "),r("p",[v._v("二分图的最大匹配 (Bipartite Graph Maximum Matching)")]),v._v(" "),r("p",[v._v("给定一个"),r("strong",[v._v("无向图")]),v._v(" G = (V, E)，一个"),r("strong",[v._v("匹配")]),v._v(" (match) 是边的一个子集 $ M \\subseteq E $，使得对于所有结点 v \\in V，子集 M 中"),r("strong",[v._v("最多有一条边")]),v._v("与结点 v 关联。如果子集 M 中的某条边与结点 v 关联，则称结点 v "),r("strong",[v._v("由 M 所匹配")]),v._v("；否则，结点 v 就是"),r("strong",[v._v("没有匹配")]),v._v("的。"),r("strong",[v._v("最大匹配")]),v._v("是具有"),r("strong",[v._v("最大基数")]),v._v("的边集 M。这里的“最大”也是“极大”的意思。")]),v._v(" "),r("p",[v._v("最大匹配问题不仅限于 二分图，即两类事物的最大匹配，而是可以在 n 分图 (n >= 2) 上寻找最大匹配。而二分图的匹配是其中最基础的，也最具有代表性。")]),v._v(" "),r("p",[v._v("在一个二分图中，结点集合 V 有划分 {L, R}，并且边集合 E 中所有的边都横跨 L 和 R。即：任意边 (u, v) \\in E，要么 u \\in L 且 v \\in R，要么 u \\in R 且 v in L。进一步假定无向图 G 是"),r("strong",[v._v("连通")]),v._v("的，因此 V 中的每个结点至少关联了一条边。")]),v._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/bipartite-graph-maximum-matching-1.png",alt:"bipartite-graph-maximum-matching-1"}})]),v._v(" "),r("p",[v._v("在二分图中寻找最大匹配问题有许多实际的应用。例如，把一个机器集合 L 和待执行的任务集合 R 相匹配。E 中有边 (u, v) 就说明机器 u \\in L 能够完成任务 v \\in R。最大匹配能够让尽可能多的机器同时运行。")]),v._v(" "),r("p",[v._v("最大二分匹配问题仅需匹配的基数越大越好，因此边的权重都设定为单位权重，即无权图。但如果考虑边的权重，则可以建模更多的场景，如果在带权图中 希望匹配的总权重值最高，则是最佳匹配的问题了。")]),v._v(" "),r("h3",{attrs:{id:"寻找最大二分匹配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#寻找最大二分匹配"}},[v._v("#")]),v._v(" 寻找最大二分匹配")]),v._v(" "),r("p",[v._v("使用 Ford-Fulkerson 方法可以在 "),r("code",[v._v("O(|V|·|E|)")]),v._v(" 时间内找出(无权)无向二分图 G = (V, E) 的最大匹配。解决这一问题的关键技巧是增加额外的源结点 s 和汇点 t，构造出一个流网络，其中的流对应于匹配，如图 26-8 (c) 所示。")]),v._v(" "),r("p",[v._v("将二分图 G 所对应的流网络 G' = (V', E') 定义如下：设源结点 s 和汇点 t 为原本不属于结点集合 V 的新结点，并设 V' = V \\cup {s, t}。如果图 G 的结点集划分为 V = L \\cup R，则 E 中所有从 L 指向 R 的边都是流网络 G' 的边。此外 G' 中的边还包括 "),r("code",[v._v("|V|")]),v._v(" 条新的有向边。E' = {(s, u): u \\in L} \\cup E \\cup {(v, t): v \\in R}")]),v._v(" "),r("p",[v._v("最后，给 E' 中的每条边赋予"),r("strong",[v._v("单位容量")]),v._v("。由于结点集 V 中的每个结点至少有一条相连的边，"),r("code",[v._v("|E >= |V| / 2")]),v._v("。因此 "),r("code",[v._v("|E| <= |E'| = |E| + |V| <= 3 |E|")]),v._v("，所以 "),r("code",[v._v("|E'| = \\Theta(|E|)")]),v._v("。")]),v._v(" "),r("p",[v._v("下面的引理证明了图 G 中的一个匹配直接对应 G 所对应的流网络 G' 中的一个流。对于流网络 G = (V, E) 中的一个流 f 来说，如果对于所有的边 (u, v) \\in V x V，f(u, v) 都是整数值，则称流 f 是"),r("strong",[v._v("整数值")]),v._v("的。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("引理 26.9")]),v._v("：设 G = (V, E) 为一个二分图，其结点划分为 V = L \\cup R，设 G' = (V', E') 是图 G 所对应的流网络。如果 M 是 G 中的一个匹配，则流网络 G' 中存在一个整数值的流 f，使得 "),r("code",[v._v("|f| = |M|")]),v._v("。相反，如果 f 是 G' 中的一个整数值的流，则图 G 中存在一个匹配 M，使得 "),r("code",[v._v("|M| = |f|")]),v._v("。")]),v._v(" "),r("p",[v._v("基于引理 26.9，希望得出如下结论：二分图 G 中的一个最大匹配对应于流网络 G' 中的一个最大流，并且可以通过在流网络 G' 上运行一个最大流算法来计算出图 G 中的最大匹配。此结论的得来 存在的唯一障碍是：最大流算法可能返回流网络 G' 中一个非整数的流 f(u, v)，即便流的值 "),r("code",[v._v("|f|")]),v._v(" 本身必须是整数。不过，下面的定理将说明，如果使用 Ford-Fulkerson 方法，前述问题不会发生，因此前述结论能够成立。")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("定理 26.10")]),v._v("（"),r("strong",[v._v("完整性定理")]),v._v("）：如果容量函数 c 只能取整数值，则 Ford-Fulkerson 方法所生成的最大流 f 满足 "),r("code",[v._v("|f|")]),v._v(" 是整数值的性质。而且，对于所有的结点 u 和 v，f(u, v) 的值都是整数。")]),v._v(" "),r("p",[v._v("定理 26.10 可以通过对迭代次数进行归纳来证明。下面给出引理 26.9 的一个推论：")]),v._v(" "),r("p",[v._v("《CLRS》"),r("strong",[v._v("推论 26.11")]),v._v("：二分图 G 中的一个最大匹配 M 的基数 等于 其对应的流网络 G' 中某一最大流 f 的值。")]),v._v(" "),r("p",[v._v("因此，给定一个无向二分图 G，可以通过创建流网络 G'，在其上运行 Ford-Fulkerson 方法来找到一个最大匹配。这个最大匹配 M 可以直接从找到的整数最大流 f 中获得。由于二分图中任何匹配的基数最大值为 min(L, R) = "),r("code",[v._v("O(|V|)")]),v._v("，G' 中最大流的值为 "),r("code",[v._v("O(|V|)")]),v._v("。又由于 "),r("code",[v._v("|E'| = \\Theta(|E|)")]),v._v("，所以可以在 "),r("code",[v._v("O(|V|·|E'|) = O(|V|·|E|)")]),v._v(" 时间内找到一个二分图的最大匹配。")]),v._v(" "),r("h3",{attrs:{id:"hopcroft-karp-最大二分匹配算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hopcroft-karp-最大二分匹配算法"}},[v._v("#")]),v._v(" Hopcroft-Karp 最大二分匹配算法")]),v._v(" "),r("p",[v._v("目前最快的解决最大二分匹配问题的算法是由 Hopcroft 和 Karp[176] 所发明的，其运行时间为 "),r("code",[v._v("O(|E|·\\sqrt(|V|))")])]),v._v(" "),r("p",[v._v("[176] John E. Hopcroft and Richard M. Karp. An n^{5/2} algorithm for maximum matchings in biparite graphs. "),r("em",[v._v("SIAM Journal on Computing")]),v._v(", 2(4):225-231, 1973.")]),v._v(" "),r("p",[v._v("给定一个无向二分图 G = (V, E)，其中 V = L \\cup R 并且所有的边都恰有一个端点在集合 L 中，而另一个端点在集合 R 中。设 M 为图 G 的一个匹配。")]),v._v(" "),r("p",[v._v("对于图 G 中的一条简单路径 P，如果该路径的起点是 L 中一个未匹配的结点，终结点是集合 R 中的一个未匹配的结点，而路径上的边交替属于 M 和 E-M，则称路径 P 是一条相对于 M 的增广路径（此增广路径的定义与流网络中的增广路径相关，但并不相同）。")]),v._v(" "),r("p",[v._v("在这里，将一条路径看作是一系列的边，而不是一系列的结点。一条关于匹配 M 的最短增广路径是一条包含最少边数的增广路径。")]),v._v(" "),r("p",[v._v("给定两个集合 A 和 B，"),r("strong",[v._v("对称差")]),v._v(" A \\oplus B 定义为 (A-B) \\cup (B-A)，即仅在一个集合中出现的元素。")]),v._v(" "),r("p",[v._v("详见《CLRS》思考题 26-6")]),v._v(" "),r("h3",{attrs:{id:"完全匹配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#完全匹配"}},[v._v("#")]),v._v(" 完全匹配")]),v._v(" "),r("p",[r("strong",[v._v("完全匹配")]),v._v("是指图中所有的结点都得到匹配的匹配。设 G = (V, E) 是结点划分为 V = L \\cup R 的无向二分图，其中 "),r("code",[v._v("|L| == |R|")]),v._v("。对于任意结点子集 $ X \\subseteq V $，定义 X 的"),r("strong",[v._v("邻居")]),v._v("为：N(X) = {y \\in V: 对某个 x \\in X，(x, y) \\in E}，即由与集合 X 中的元素 相邻的结点所构成的集合。")]),v._v(" "),r("p",[v._v("关于完全匹配，有 "),r("strong",[v._v("Hall 定理")]),v._v("：图 G 中存在一个完全匹配 当且仅当 对于每个边子集 $ A \\subseteq L $，有 "),r("code",[v._v("|A| <= |N(A)|")]),v._v("。")]),v._v(" "),r("h3",{attrs:{id:"d-正则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#d-正则"}},[v._v("#")]),v._v(" d 正则")]),v._v(" "),r("p",[v._v("对于一个结点划分为 V = L \\cup R 的无向二分图 G = (V, E) 而言，如果每个属于结点集合 V 的结点 v 的度数都是自然数 d，则称该二分图是 "),r("strong",[v._v("d 正则的")]),v._v("。对于每个 d 正则的二分图，都有 "),r("code",[v._v("|L| == |R|")]),v._v("。")]),v._v(" "),r("p",[v._v("可以证明：每个 d 正则二分图的匹配基数都是 "),r("code",[v._v("|L|")]),v._v("。")]),v._v(" "),r("p",[v._v("证明思路：该二分图对应的流网络的一个最小切割的容量为 "),r("code",[v._v("|L|")]),v._v("。")]),v._v(" "),r("h2",{attrs:{id:"python-代码范例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#python-代码范例"}},[v._v("#")]),v._v(" Python 代码范例")]),v._v(" "),r("p",[v._v("Python 环境：Python 3.7")]),v._v(" "),r("h3",{attrs:{id:"ford-fulkerson-最大流算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ford-fulkerson-最大流算法"}},[v._v("#")]),v._v(" Ford-Fulkerson 最大流算法")]),v._v(" "),r("ul",[r("li",[v._v("Ford-Fulkerson 方法\n"),r("ul",[r("li",[v._v("Ford-Fulkerson 算法 O(V |f*|)")]),v._v(" "),r("li",[v._v("Edmonds-Karp 算法 O(V E^2)")])])]),v._v(" "),r("li",[v._v("Push-Relabel 推送-重贴标签方法\n"),r("ul",[r("li",[v._v("Push-Relabel 通用的推送-重贴标签算法 O(V^2 E)")]),v._v(" "),r("li",[v._v("Relabel-To-Front 前置重贴标签算法 O(V^3)")])])])]),v._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/max-flow-matching/ford-fulkerson.py",target:"_blank",rel:"noopener noreferrer"}},[v._v("GitHub Code Link"),r("OutboundLink")],1)]),v._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" 参考资料")]),v._v(" "),r("ul",[r("li",[v._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26")])])])}),[],!1,null,null,null);_.default=o.exports}}]);