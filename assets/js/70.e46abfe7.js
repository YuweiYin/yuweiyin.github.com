(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{314:function(t,e,o){"use strict";o.r(e);var a=o(28),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"algorithm-computational-geometry"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-computational-geometry"}},[t._v("#")]),t._v(" Algorithm - Computational Geometry")]),t._v(" "),o("ul",[o("li",[t._v("For source files, please refer to the "),o("a",{attrs:{href:"https://github.com/YuweiYin/Algorithm_YuweiYin",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Repository"),o("OutboundLink")],1),t._v(". (I'd be happy to see more people like this project and give "),o("strong",[t._v("Star")]),t._v(".)")])]),t._v(" "),o("h2",{attrs:{id:"目录"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),o("ul",[o("li",[t._v("计算几何学 Computational Geometry\n"),o("ul",[o("li",[t._v("(欧几里得空间)点和线段的构造")]),t._v(" "),o("li",[t._v("基本几何运算: 对位四则运算、内积、叉积、距离、夹角")]),t._v(" "),o("li",[t._v("判断线段相交\n"),o("ul",[o("li",[t._v("给定两条线段，判断二者是否相交")]),t._v(" "),o("li",[t._v("给定线段集合，判断其中是否存在相交线段")])])]),t._v(" "),o("li",[t._v("凸包问题: 给定点集，寻找该点集的凸包 (convex hull)\n"),o("ul",[o("li",[t._v("Graham 扫描法")]),t._v(" "),o("li",[t._v("Jarvis 步进法")])])]),t._v(" "),o("li",[t._v("最远/最近点对问题\n"),o("ul",[o("li",[t._v("给定凸多边形的顶点集合，求出该点集的最远点对: 旋转卡壳算法 (Rotating Calipers)")]),t._v(" "),o("li",[t._v("给定点集，求出该点集的最近点对")])])])])])]),t._v(" "),o("h2",{attrs:{id:"_0-计算几何学"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_0-计算几何学"}},[t._v("#")]),t._v(" 0. 计算几何学")]),t._v(" "),o("p",[t._v("计算几何学是计算机科学的一个分支，专门研究那些用来解决"),o("strong",[t._v("几何问题")]),t._v("的算法。在现代工程与数学界，计算几何学在不同的领域里有着广泛的应用，包括计算机图形学、机器人学、VLSI 电路设计、计算机辅助设计、分子建模、冶金学、制造业、纺织品设计学、林学和统计学等。计算几何学问题的"),o("strong",[t._v("输入")]),t._v("通常是"),o("strong",[t._v("对几何对象集合的描述")]),t._v("，如点集、线段集，或者一个多边形中按顺/逆时针顺序排列的顶点集合。而问题的"),o("strong",[t._v("输出")]),t._v("通常是回答"),o("strong",[t._v("关于这些几何对象的查询")]),t._v("，例如，"),o("strong",[t._v("直线是否相交")]),t._v("；或者是否为一个新的几何对象，例如，点集的"),o("strong",[t._v("凸包问题")]),t._v(" (convex hull，即最小封闭凸多边形)。")]),t._v(" "),o("p",[t._v("这里将研究"),o("strong",[t._v("欧式二维空间")]),t._v("内(即平面上)的若干个计算几何算法。用点集 {p1, p2, p3, ...} 来表示每一个数输入对象，其中每个 pi = {xi, yi}, 且 $ xi, yi \\in R $。例如，以顶点序列 "),o("code",[t._v("<p_0, p_1, p_2, ..., p_{n-1}>")]),t._v(" 来表示一个含有 n 个顶点的多边形 P (polygon)，这些点以在 P 的边界上出现的顺序来排列。")]),t._v(" "),o("p",[t._v("计算几何学也可以应用到三维，甚至更高维度的空间上，不过这样的问题及其解决方案较难可视化。而且 即便是在二维空间上，也能够充分展现计算几何学的精妙之处。")]),t._v(" "),o("h2",{attrs:{id:"_1-线段的性质"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-线段的性质"}},[t._v("#")]),t._v(" 1. 线段的性质")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-1.png",alt:"computational-geometry-1"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-2.png",alt:"computational-geometry-2"}})]),t._v(" "),o("h3",{attrs:{id:"_1-1-叉积"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-叉积"}},[t._v("#")]),t._v(" 1.1. 叉积")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-3.png",alt:"computational-geometry-3"}})]),t._v(" "),o("p",[t._v("事实上，二维向量的"),o("strong",[t._v("叉积")]),t._v("是一个三维的概念。根据“右手法则”，它是一个与 p1 和 p2 都垂直的向量，其量值为 "),o("code",[t._v("| x1 y2 - x2 y1 |")]),t._v("。在这里，不考虑叉积作为一个向量的方向性，而仅考虑其模长。")]),t._v(" "),o("h3",{attrs:{id:"_1-2-确定连续线段是向左转还是向右转"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-确定连续线段是向左转还是向右转"}},[t._v("#")]),t._v(" 1.2. 确定连续线段是向左转还是向右转")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-4.png",alt:"computational-geometry-4"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-5.png",alt:"computational-geometry-5"}})]),t._v(" "),o("h3",{attrs:{id:"_1-3-判定两条线段是否相交"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-判定两条线段是否相交"}},[t._v("#")]),t._v(" 1.3. 判定两条线段是否相交")]),t._v(" "),o("p",[t._v("为判定两条线段是否相交，需要检查每条线段是否"),o("strong",[t._v("跨越")]),t._v("了包含另一条线段的直线。如果点 p1 位于某条直线的一边，而点 p2 位于该直线的另一边，则称线段 p1p2 跨越了这条直线。若 p1 或 p2 恰好落在直线上，则出现边界情况。两条线段相交当且仅当下面两个条件"),o("strong",[t._v("至少成立一个")]),t._v("：")]),t._v(" "),o("ol",[o("li",[t._v("对于这两条线段，其中的每条线段都"),o("strong",[t._v("跨越")]),t._v("了包含另一条线段的直线。")]),t._v(" "),o("li",[t._v("一条线段的某个端点落在另一条线段上。（边界情况）")])]),t._v(" "),o("p",[t._v("下面的过程实现了上述思想。如果线段 p1p2 和 p3p4 相交，那么 "),o("code",[t._v("SEGMENTS_INTERSECT")]),t._v(" 返回 True，否则返回 False。它调用了子过程 "),o("code",[t._v("DIRECTION")]),t._v("，利用上述的叉积方法计算出线段的相应方向；另外还调用了子过程 "),o("code",[t._v("ON_SEGMENT")]),t._v(" 来判断一个与线段共线的点 是否位于这条线段上（包含线段的端点）。")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("SEGMENTS_INTERSECT(p1, p2, p3, p4)\n1  d_1 = DIRECTION(p3, p4, p1)\n2  d_2 = DIRECTION(p3, p4, p2)\n3  d_3 = DIRECTION(p1, p2, p3)\n4  d_4 = DIRECTION(p1, p2, p4)\n5  if ((d_1 > 0 and d_2 < 0) or (d_1 < 0 and d_2 > 0) and\n       (d_3 > 0 and d_4 < 0) or (d_3 < 0 and d_4 > 0))\n6      return True\n7  elif d_1 == 0 and ON_SEGMENT(p3, p4, p1)\n8      return True\n9  elif d_2 == 0 and ON_SEGMENT(p3, p4, p2)\n10     return True\n11 elif d_3 == 0 and ON_SEGMENT(p1, p2, p3)\n12     return True\n13 elif d_4 == 0 and ON_SEGMENT(p1, p2, p4)\n14     return True\n15 else\n16     return False\n")])])]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("DIRECTION(pi, pj, pk)\n1  return (pk - pi) * (pj - pi)\n")])])]),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("ON_SEGMENT(pi, pj, pk)\n1  if min(xi, xj) <= xk <= max(xi, xj) and\n       min(yi, yj) <= yk <= max(yi, yj)\n2      return True\n3  else\n4      return False\n")])])]),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-6.png",alt:"computational-geometry-6"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-7.png",alt:"computational-geometry-7"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-8.png",alt:"computational-geometry-8"}})]),t._v(" "),o("h3",{attrs:{id:"_1-4-叉积的其它应用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-叉积的其它应用"}},[t._v("#")]),t._v(" 1.4. 叉积的其它应用")]),t._v(" "),o("p",[t._v("当需要根据相对于给定原点的极角大小 对给定的点集进行排序时，可以使用叉积进行排序过程中的比较。另外，可以用红黑树来维护一个线段集合的垂直顺序。并不是显式地记录红黑树关键字值，而是通过计算叉积来确定 与同一个给定的垂直线相交的两条线段的相对位置。")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-9.png",alt:"computational-geometry-9"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/computational-geometry-10.png",alt:"computational-geometry-10"}})]),t._v(" "),o("h2",{attrs:{id:"_2-确定任意一对线段是否相交"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-确定任意一对线段是否相交"}},[t._v("#")]),t._v(" 2. 确定任意一对线段是否相交")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-1.png",alt:"segment-intersect-1"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-2.png",alt:"segment-intersect-2"}})]),t._v(" "),o("h3",{attrs:{id:"_2-1-线段排序"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-线段排序"}},[t._v("#")]),t._v(" 2.1. 线段排序")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-3.png",alt:"segment-intersect-3"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-4.png",alt:"segment-intersect-4"}})]),t._v(" "),o("h3",{attrs:{id:"_2-2-移动扫除线"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-移动扫除线"}},[t._v("#")]),t._v(" 2.2. 移动扫除线")]),t._v(" "),o("p",[t._v("典型的扫除 Sweeping 算法需要维护如下两组数据：")]),t._v(" "),o("ol",[o("li",[o("strong",[t._v("扫除线状态")]),t._v(" (sweep-line status) 给出了与扫除线相交的物体之间的关系。")]),t._v(" "),o("li",[o("strong",[t._v("事件点调度")]),t._v(" (event-point schedule) 是一个按 x 坐标从左到右排列的事件点序列。随着扫除线从左到右行进，每当遇到事件点的 x 坐标时，扫除都会暂停 并处理该事件点，然后重新开始扫除。扫除线状态仅在事件点处改变。")])]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-5.png",alt:"segment-intersect-5"}})]),t._v(" "),o("h3",{attrs:{id:"_2-3-求线段交点的伪代码"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-求线段交点的伪代码"}},[t._v("#")]),t._v(" 2.3. 求线段交点的伪代码")]),t._v(" "),o("p",[t._v("下面的算法将一个由 n 条线段组成的集合 S 作为输入，如果 S 中存在一对线段相交，则返回 True，否则返回 False。完全前序 T 由一棵"),o("a",{attrs:{href:"../../data-structure/red-black-tree"}},[t._v("红黑树")]),t._v("来维护。")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("ANY_SEGMENTS_INTERSECT(S)\n1  T = \\emptyset\n2  sort the endpoints of the segments in S from left to right,\n       breaking ties by putting left endpoints before right endpoints\n       and breaking further ties by putting points with lower y-coordinates first\n3  for each point p in the sorted list of endpoints\n4      if p is the left endpoint of a segment s\n5          INSERT(T, s)\n6          if (ABOVE(T, s) exists and intersects s)\n               or (BELOW(T, s) exists and intersects s)\n7              return True\n8      if p is the right endpoint of a segment s\n9          if both ABOVE(T, s) and BELOW(T, s) exist\n               and ABOVE(T, s) intersects BELOW(T, s)\n10             return True\n11         DELETE(T, s)\n12 return False\n")])])]),o("p",[t._v("下图 33-5 说明了此算法的执行过程。")]),t._v(" "),o("ol",[o("li",[t._v("第 1 行，初始化完全前序(扩展红黑树的动态集合) T 为空")]),t._v(" "),o("li",[t._v("第 2 行，将 2n 个线段端点 由左到右排序，并按照前述方法处理多个点 x 坐标值相同的情况，从而确定事件点的调度次序。\n"),o("ul",[o("li",[t._v("执行第 2 行的一种方式是，在 (x, e, y) 上对端点按照字典序排序，其中 x 和 y 为通常对坐标，而 e = 0 表示左端点、e = 1 表示右端点。")])])]),t._v(" "),o("li",[t._v("在第 3～11 行的 for 循环中，每一次迭代都处理一个事件点 p。\n"),o("ul",[o("li",[t._v("如果事件点 p 是某线段 s 的左端点，那么第 5 行将 s 添加到完全前序 T 中。\n"),o("ul",[o("li",[t._v("如果 s 与(由经过 p 的扫除线所定义的)完全前序中的(与之连续的)两条连续线段 中的任一条相交，则第 6～7 行返回 True，表示存在相交的线段。")]),t._v(" "),o("li",[t._v("如果 p 位于另一条线段 s' 上，则出现边界情况。此时，仅需要将 s 和 s' 连续地放入 T 中。")])])]),t._v(" "),o("li",[t._v("如果事件点 p 是某线段 s 的右端点，那么第 11 行会将 s 从完全前序 T 中删除。\n"),o("ul",[o("li",[t._v("考虑经过 p 的扫除线所定义的完全前序，如果 s 旁边(ABOVE 或者 BELOW)的线段有相交，那么第 9～10 行返回 True。")]),t._v(" "),o("li",[t._v("如果这些线段不相交，则第 11 行就将 s 从完全前序 T 中删除。")]),t._v(" "),o("li",[t._v("只要第 10 行的 return 语句没有阻碍第 11 行的执行，那么当 s 被删除后，s 旁边的线段就会在完全前序中变为连续。")])])])])]),t._v(" "),o("li",[t._v("最后，如果在处理完全部 2n 个事件点后没发现存在线段相交，第 12 行就返回 False。")])]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-6.png",alt:"segment-intersect-6"}})]),t._v(" "),o("h3",{attrs:{id:"_2-4-求线段交点算法的正确性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-求线段交点算法的正确性"}},[t._v("#")]),t._v(" 2.4. 求线段交点算法的正确性")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-7.png",alt:"segment-intersect-7"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-8.png",alt:"segment-intersect-8"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-9.png",alt:"segment-intersect-9"}})]),t._v(" "),o("h3",{attrs:{id:"_2-5-求线段交点算法的运行时间"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-求线段交点算法的运行时间"}},[t._v("#")]),t._v(" 2.5. 求线段交点算法的运行时间")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-10.png",alt:"segment-intersect-10"}})]),t._v(" "),o("h3",{attrs:{id:"_2-6-其它线段相交相关问题与性质"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-其它线段相交相关问题与性质"}},[t._v("#")]),t._v(" 2.6. 其它线段相交相关问题与性质")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-11.png",alt:"segment-intersect-11"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/segment-intersect-12.png",alt:"segment-intersect-12"}})]),t._v(" "),o("h2",{attrs:{id:"_3-寻找凸包"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-寻找凸包"}},[t._v("#")]),t._v(" 3. 寻找凸包")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-1.png",alt:"convex-hull-1"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-2.png",alt:"convex-hull-2"}})]),t._v(" "),o("p",[t._v("因此，通过在 O(n log n) 时间内计算出 n 个输入点的凸包，然后再找出得到的凸多边形中的最远顶点对，就可以在 O(n log n) 时间内 找出任意 n 个点组成的集合中"),o("strong",[t._v("距离最远的点对")]),t._v("。")]),t._v(" "),o("p",[o("strong",[t._v("旋转卡壳")]),t._v(" (Rotating Calipers) 算法可以在 O(n) 时间内计算出给定凸多边形(或者凸包的顶点集)的最远点对。")]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("begin\n     p0:=pn;\n     q:=NEXT[p];\n     while (Area(p,NEXT[p],NEXT[q]) > Area(p,NEXT[p],q)) do\n          q:=NEXT[q];\n          q0:=q;\n          while (q != p0) do\n               begin\n                    p:=NEXT[p];\n                    Print(p,q);\n                    while (Area(p,NEXT[p],NEXT[q]) > Area(p,NEXT[p],q) do\n                         begin\n                              q:=NEXT[q];\n                              if ((p,q) != (q0,p0)) then Print(p,q)\n                              else return\n                         end;\n                    if (Area(p,NEXT[p],NEXT[q]) = Area(p,NEXT[p],q)) then\n                      if ((p,q) != (q0,p0)) then Print(p,NEXT[q])\n                      else Print(NEXT[p],q)\n               end\nend\n")])])]),o("h3",{attrs:{id:"_3-1-graham-扫描法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-graham-扫描法"}},[t._v("#")]),t._v(" 3.1. Graham 扫描法")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-3.png",alt:"convex-hull-3"}})]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v('GRAHAM_SCAN(Q)\n1  let p_0 be the point in Q with the minimum y-coordinate,\n       or the leftmost such point in case of a tie\n2  let <p_1, p_2, ..., p_m> be the remaining points in Q,\n       sorted by polar angle in counterclockwise order around p_0\n       (if more than one point has the same angle, remove all but\n       \tthe one that is farthest from p_0)\n3  if m < 2\n4      return "convex hull is empty"\n5  else\n6      let S be an empty stack\n7      PUSH(p_0, S)\n8      PUSH(p_1, S)\n9      PUSH(p_2, S)\n10     for i = 3 to m\n11         while the angle formed by points NEXT_TO_TOP(S), TOP(S), \n               and p_i makes a nonleft turn\n12             POP(S)\n13         PUSH(p_i, S)\n14 return S\n')])])]),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-4.png",alt:"convex-hull-4"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-5.png",alt:"convex-hull-5"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-6.png",alt:"convex-hull-6"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-7.png",alt:"convex-hull-7"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-8.png",alt:"convex-hull-8"}})]),t._v(" "),o("h3",{attrs:{id:"_3-2-jarvis-步进法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-jarvis-步进法"}},[t._v("#")]),t._v(" 3.2. Jarvis 步进法")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-9.png",alt:"convex-hull-9"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-10.png",alt:"convex-hull-10"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-11.png",alt:"convex-hull-11"}})]),t._v(" "),o("h3",{attrs:{id:"_3-3-其它点集凸包相关问题与性质"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-其它点集凸包相关问题与性质"}},[t._v("#")]),t._v(" 3.3. 其它点集凸包相关问题与性质")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/convex-hull-12.png",alt:"convex-hull-12"}})]),t._v(" "),o("h2",{attrs:{id:"_4-寻找最近点对"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-寻找最近点对"}},[t._v("#")]),t._v(" 4. 寻找最近点对")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-1.png",alt:"nearest-pair-1"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-2.png",alt:"nearest-pair-2"}})]),t._v(" "),o("h3",{attrs:{id:"_4-1-分治算法"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-分治算法"}},[t._v("#")]),t._v(" 4.1. 分治算法")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-3.png",alt:"nearest-pair-3"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-4.png",alt:"nearest-pair-4"}})]),t._v(" "),o("h3",{attrs:{id:"_4-2-算法的正确性"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-算法的正确性"}},[t._v("#")]),t._v(" 4.2. 算法的正确性")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-5.png",alt:"nearest-pair-5"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-6.png",alt:"nearest-pair-6"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-7.png",alt:"nearest-pair-7"}})]),t._v(" "),o("h3",{attrs:{id:"_4-3-算法的实现与运行时间分析"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-算法的实现与运行时间分析"}},[t._v("#")]),t._v(" 4.3. 算法的实现与运行时间分析")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-8.png",alt:"nearest-pair-8"}})]),t._v(" "),o("div",{staticClass:"language- extra-class"},[o("pre",{pre:!0,attrs:{class:"language-text"}},[o("code",[t._v("1  let Y_L[1..Y.length] and Y_R[1..Y.length] be new arrays\n2  Y_L.length = Y_R.length = 0\n3  for i = 1 to Y.length\n4      if Y[i] \\in P_L\n5          Y_L.length = Y_L.length + 1\n6          Y_L[Y_L.length] = Y[i]\n7      else\n8          Y_R.length = Y_R.length + 1\n9          Y_R[Y_R.length] = Y[i]\n")])])]),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-9.png",alt:"nearest-pair-9"}})]),t._v(" "),o("h3",{attrs:{id:"_4-4-其它最近点对相关问题与性质"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-其它最近点对相关问题与性质"}},[t._v("#")]),t._v(" 4.4. 其它最近点对相关问题与性质")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/nearest-pair-10.png",alt:"nearest-pair-10"}})]),t._v(" "),o("h2",{attrs:{id:"_5-其它计算几何学相关问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-其它计算几何学相关问题"}},[t._v("#")]),t._v(" 5. 其它计算几何学相关问题")]),t._v(" "),o("h3",{attrs:{id:"_5-1-凸层"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-凸层"}},[t._v("#")]),t._v(" 5.1. 凸层")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-1.png",alt:"cg-other-questions-1"}})]),t._v(" "),o("h3",{attrs:{id:"_5-2-最大层"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-最大层"}},[t._v("#")]),t._v(" 5.2. 最大层")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-2.png",alt:"cg-other-questions-2"}})]),t._v(" "),o("h3",{attrs:{id:"_5-3-巨人和鬼问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-巨人和鬼问题"}},[t._v("#")]),t._v(" 5.3. 巨人和鬼问题")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-3.png",alt:"cg-other-questions-3"}})]),t._v(" "),o("h3",{attrs:{id:"_5-4-拾取棍子问题"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-拾取棍子问题"}},[t._v("#")]),t._v(" 5.4. 拾取棍子问题")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-4.png",alt:"cg-other-questions-4"}})]),t._v(" "),o("h3",{attrs:{id:"_5-5-稀疏包分布"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-稀疏包分布"}},[t._v("#")]),t._v(" 5.5. 稀疏包分布")]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-5.png",alt:"cg-other-questions-5"}})]),t._v(" "),o("p",[o("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/computational-geometry/cg-other-questions-6.png",alt:"cg-other-questions-6"}})]),t._v(" "),o("h2",{attrs:{id:"代码范例"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),o("h3",{attrs:{id:"python"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),o("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/other-topics/computational-geometry/computational-geometry.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),o("OutboundLink")],1)]),t._v(" "),o("h2",{attrs:{id:"参考资料"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),o("ul",[o("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 33")])])])}),[],!1,null,null,null);e.default=r.exports}}]);