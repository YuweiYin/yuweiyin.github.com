(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{284:function(t,r,e){"use strict";e.r(r);var o=e(28),a=Object(o.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"algorithm-number-theoretic-algorithm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-number-theoretic-algorithm"}},[t._v("#")]),t._v(" Algorithm - Number-Theoretic Algorithm")]),t._v(" "),e("p",[t._v("By "),e("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),e("ul",[e("li",[t._v("数论算法 Number-Theoretic Algorithm\n"),e("ul",[e("li",[t._v("欧几里得算法 Euclidean Algorithm")]),t._v(" "),e("li",[t._v("扩展的欧几里得算法 Extended Euclidean Algorithm")]),t._v(" "),e("li",[t._v("求解模线性方程 Modular Linear Equation Solving")]),t._v(" "),e("li",[t._v("中国剩余定理 Chinese Remainder Theorem")]),t._v(" "),e("li",[t._v("元素的模取幂 Modular Exponentiation")]),t._v(" "),e("li",[t._v("(伪)素数测试 Fermat Pseudo Prime Test")]),t._v(" "),e("li",[t._v("Miller-Rabin 随机性素数测试方法")]),t._v(" "),e("li",[t._v("整数的(素)因子分解 - Pollard-Rho 启发式算法")])])])]),t._v(" "),e("h2",{attrs:{id:"数论算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数论算法"}},[t._v("#")]),t._v(" 数论算法")]),t._v(" "),e("p",[t._v("数论曾经被视为一种优美但没什么实际用途的纯数学学科。如今，数论算法已经得到了广泛的使用。这很大程度上要归功于人们发明了"),e("strong",[t._v("基于大素数的加密方法")]),t._v("。快速计算大素数的算法使得高效加密成为可能，而目前其安全性的保证则依赖于缺少高效地"),e("strong",[t._v("将大合数分解为大素数之积")]),t._v("（或求解相关问题，如计算"),e("strong",[t._v("离散对数")]),t._v("）方法的现状。")]),t._v(" "),e("p",[e("strong",[t._v("量子计算")]),t._v("与量子通信是目前的前沿研究。在量子计算机中，有一种 Shor's Algorithm "),e("strong",[t._v("秀尔算法")]),t._v("用于因子分解，可以很快地计算因子分解问题（而这个问题在目前流行的计算模型中 需要耗费指数渐近时间）。")]),t._v(" "),e("p",[t._v("在数论算法中，处理的对象是大整数。而且一般不像排序算法那样，是对大量整数的处理。因此，数论算法通常利用输入所需的"),e("strong",[t._v("位数")]),t._v("来度量输入的大小，而不仅仅是输入中整数的数目。给定 k 个整数输入 $ a_{1}, ..., a_{k} $，如果算法可以在关于 $ log_{2} (a_1), ..., log_{2} (a_k) $ 的多项式时间完成（即算法在关于"),e("strong",[t._v("整数的二进制形式的位数")]),t._v("的多项式时间内完成），则称算法称为"),e("strong",[t._v("多项式时间算法")]),t._v("。")]),t._v(" "),e("p",[t._v("另外，由于当输入整数很大时，基本运算（乘法、除法、模运算等）也会变得较为耗时，因此数论算法通常使用所需的"),e("strong",[t._v("位运算")]),t._v("数目作为基准来衡量算法的时间代价。例如，将两个 k (二进制)位整数用常规方法相乘 需要 $ \\Theta(k^2) $ 次位运算。同样地，用朴素的方法计算一个 k (二进制)位整数除以另一个较短整数的商或求余数 也需要耗时 $ \\Theta(k^2) $。")]),t._v(" "),e("p",[t._v("如今，人们已有了更快的数值计算方法。例如，一个简单的分支算法可以在两个 k (二进制)位整数相乘的问题上达到 $ \\Theta(k^{log_{2} 3}) $ 的运行时间。而已知的最快算法则只需要 $ \\Theta(k log_{2} {k} log_{2} log_{2} {k}) $。然而，在实际问题中，简单直接的 $ \\Theta(k^2) $ 算法往往效果最好。")]),t._v(" "),e("h2",{attrs:{id:"基础数论概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础数论概念"}},[t._v("#")]),t._v(" 基础数论概念")]),t._v(" "),e("p",[t._v("这里简单回顾基础数论中关于整数集 Z = {..., -2, -1, 0, 1, 2, ...} 和自然数集 N = {0, 1, 2, ...} 的一些概念。")]),t._v(" "),e("h3",{attrs:{id:"整除性与约数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整除性与约数"}},[t._v("#")]),t._v(" 整除性与约数")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-1.png",alt:"number-theory-1"}})]),t._v(" "),e("h3",{attrs:{id:"素数与合数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#素数与合数"}},[t._v("#")]),t._v(" 素数与合数")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-2.png",alt:"number-theory-2"}})]),t._v(" "),e("h3",{attrs:{id:"除法定理、余数和等模"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#除法定理、余数和等模"}},[t._v("#")]),t._v(" 除法定理、余数和等模")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-3.png",alt:"number-theory-3"}})]),t._v(" "),e("h3",{attrs:{id:"公约数与最大公约数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#公约数与最大公约数"}},[t._v("#")]),t._v(" 公约数与最大公约数")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-4.png",alt:"number-theory-4"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-5.png",alt:"number-theory-5"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-6.png",alt:"number-theory-6"}})]),t._v(" "),e("h3",{attrs:{id:"互质数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#互质数"}},[t._v("#")]),t._v(" 互质数")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-7.png",alt:"number-theory-7"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-8.png",alt:"number-theory-8"}})]),t._v(" "),e("h3",{attrs:{id:"唯一因子分解定理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#唯一因子分解定理"}},[t._v("#")]),t._v(" 唯一因子分解定理")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-9.png",alt:"number-theory-9"}})]),t._v(" "),e("h3",{attrs:{id:"其它相关性质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#其它相关性质"}},[t._v("#")]),t._v(" 其它相关性质")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-10.png",alt:"number-theory-10"}})]),t._v(" "),e("h3",{attrs:{id:"素数的数量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#素数的数量"}},[t._v("#")]),t._v(" 素数的数量")]),t._v(" "),e("p",[t._v("可以用反证法，证明素数的个数有无穷多个")]),t._v(" "),e("h3",{attrs:{id:"素数的分布"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#素数的分布"}},[t._v("#")]),t._v(" 素数的分布")]),t._v(" "),e("p",[t._v("关于素数的分布，数论领域有许多研究，其中很著名的就有黎曼猜想，关于 Riemman Zeta function")]),t._v(" "),e("h2",{attrs:{id:"最大公约数-gcd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最大公约数-gcd"}},[t._v("#")]),t._v(" 最大公约数 GCD")]),t._v(" "),e("p",[e("strong",[t._v("欧几里得算法")]),t._v(" Euclidean Algorithm 可以高效地计算两个整数的最大公约数 (Greatest Common Divisor, GCD)。在对其运行时间进行分析的过程中，可以发现它与"),e("strong",[t._v("斐波那契数列")]),t._v("存在一些联系，由此可知欧几里得算法最坏情况下的输入。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-11.png",alt:"number-theory-11"}})]),t._v(" "),e("h3",{attrs:{id:"欧几里得算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#欧几里得算法"}},[t._v("#")]),t._v(" 欧几里得算法")]),t._v(" "),e("p",[t._v("欧几里得（约公元前 300 年）的《几何原本》描述了下列 gcd 算法，实际上这一算法出现的时间可能还要早些。可以直接利用前述定理 31.9 得到 GCD 递归程序，其输入 a 和 b 都是"),e("strong",[t._v("任意非负整数")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("EUCLID(a, b)\n1  if b == 0\n2      return a\n3  else\n4      return EUCLID(b, a mod b)\n")])])]),e("p",[t._v("计算过程举例：EUCLID(30, 21) = EUCLID(21, 9) = EUCLID(9, 3) = EUCLID(3, 0) = 3")]),t._v(" "),e("p",[t._v("另外，如果在输入时 a < b，那么首次递归后就会交换二者的位置。")]),t._v(" "),e("p",[t._v("前述 "),e("code",[t._v("EUCLID")]),t._v(" 过程是尾递归，可以改成如下迭代形式：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("EUCLID(a, b)\n1  while b != 0\n2      (a, b) = (b, a mod b)\n3  return a\n")])])]),e("h3",{attrs:{id:"欧几里得算法的运行时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#欧几里得算法的运行时间"}},[t._v("#")]),t._v(" 欧几里得算法的运行时间")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-12.png",alt:"number-theory-12"}})]),t._v(" "),e("p",[t._v("斐波那契数列：$ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... $")]),t._v(" "),e("p",[t._v("EUCLID(89, 55) = EUCLID(55, 34) = EUCLID(34, 21) = EUCLID(21, 13) = EUCLID(13, 8) = EUCLID(8, 5) = EUCLID(5, 3) = EUCLID(3, 1) = EUCLID(1, 0) = 1")]),t._v(" "),e("p",[t._v("$ gcd(F_{k+1}, F_{k}) = gcd(F_{k}, F_{k-1}) $")]),t._v(" "),e("h3",{attrs:{id:"欧几里得算法的扩展形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#欧几里得算法的扩展形式"}},[t._v("#")]),t._v(" 欧几里得算法的扩展形式")]),t._v(" "),e("p",[t._v("欧几里得算法不仅能计算最大公约数，利用其计算过程的系数，可以得出**(模)乘法的逆元**。此系数是满足下述条件的整系数 x 和 y：$ d = gcd(a, b) = ax + by $。这里 x 与 y 可能为 0 或负数。")]),t._v(" "),e("p",[t._v("下述伪代码描述的过程 "),e("code",[t._v("EXTENDED_EUCLID")]),t._v(" 的输入为一对非负整数，并返回一个满足前述条件三元组 (d, x, y)：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("EXTENDED_EUCLID(a, b)\n1  if b == 0\n2      return (a, 1, 0)\n3  else\n4      (d', x', y') = EXTENDED_EUCLID(b, a mod b)\n5      (d, x, y) = (d', y' x' - \\floor(a / b) * y')\n6      return (d, x, y)\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-13.png",alt:"number-theory-13"}})]),t._v(" "),e("p",[t._v("如果 "),e("code",[t._v("EXTENDED_EUCLID(a, b)")]),t._v(" 返回 (d, x, y)，表示 a 和 b 的最大公约数是 d，即有 gcd(a, b) = d = ax + by")]),t._v(" "),e("p",[t._v("如果返回的 d 为 1，则表示 a 和 b 互素，且由于 1 = ax + by，可以得到如下结果：")]),t._v(" "),e("ul",[e("li",[t._v("1 = (ax + by) mod b，故有 1 = (ax) mod b，这意味着在 mod b 的情况下，a 与 x 互为乘法逆元\n"),e("ul",[e("li",[t._v("同理，在 mod y 的情况下，也有 a 与 x 互为乘法逆元")])])]),t._v(" "),e("li",[t._v("1 = (ax + by) mod a，故有 1 = (by) mod a，这意味着在 mod a 的情况下，b 与 y 互为乘法逆元\n"),e("ul",[e("li",[t._v("同理，在 mod x 的情况下，也有 b 与 y 互为乘法逆元")])])]),t._v(" "),e("li",[t._v("不过由于计算前往往不知道 x 和 y 值，所以一般是为了得到在 mod b 的情况下，a 的乘法逆元（以及在 mod a 的情况下，b 的乘法逆元）")])]),t._v(" "),e("p",[t._v("因此运用 "),e("code",[t._v("EXTENDED_EUCLID")]),t._v(" 可以高效地计算出 最大公约数 和 (模)乘法逆元。")]),t._v(" "),e("h2",{attrs:{id:"模运算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模运算"}},[t._v("#")]),t._v(" 模运算")]),t._v(" "),e("p",[t._v("模运算模型十分适合用群论结构（代数系统）来进行描述。")]),t._v(" "),e("h3",{attrs:{id:"有限群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有限群"}},[t._v("#")]),t._v(" 有限群")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-1.png",alt:"group-1"}})]),t._v(" "),e("p",[t._v("另，交换群又常被称为 Abel Group 阿贝尔群。")]),t._v(" "),e("h3",{attrs:{id:"由模加法与模乘法所定义的群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#由模加法与模乘法所定义的群"}},[t._v("#")]),t._v(" 由模加法与模乘法所定义的群")]),t._v(" "),e("p",[t._v("通过对模 n 运用加法与乘法运算，可以得到两个有限交换群，其中 n 是正整数。这些群基于整数模 n 所形成的等价类。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-2.png",alt:"group-2"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-3.png",alt:"group-3"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-4.png",alt:"group-4"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-5.png",alt:"group-5"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-6.png",alt:"group-6"}})]),t._v(" "),e("h3",{attrs:{id:"子群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#子群"}},[t._v("#")]),t._v(" 子群")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-7.png",alt:"group-7"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-8.png",alt:"group-8"}})]),t._v(" "),e("h3",{attrs:{id:"由一个元素生成的子群"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#由一个元素生成的子群"}},[t._v("#")]),t._v(" 由一个元素生成的子群")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-9.png",alt:"group-9"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-10.png",alt:"group-10"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/group-11.png",alt:"group-11"}})]),t._v(" "),e("h2",{attrs:{id:"求解模线性方程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#求解模线性方程"}},[t._v("#")]),t._v(" 求解模线性方程")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/modular-linear-equation-1.png",alt:"modular-linear-equation-1"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/modular-linear-equation-2.png",alt:"modular-linear-equation-2"}})]),t._v(" "),e("p",[t._v("下列算法可输出模方程 ax = b (mod n) 的所有解。输入 a 和 n 为任意正整数，b 为任意整数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("MODULAR_LINEAR_EQUATION_SOLVER(a, b, n)\n1  (d, x', y') = EXTENDED_EUCLID(a, n)\n2  if b mod d == 0  // also means $ b|d $\n3      x = x'(b/d) mod n\n4      for i = 0 to d-1\n5          print (x + i(n/d)) mod n\n6  else\n7      print \"no solutions\"\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/modular-linear-equation-3.png",alt:"modular-linear-equation-3"}})]),t._v(" "),e("h2",{attrs:{id:"中国剩余定理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中国剩余定理"}},[t._v("#")]),t._v(" 中国剩余定理")]),t._v(" "),e("p",[t._v("中国剩余定理 (Chinese Remainder Theorem)")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/chinese-remainder-theorem-1.png",alt:"chinese-remainder-theorem-1"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/chinese-remainder-theorem-2.png",alt:"chinese-remainder-theorem-2"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/chinese-remainder-theorem-3.png",alt:"chinese-remainder-theorem-3"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/chinese-remainder-theorem-4.png",alt:"chinese-remainder-theorem-4"}})]),t._v(" "),e("h2",{attrs:{id:"元素的模取幂"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#元素的模取幂"}},[t._v("#")]),t._v(" 元素的模取幂")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-1.png",alt:"element-power-1"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-2.png",alt:"element-power-2"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-3.png",alt:"element-power-3"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-4.png",alt:"element-power-4"}})]),t._v(" "),e("h3",{attrs:{id:"用反复平方法求数的幂"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用反复平方法求数的幂"}},[t._v("#")]),t._v(" 用反复平方法求数的幂")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-5.png",alt:"element-power-5"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("MODULAR_EXPONENTIATION(a, b, n)\n1  c = 0\n2  d = 1\n3  let <b_{k}, b_{k-1}, ..., b_{0}> be the binary representation of b\n4  for i = k downto 0\n5      c = 2 * c\n6      d = (d * d) mod n\n7      if b_i == 1\n8          c = c + 1\n9          d = (d * a) mod n\n10 return d\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-6.png",alt:"element-power-6"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/element-power-7.png",alt:"element-power-7"}})]),t._v(" "),e("h2",{attrs:{id:"rsa-公钥加密系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rsa-公钥加密系统"}},[t._v("#")]),t._v(" RSA 公钥加密系统")]),t._v(" "),e("p",[t._v("RSA 公钥加密系统主要基于以下(在目前的计算模型中的)事实：寻求大素数是很容易的，但要把一个大合数分解为两个大素数的乘积却相当困难。")]),t._v(" "),e("h3",{attrs:{id:"公钥加密系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#公钥加密系统"}},[t._v("#")]),t._v(" 公钥加密系统")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-1.png",alt:"rsa-1"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-2.png",alt:"rsa-2"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-3.png",alt:"rsa-3"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-4.png",alt:"rsa-4"}})]),t._v(" "),e("h3",{attrs:{id:"rsa-加密系统"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rsa-加密系统"}},[t._v("#")]),t._v(" RSA 加密系统")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-5.png",alt:"rsa-5"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-6.png",alt:"rsa-6"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/rsa-7.png",alt:"rsa-7"}})]),t._v(" "),e("h2",{attrs:{id:"素数的测试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#素数的测试"}},[t._v("#")]),t._v(" 素数的测试")]),t._v(" "),e("p",[t._v("本节考虑"),e("strong",[t._v("寻找大素数")]),t._v("的问题，首先讨论"),e("strong",[t._v("素数的密度")]),t._v("，然后讨论一种"),e("strong",[t._v("不完全可行")]),t._v("的测试素数的方法（利用费马(小)定理），最后介绍一种由 Miller 和 Rabin 发现的"),e("strong",[t._v("有效的随机素数测试算法")]),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"素数的密度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#素数的密度"}},[t._v("#")]),t._v(" 素数的密度")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-1.png",alt:"prime-test-1"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-2.png",alt:"prime-test-2"}})]),t._v(" "),e("h3",{attrs:{id:"伪素数测试过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#伪素数测试过程"}},[t._v("#")]),t._v(" 伪素数测试过程")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-3.png",alt:"prime-test-3"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("PSEUDOPRIME(n)\n1  if MODULAR_EXPONENTIATION(2, n-1, n) != 1 (mod n)\n2      return COMPOSITE  // definitely\n3  else\n4      return PRIME      // wo hope!\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-4.png",alt:"prime-test-4"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-5.png",alt:"prime-test-5"}})]),t._v(" "),e("h3",{attrs:{id:"miller-rabin-随机性素数测试方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#miller-rabin-随机性素数测试方法"}},[t._v("#")]),t._v(" Miller-Rabin 随机性素数测试方法")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-6.png",alt:"prime-test-6"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("WITNESS(a, n)\n1  let t and u be such that t >= 1, u is odd, and n-1 = u * 2^{t}\n2  x_0 = MODULAR_EXPONENTIATION(a, u, n)\n3  for i = 1 to t\n4      x_i = x_{i-1}^2 mod n\n5      if x_i == 1 and x_{i-1} != 1 and x_{i-1} != n-1\n6          return True\n7  if x_t != 1\n8      return True\n9  return False\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-7.png",alt:"prime-test-7"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-8.png",alt:"prime-test-8"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("MILLER_RABIN(n, s)\n1  for j = 1 to s\n2      a = Random(1, n-1)\n3      if WITNESS(a, n)\n4          return CONPOSITE  // definitely\n5  return PRIME  // almost surely\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-9.png",alt:"prime-test-9"}})]),t._v(" "),e("h3",{attrs:{id:"miller-rabin-素数测试的出错率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#miller-rabin-素数测试的出错率"}},[t._v("#")]),t._v(" Miller-Rabin 素数测试的出错率")]),t._v(" "),e("p",[t._v("如果 "),e("code",[t._v("MILLER_RABIN")]),t._v(" 返回 True，则它仍有一种很小的可能性会产生错误。然而，它不像 "),e("code",[t._v("PSEUDOPRIME")]),t._v(" 那样出错的概率依赖于 n。而且它也不存在坏的输入。相反，它的出错率取决于 s 的大小和在选取基值 a 时的“运气”。另外，由于每次测试都比简单地检查等式 (31.40) 更严格，因此从总体上，对随机选取的整数 n，判断 n 为素数的出错率应该是很小的。下面的两个定理阐述了更精确的论点，其证明过程详见《CLRS》Chapter 31.8。")]),t._v(" "),e("p",[t._v("《CLRS》"),e("strong",[t._v("定理 31.38")]),t._v("：如果 n 是一个奇合数，则 n 为合数的证据的数目至少为 (n-1)/2。")]),t._v(" "),e("p",[t._v("《CLRS》"),e("strong",[t._v("定理 31.39")]),t._v("：对于任意奇数 n > 2 和正整数 s，"),e("code",[t._v("MILLER_RABIN(n, s)")]),t._v(" 出错的概率至多为 2^{-s}。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-10.png",alt:"prime-test-10"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/prime-test-11.png",alt:"prime-test-11"}})]),t._v(" "),e("h2",{attrs:{id:"整数的因子分解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#整数的因子分解"}},[t._v("#")]),t._v(" 整数的因子分解")]),t._v(" "),e("p",[t._v("假设希望将一个整数 n 进行"),e("strong",[t._v("因子分解")]),t._v("，也就是分解为"),e("strong",[t._v("素数的乘积")]),t._v("。同过前一节的素数测试，可以以很大概率地推测 n 是否为素数，也能断定 n 是否为合数。但当指出 n 为合数时，素数测试算法并不能指出 n 的素数因子。")]),t._v(" "),e("p",[t._v("对一个大整数 n 进行因子分解，似乎要比仅确定 n 是素数还是合数困难得多。即使用当今的超级计算机和现行的最佳算法，要对任意一个 1024 位的数进行因子分解也还是不实际的。")]),t._v(" "),e("h3",{attrs:{id:"pollard-的-rho-启发式方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pollard-的-rho-启发式方法"}},[t._v("#")]),t._v(" Pollard 的 rho 启发式方法")]),t._v(" "),e("p",[t._v("对小于 R 的所有整数进行试除，保证完全获得小于 R^2 的任意数的因子分解。下列过程用相同的工作量，就能对小于 R^4 的任意数进行因子分解（除非运气不佳，否则可以完成）。由于该过程仅仅是一种启发式方法，因此既不能保证其运行时间 也不能保证其运行成功，尽管该过程在实际应用中非常有效。"),e("code",[t._v("POLLARD_RHO")]),t._v(" 过程的另一个优点是：它只使用固定量的存储空间。（如果愿意，可以很容易地在一个可编程的掌上计算器上实现此过程，以找出较小整数的素因子）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("POLLARD_RHO(n)\n1  i = 1\n2  x_1 = Random(0, n-1)\n3  y = x_1\n4  k = 2\n5  while True\n6      i = i + 1\n7      x_i = (x_{i-1}^2 - 1) mod n\n8      d = gcd(y - x_i, n)\n9      if d != 1 and d != n\n10         print(d)\n11     if i == k\n12         y = x_i\n13         k = 2 * k\n")])])]),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/pollard-rho-1.png",alt:"pollard-rho-1"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/pollard-rho-2.png",alt:"pollard-rho-2"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/pollard-rho-3.png",alt:"pollard-rho-3"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/pollard-rho-4.png",alt:"pollard-rho-4"}})]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/pollard-rho-5.png",alt:"pollard-rho-5"}})]),t._v(" "),e("h2",{attrs:{id:"代码范例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),e("h3",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),e("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/other-topics/number-theoretic-algorithm/number-theory.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 31")])])])}),[],!1,null,null,null);r.default=a.exports}}]);