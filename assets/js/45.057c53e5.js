(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{267:function(v,_,t){"use strict";t.r(_);var e=t(28),r=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"algorithm-graph-theory-push-relabel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-graph-theory-push-relabel"}},[v._v("#")]),v._v(" Algorithm - Graph Theory - Push-Relabel")]),v._v(" "),t("p",[v._v("By "),t("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[v._v("YuweiYin"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("最大流 Max-Flow")]),v._v(" "),t("p",[v._v("推送-重贴标签算法 Push-Relabel")]),v._v(" "),t("h3",{attrs:{id:"流网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流网络"}},[v._v("#")]),v._v(" 流网络")]),v._v(" "),t("p",[v._v("流网络 G = (V, E) 是一个有向图，图中每条边 (u, v) \\in E 有一个"),t("strong",[v._v("非负")]),v._v("的"),t("strong",[v._v("容量值")]),v._v(" c(u, v) >= 0。而且，如果边集合 E 包含一条边 (u, v)，则图中不存在反方向的边 (v, u)。如果 (u, v) \\notin E，为方便起见，定义 c(u, v) = 0。并且在图中不允许有自循环/自圈 (u, u)。")]),v._v(" "),t("p",[v._v("另外，在流网络的所有结点中，有两个特殊的结点："),t("strong",[v._v("源结点")]),v._v(" s (source) 和"),t("strong",[v._v("汇点")]),v._v(" t (terminal)。源结点入度为 0、汇点出度为 0。为方便起见，假定 V 中每个结点 v 都位于某条从 s 到 v 的路径上，即有 "),t("code",[v._v("s ~> v ~> t")]),v._v(" 路径。")]),v._v(" "),t("p",[v._v("因此，流网络图是"),t("strong",[v._v("弱连通")]),v._v("的。并且由于除源结点 s 外的每个结点都至少有一条进入的边，有 "),t("code",[v._v("|E| >= |V| - 1")]),v._v("。")]),v._v(" "),t("ul",[t("li",[v._v("流网络的性质主要如下：\n"),t("ul",[t("li",[v._v("流网络 G = (V, E) 是一个弱连通的有向图")]),v._v(" "),t("li",[v._v("所有边的权重为非负值，且每条边的权重值有上界 c(u, v)")]),v._v(" "),t("li",[v._v("任意两个结点 u, v \\in V，不能同时存在边 (u, v) 和边 (v, u)")]),v._v(" "),t("li",[v._v("如果某边 (u, v) 不存在，定义其权重值 c(u, v) = 0")]),v._v(" "),t("li",[v._v("图中没有自循环 (u, u)")]),v._v(" "),t("li",[v._v("通常来说，源结点 s 的入度为 0，汇点 t 的出度为 0")]),v._v(" "),t("li",[v._v("每个结点 v 都处于从 s 到 t 的某条路径上。即：从起点 s 发出的流量可以流经 v 到达终点 t")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/max-flow-1.png",alt:"max-flow-1"}})]),v._v(" "),t("p",[v._v("这里给出流的形式化定义。设 G = (V, E) 是一个"),t("strong",[v._v("流网络")]),v._v("，其"),t("strong",[v._v("容量函数")]),v._v("为 c。设 s 为网络的"),t("strong",[v._v("源结点")]),v._v("，t 为"),t("strong",[v._v("汇点")]),v._v("。G 中的"),t("strong",[v._v("流")]),v._v("是一个"),t("strong",[v._v("实值函数")]),v._v(" f: VxV -> R，满足如下两条性质：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("容量限制")]),v._v("：（“流量有限额”）对于所有的结点 u, v \\in V，要求 0 <= f(u, v) <= c(u, v)")]),v._v(" "),t("li",[t("strong",[v._v("流量守恒")]),v._v("：（“流入等于流出”）对于所有的结点 u \\in V - {s, t}，要求 $ \\sum_{v \\in V} f(v, u) = \\sum_{v \\in V} f(u, v) $\n"),t("ul",[t("li",[v._v("当 (u, v) \\notin E 时，从结点 u 到结点 v 之间没有流，因此 f(u, v) == 0")])])])]),v._v(" "),t("p",[v._v("称非负数值 f(u, v) 为从结点 u 到结点 v 的流。一个流 f 的值 "),t("code",[v._v("|f|")]),v._v(" 定义如下：")]),v._v(" "),t("p",[v._v("$$ |f| = \\sum_{v \\in V} f(s, v) = \\sum_{v \\in V} f(v, s) $$")]),v._v(" "),t("p",[v._v("即，流 f 的值时从源结点流出的总流量 减去 流入源结点的总流量。这里符号 "),t("code",[v._v("|·|")]),v._v(" 仅用作表达流的值，而不是数的绝对值或者集合的基数值。")]),v._v(" "),t("p",[v._v("通常来说，一个流网络不会有任何进入源结点的边，即源结点的入度为 0，故求和项 $ \\sum_{v \\in V} f(v, s) $ 的值将是 0。但对于有的网络而言（比如"),t("strong",[v._v("残存网络")]),v._v("），流入源结点的流量十分重要。")]),v._v(" "),t("p",[v._v("在"),t("strong",[v._v("最大流问题")]),v._v("中，给定一个"),t("strong",[v._v("流网络")]),v._v(" G、一个"),t("strong",[v._v("源结点")]),v._v(" s、一个"),t("strong",[v._v("汇点")]),v._v(" t，目标是找到值最大的一个"),t("strong",[v._v("流")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"推送-重贴标签算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#推送-重贴标签算法"}},[v._v("#")]),v._v(" 推送-重贴标签算法")]),v._v(" "),t("p",[v._v("许多"),t("strong",[v._v("渐近效率很高")]),v._v("的最大流算法都是“推送-重贴标签”算法，最大流算法的"),t("strong",[v._v("最快实现")]),v._v("也是基于此方法。另外，此方法还能有效地解决其它流问题，如"),t("strong",[v._v("最小成本流")]),v._v("问题。")]),v._v(" "),t("p",[v._v("首先引入 Goldberg 的“通用”最大流算法，该算法有一个非常简单的实现，其运行时间为 "),t("code",[v._v("O(|V|^2 |E|)")]),v._v("，这比基于 "),t("a",{attrs:{href:"./ford-fulkerson"}},[v._v("Ford-Fulkerson 方法")]),v._v(" 的 Edmonds-Karp 算法的运行时间 "),t("code",[v._v("O(|V| |E|^2)")]),v._v(" 要好。对此通用算法进行调优，可以获得运行时间为 "),t("code",[v._v("O(|V|^3)")]),v._v(" 的"),t("strong",[v._v("前置重贴标签算法")]),v._v(" (Relabel-To-Front)。")]),v._v(" "),t("p",[v._v("推送-重贴标签算法比 Ford-Fulkerson 方法的"),t("strong",[v._v("局域性更强")]),v._v("。它不是对整个残存网络 Gf 进行检查、然后选择一条增广路径，而是一个结点一个结点地进行考察，"),t("strong",[v._v("每一步只检查当前结点的邻结点")]),v._v("。而且，与 Ford-Fulkerson 方法不同，推送-重贴标签算法并不在整个执行过程中保持流量守恒性质，而是在执行过程中维持一个 "),t("strong",[v._v("预流")]),v._v(" (preflow)。预流是一个 V x V -> R 的函数 f，该函数满足"),t("strong",[v._v("容量限制性质")]),v._v(" 以及如下 "),t("strong",[v._v("弱化了的流量守恒性质")]),v._v("：")]),v._v(" "),t("p",[v._v("对于所有的结点 u \\in V - {s}，有 $ e(u) = \\sum_{v \\in V} f(v, u) - \\sum_{v \\in V} f(u, v) >= 0 $。即：进入一个结点的流 可以超过流出该结点的流。此差值 e(u) 被称为进入结点 u 的 "),t("strong",[v._v("超额流")]),v._v(" (excess flow)。如果对于结点 u \\in V - {s}，有 e(u) > 0，则称该结点 "),t("strong",[v._v("溢出")]),v._v(" (overflowing)。")]),v._v(" "),t("h3",{attrs:{id:"基本操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[v._v("#")]),v._v(" 基本操作")]),v._v(" "),t("p",[v._v("推送-重贴标签算法的两个基本操作：“推送”预流、对结点进行“重贴标签”。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("推送预流")]),v._v("：从一个结点 将超额的流 推送到一个 (高度更低的) 邻结点。\n"),t("ul",[t("li",[v._v("预流只能从高度较高的结点 推送到高低较低的邻结点。")])])]),v._v(" "),t("li",[t("strong",[v._v("重贴标签")]),v._v("：改变一个结点的标签 (即该结点的高度)。\n"),t("ul",[t("li",[v._v("如果一个结点 u 有超额流，但是 u 的邻结点的高度 均大于 u 的高度，此时需要将 u 的高度提升至 "),t("strong",[v._v("残余容量")]),v._v(" cf(u ,v) > 0 的"),t("strong",[v._v("最矮邻结点")]),v._v(" v 的高度加一，从而可以把 u 的超额流经过边 (u, v) 推送给邻居结点 v。")])])])]),v._v(" "),t("p",[v._v("结点"),t("strong",[v._v("高度")]),v._v("的准确定义：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 的一个预流。如果函数 h: V -> N 满足 h(s) = "),t("code",[v._v("|V|")]),v._v(" 且 h(t) = 0，并且对于所有残存网络 Gf 中的边 (u, v) \\in Ef，均有 h(u) <= h(v) + 1，则 h 是一个"),t("strong",[v._v("高度函数")]),v._v("。")]),v._v(" "),t("p",[v._v("在有的文献中，高度函数也通常被称为“距离函数”，一个结点的高度也被称为“距离标签”。这里使用“高度”，更能体现水往低处流的直观思想，帮助理解算法的过程。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.12")]),v._v("：设 G = (V, E) 为一个流网络，设 f 为 G 的预流，设 h 为 V 上的高度函数。对于任意两个结点 u, v \\in V，如果 h(u) > h(v) + 1，则 (u, v) 不是残存网络 Gf 中的一条边。")]),v._v(" "),t("h3",{attrs:{id:"基本操作-推送操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本操作-推送操作"}},[v._v("#")]),v._v(" 基本操作-推送操作")]),v._v(" "),t("p",[v._v("如果结点 u 是一个溢出结点，即 e(u) > 0。此时，如果对于 u 的邻结点 v，有如下两个性质：")]),v._v(" "),t("ul",[t("li",[v._v("残存网络中残存容量 cf(u ,v) > 0。（这保证了边 (u, v) 还能够负载更多的流量）")]),v._v(" "),t("li",[v._v("h(u) = h(v) + 1。（一定要注意：预流推送操作 仅针对高度差为 1 的两结点进行）")])]),v._v(" "),t("p",[v._v("若存在这样的邻居结点 v，则可以执行下述 "),t("code",[v._v("PUSH(u, v)")]),v._v(" 过程将 u 的超额流推动给 v。下面的伪代码所执行的任务是对预流 f 和结点 u 和 v 的超额流进行更新。该过程假定可以在给定 u 和 f 的情况下，能在常数时间内计算出残存容量 cf(u, v)。另外，将存放在结点 u 上的超额流保存在属性 u.e 上，将 u 的高度(标签)保存在属性 u.h 中。表达式 $ \\delta_f (u, v) $ 是一个临时变量，用来存放可以从 u 推送到 v 的流量。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("PUSH(u, v)\n1  // Applies when: u is overflowing, cf(u, v) > 0, and u.h = v.h + 1\n2  // Action: Push \\delta_f(u, v) = min(u.e, cf(u, v)) units of the flow from u to v\n3  \\delta_f(u, v) = min(u.e, cf(u, v))\n4  if (u, v) \\in E\n5      (u, v).f = (u, v).f + \\delta_f(u, v)\n6  else\n7      (v, u).f = (v, u).f - \\delta_f(u, v)\n8  u.e = u.e - \\delta_f(u, v)\n9  v.e = v.e + \\delta_f(u, v)\n")])])]),t("p",[v._v("由于推送到结点 v 的流量是 min(u.e, cf(u, v))，所以不会导致超额流 u.e < 0，也不会使得边 (u, v) 的流量超过其容量限制。"),t("code",[v._v("PUSH(u, v)")]),v._v(" 在 4～7 行更新残存网络的边 (u, v) 和 (v, u) 的残存容量 cf 值。在 8～9 行更新进入结点 u 和 v 的超额流，即 e 属性。")]),v._v(" "),t("p",[t("code",[v._v("PUSH(u, v)")]),v._v(" 仅允许在高度情况为 u.h = v.h + 1 时进行推送。另外根据引理 26.12，高度差超过 1 的两个结点之间也不应存在残存边。")]),v._v(" "),t("p",[v._v("称 "),t("code",[v._v("PUSH(u, v)")]),v._v(" 为从结点 u 结点 v 的一个推送操作。如果一个推送操作适用于有向边 (u, v)，则称推送操作适用于结点 u。如果在该操作后，残存网络中的边 (u, v) 达到 "),t("strong",[v._v("饱和状态")]),v._v("（即在操作之后有 cf(u, v) == 0），则该推送操作被称为 "),t("strong",[v._v("饱和推送")]),v._v("，否则该操作被称为 "),t("strong",[v._v("非饱和推送")]),v._v("。另外，如果一条边达到饱和状态，它将从残存网络中消失。（具体实现时，残存网络矩阵中 不考虑 cf(u, v) 为 0 的边即可）")]),v._v(" "),t("p",[v._v("根据 "),t("code",[v._v("\\delta_f(u, v) = min(u.e, cf(u, v))")]),v._v(" 可知，当 cf(u, v) <= u.e 时，此推送是饱和推送；否则为非饱和推送，此时 "),t("code",[v._v("\\delta_f(u, v) = u.e")]),v._v("，因此推送操作结束后，结点 u 不再溢出（即下面的引理 26.13）。而且，如果 cf(u, v) == u.e，那么此操作不仅是饱和操作，还能够在推送结束后让 u.e 变为 0，表示消除了结点 u 的溢出状态。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.13")]),v._v("：在从结点 u 到结点 v 的一个非饱和推送操作后，结点 u 将不再溢出。")]),v._v(" "),t("h3",{attrs:{id:"基本操作-重贴标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本操作-重贴标签"}},[v._v("#")]),v._v(" 基本操作-重贴标签")]),v._v(" "),t("p",[v._v("如果结点 u 溢出，并且其邻居结点的高度均不低于 u 的高度 u.h，即对所有的边 (u, v) \\in Ef，有 u.h <= v.h，则如下伪代码描述的基本操作 "),t("code",[v._v("RELABEL(u)")]),v._v(" 适用于结点 u。通过将结点 u "),t("strong",[v._v("提升到适当的高度")]),v._v("，让它可以把溢出的超额流推动给邻居结点。即让 "),t("code",[v._v("PUSH(u, v)")]),v._v(" 操作适用于有向边 (u, v)、适用于结点 u。（另外，根据定义，源结点 s 和汇点 t 都不可能溢出，所以 "),t("code",[v._v("RELABEL")]),v._v(" 操作不会适用于 s 和 t）")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("RELABEL(u)\n1  // Applies when: u is overflowing and for all v \\in V such that (u, v) \\in Ef, u.h <= v.h\n2  // Action: Increase the height of u\n3  u.h = 1 + min(v.h: (u, v) \\in Ef)\n")])])]),t("p",[t("code",[v._v("RELABEL")]),v._v(" 过程的条件中描述的 "),t("code",[v._v("(u, v) \\in Ef")]),v._v("，隐含了残存容量 cf(u, v) > 0。")]),v._v(" "),t("p",[v._v("当调用操作 "),t("code",[v._v("RELABEL(u)")]),v._v(" 时，称结点 u "),t("strong",[v._v("被重贴标签")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"通用的推送-重贴标签算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通用的推送-重贴标签算法"}},[v._v("#")]),v._v(" 通用的推送-重贴标签算法")]),v._v(" "),t("p",[v._v("通用的推送-重贴标签算法 使用子程序 "),t("code",[v._v("INITIALIZE_PREFLOW(G, s)")]),v._v(" 在流网络中创建一个由如下公式定义的初始预流：")]),v._v(" "),t("ul",[t("li",[v._v("若 u == s，则 (u, v).f = c(u, v)")]),v._v(" "),t("li",[v._v("若 u != s，则 (u, v).f = 0")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("INITIALIZE_PREFLOW(G, s)\n1  for each vertex v \\in G.V\n2      v.h = 0\n3      v.e = 0\n4  for each edge(u, v) \\in G.E\n5      (u, v).f = 0\n6  s.h = |G.V|\n7  for each vertex v \\in s.Adj\n8      (s, v).f = c(s, v)\n9      v.e = c(s, v)\n10     s.e = s.e - c(s, v)\n")])])]),t("p",[v._v("该初始化过程 将从源结点 s 发出的所有边都充满流（即理想上 最大流的最大可能取值，也即是切割 ({s}, V-{s}) 的容量），而其它边上都没有流。对于每个与源结点 s 相邻的结点 v，一开始其超额流 v.e = c(s, v)，因为流入 v 的流量是 c(s, v)，而流出 v 的流量为 0。并且将 s.e 初始化为所有这些容量之和的相反数。至于高度(标签)，一开始仅有源结点 s 高度为 "),t("code",[v._v("|V|")]),v._v("，其余结点的高度均为 0。")]),v._v(" "),t("p",[v._v("进行初始化过程后，按非特定次序执行一个序列的推送和重贴标签操作，就能得出如下"),t("strong",[v._v("通用算法")]),v._v("：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("GENERIC_PUSH_RELABEL(G, s, t)\n1  INITIALIZE_PREFLOW(G, s)\n2  while there exists an applicable push or relabel operation\n3      select an applicable push or relabel operation and perform it\n")])])]),t("p",[v._v("下面的引理说明，"),t("strong",[v._v("只要存在溢出结点")]),v._v("，两种基本操作就"),t("strong",[v._v("至少一种可以应用")]),v._v("到该溢出结点上。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.14")]),v._v("（可以对溢出结点执行推送或重贴标签操作）：设 G = （V, E) 是一个源结点为 s、汇点为 t 的流网络，设 f 为一个预流，h 为 f 的任意高度函数。如果 u 是一个溢出结点，则要么可以对结点 u 执行推送操作，要么可以对其执行重贴标签操作。")]),v._v(" "),t("h3",{attrs:{id:"通用推送-重贴标签算法的正确性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通用推送-重贴标签算法的正确性"}},[v._v("#")]),v._v(" 通用推送-重贴标签算法的正确性")]),v._v(" "),t("p",[v._v("为了证明通用的推送-重贴标签算法能够解决最大流问题，下面首先证明"),t("strong",[v._v("如果该算法终止")]),v._v("，"),t("strong",[v._v("预流 f 就是一个最大流")]),v._v("。然后再证明该算法必将终止。下面首先关注高度函数 h。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.15")]),v._v("（"),t("strong",[v._v("结点高度从来不会降低")]),v._v("）：在一个流网络 G = (V, E) 上执行 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 算法的过程中，对于每个结点 u \\in V，其高度 v.h 从来不会减少。而且，每当一个重贴标签操作应用到结点 u 时，其高度 u.h 至少增加一个单位。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.16")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，则 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 算法在 G 上执行的过程中，将"),t("strong",[v._v("维持")]),v._v("属性 h 作为一个"),t("strong",[v._v("高度函数")]),v._v("的各性质。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.17")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 中的一个预流，h 为 V 上的一个高度函数。那么在残存网络 Gf 中不存在一条从源结点 s 到汇点 t 的路径。（即不存在增广路径）")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-1.png",alt:"push-relabel-1"}})]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("定理 26.18")]),v._v("（通用的推送-重贴标签方法的"),t("strong",[v._v("正确性")]),v._v("）：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，如果算法 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 在图 G 上运行时"),t("strong",[v._v("能够终止")]),v._v("，则该算法所计算出的预流 f 是图 G 的"),t("strong",[v._v("一个最大流")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-2.png",alt:"push-relabel-2"}})]),v._v(" "),t("h3",{attrs:{id:"通用推送-重贴标签算法的分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通用推送-重贴标签算法的分析"}},[v._v("#")]),v._v(" 通用推送-重贴标签算法的分析")]),v._v(" "),t("p",[v._v("为了证明通用的推送-重贴标签算法确实会终止，这里给出该算法所执行的操作的次数界。分别对这三类操作求界：重贴标签操作、饱和推送操作、非饱和推送操作。在获得每种操作次数的界后，就可以直接构造一个运行时间为 "),t("code",[v._v("O(|V|^2 |E|)")]),v._v(" 的算法。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.19")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 中的一个预流。那么对于任意溢出结点 x，在"),t("strong",[v._v("残存网络")]),v._v(" Gf 中存在一条从结点 x "),t("strong",[v._v("到源结点")]),v._v(" s 的简单路径。")]),v._v(" "),t("p",[v._v("下面的引理将给出结点的高度的界，该引理的推论则对重贴标签操作的总次数进行了限定。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.20")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，在 G 上执行算法 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 过程中的任意时刻，对于所有结点 u \\in V，均有 "),t("code",[v._v("u.h <= 2|V| - 1")]),v._v("。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("推论 26.21")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，在 G 上执行算法 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 过程中，对"),t("strong",[v._v("每个结点")]),v._v("所执行的"),t("strong",[v._v("重贴标签")]),v._v("操作的次数最多为 "),t("code",[v._v("2|V| - 1")]),v._v(" 次，而"),t("strong",[v._v("所有重贴标签操作")]),v._v("不会超过 "),t("code",[v._v("(2|V| - 1)(|V| - 2) < 2|V|^2")]),v._v(" 次。")]),v._v(" "),t("p",[v._v("引理 26.20 同时也有助于对饱和推送操作的次数进行限定。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.22")]),v._v("（"),t("strong",[v._v("饱和推送")]),v._v("操作次数的上界）：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，在 G 上执行算法 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 过程中，饱和推送操作的次数少于 "),t("code",[v._v("2|V|·|E|")]),v._v("。")]),v._v(" "),t("p",[v._v("下面的引理对通用的推送-重贴标签算法中的非饱和推送操作次数进行了限制。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.23")]),v._v("（"),t("strong",[v._v("非饱和推送")]),v._v("操作次数的上界）：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，在 G 上执行算法 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 过程中，非饱和推送操作的次数少于 "),t("code",[v._v("4|V|^2 (|V| + |E|)")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-3.png",alt:"push-relabel-3"}})]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("定理 26.24")]),v._v("：在任意流网络 G = (V, E) 上执行算法 "),t("code",[v._v("GENERIC_PUSH_RELABEL")]),v._v(" 过程中，基本操作的总次数是 "),t("code",[v._v("O(|V|^2 |E|)")]),v._v("。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("推论 26.25")]),v._v("：对于任意流网络 G = (V, E)，都存在一种通用的推送-重贴标签算法的实现，其运行时间是 "),t("code",[v._v("O(|V|^2 |E|)")]),v._v("。")]),v._v(" "),t("p",[v._v("实现推送-重贴标签算法，往往需要使得每个重贴标签的操作成本为 "),t("code",[v._v("O(|V|)")]),v._v("，而每个推送操作的成本为 O(1)。并且需要设计一个数据结构，使得可以在 O(1) 时间内选出一个合适的操作（以便在当前 while 循环来执行），从而使得整个算法的运行时间为 "),t("code",[v._v("O(|V|^2 |E|)")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"前置重贴标签算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置重贴标签算法"}},[v._v("#")]),v._v(" 前置重贴标签算法")]),v._v(" "),t("p",[v._v("推送-重贴标签方法允许以任意次序执行基本操作（重贴标签、饱和推送、非饱和推送）。而"),t("strong",[v._v("前置重贴标签算法")]),v._v(" (Relabel-To-Front) 仔细地选择操作的次序，并对网络数据结构进行高效地管理，从而达到 "),t("code",[v._v("O(|V|^3)")]),v._v(" 的时间复杂度。")]),v._v(" "),t("p",[v._v("前置重贴标签算法在执行过程中维持一个网络中结点的链表。算法从头到尾对链表进行扫描，每次选择一个溢出结点 u，然后对所选结点进行“释放”：对所选结点执行推送操作和重贴标签操作，直至该结点 u 的超额流量 u.e 等于 0 为止。")]),v._v(" "),t("p",[v._v("因为每次在算法对一个结点进行重贴标签操作时，都会将该结点移动到链表的首部，故此算法得名为 "),t("strong",[v._v("前置重贴标签算法")]),v._v(" (Relabel-To-Front)。在移动之后，算法会开始一次新的扫描。")]),v._v(" "),t("p",[v._v("前置重贴标签算法的正确性和时间复杂度分析 都依赖于所谓的“"),t("strong",[v._v("许可边")]),v._v("”的概念。许可边是指在残存网络中，流可以经其进行推送的边。")]),v._v(" "),t("h3",{attrs:{id:"许可边和网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#许可边和网络"}},[v._v("#")]),v._v(" 许可边和网络")]),v._v(" "),t("p",[v._v("设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 中的一个预流，h 是一个高度函数。对于边 (u, v)，如果 cf(u, v) > 0 且 h(u) = h(v) + 1，则边 (u, v) 是一条"),t("strong",[v._v("许可边")]),v._v("；否则，边 (u, v) 是一条"),t("strong",[v._v("非许可边")]),v._v("。"),t("strong",[v._v("许可网络")]),v._v("是指图 Gfh = (V, Efh)，其中 Efh 是许可边的集合。")]),v._v(" "),t("p",[v._v("从上述定义可知，许可网络由那些可以在其上推送流的边所构成。下面的引理表明这种网络是一个有向无环图 (Directed Acyclic Graph, DAG)：")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.26")]),v._v("（"),t("strong",[v._v("许可网络是无环的")]),v._v("）：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 中的一个预流，h 是一个高度函数。则许可网络 Gfh = (V, Efh) 是无环的。")]),v._v(" "),t("p",[v._v("下面的两个引理说明推送操作和重贴标签操作是如何改变许可网络的：")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.27")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 中的一个预流，h 是一个高度函数。如果结点 u 是一个溢出结点，且 (u, v) 是一条许可边，则 "),t("code",[v._v("PUSH(u, v)")]),v._v(" 操作适用于结点 u。该操作不会创建任何新的许可边，但有可能导致边 (u, v) 成为非许可边。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.28")]),v._v("：设 G = (V, E) 是一个源结点为 s、汇点为 t 的流网络，并设 f 为 G 中的一个预流，h 是一个高度函数。如果结点 u 是一个溢出结点，且不存在从结点 u 发出的许可边，则 "),t("code",[v._v("RELABEL(u)")]),v._v(" 操作适用于结点 u。此外，在对结点 u 进行重贴标签操作后，将至少存在一条从结点 u 发出的许可边，但不存在进入结点 u 的许可边。")]),v._v(" "),t("h3",{attrs:{id:"邻接链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#邻接链表"}},[v._v("#")]),v._v(" 邻接链表")]),v._v(" "),t("p",[v._v("在前置重贴标签算法中，将所有的边都组织为“邻接链表”。给定流网络 G = (V, E)，对于结点 u \\in V，其邻接链表 u.N 是结点 u 在图 G 中的邻接结点所构成的一个单链表。因此，如果边 (u, v) \\in E 或者 (v, u) \\in E，则结点 v 将出现在链表 u.N 中。")]),v._v(" "),t("p",[v._v("邻接链表 u.N 包含的结点恰好是那些可能存在残存边 (u, v) 的结点 v。属性 u.N.head 指向的是邻接链表 u.N 中的第一个结点，v.next-neighbor 指向的是在链表 u.N 中位于结点 v 后面的一个结点（即 v 的后继结点）。如果 v 是链表中的最后一个结点，则该指针的值为 nil 空。")]),v._v(" "),t("p",[v._v("前置重贴标签算法以任意次序遍历每个邻接链表，但是一旦定下来此次序，在算法的整个执行过程中就维持不变了。对于每个结点 u，属性 u.current 指向的是 u.N 链表中当前正在考察的结点。在初始状态下，u.curent 被设置为 u.N.head。")]),v._v(" "),t("h3",{attrs:{id:"释放溢出结点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#释放溢出结点"}},[v._v("#")]),v._v(" 释放溢出结点")]),v._v(" "),t("p",[v._v("对于溢出结点 u，如果将其所有多余的流 通过许可边推送到相邻的结点上，则称该结点得到"),t("strong",[v._v("释放")]),v._v("。在释放过程中，需要对结点 u 进行重贴标签操作，这使得从结点 u 发出的某条边成为许可边。下面是释放操作 "),t("code",[v._v("DISCHARGE")]),v._v(" 的伪代码：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("DISCHARGE(u)\n1  while u.e > 0\n2      v = u.current\n3      if v == nil\n4          RELABEL(u)\n5          u.current = u.N.head\n6      elseif cf(u, v) > 0 and u.h == v.h + 1\n7          PUSH(u, v)\n8      else\n9          u.current = v.next-neighbor\n")])])]),t("p",[v._v("算法流程描述如下：")]),v._v(" "),t("ol",[t("li",[v._v("在 1～9 行的 while 循环，只要结点 u 还有正值的超额流量 u.e，该循环就持续执行。每次迭代执行三种操作中的某一种，具体执行哪种操作取决于邻接链表 u.N 中当前结点 v 的情况。")]),v._v(" "),t("li",[v._v("在 2 行，取出 u 的邻接结点中 当前需要考虑的结点 v。")]),v._v(" "),t("li",[v._v("在 3～5 行，分支一：如果结点是 nil 空，则表示运行到了链表 u.N 的尾部了，前面的邻居结点 v 都已考虑过了。此时 u 还有超额流量 u.e > 0，所以需要对 u 执行重贴标签操作，以提升其高度，便于执行 "),t("code",[v._v("PUSH")]),v._v(" 操作来推送 u 中超额的流量。\n"),t("ul",[t("li",[v._v("在 4 行，对结点 u 进行重贴标签操作、提升结点高度。")]),v._v(" "),t("li",[v._v("在 5 行，将结点 u 的当前考虑结点设为 u.N 的首元素。")])])]),v._v(" "),t("li",[v._v("在 6～7 行，分支二：结点 v 不是 nil 空，并且边 (u, v) 是一条许可边，则第 7 行将结点 u 的部分（也可能是全部）超额流量推送到结点 v 上。")]),v._v(" "),t("li",[v._v("在 8～9 行，分支三：结点 v 不是 nil 空，但边 (u, v) 是非许可边，则第 9 行将邻接链表 u.N 中的 u.current 指针指向 v 的后继结点，下轮 while 循环考虑此后继结点。")])]),v._v(" "),t("p",[v._v("另外，注意到，如果针对一个溢出结点 u 来调用 "),t("code",[v._v("DISCHARGE(u)")]),v._v(" 算法，则此过程所执行的最后一个操作必定是对结点 u 所执行的推送操作。因为该算法终止的唯一条件是当 u.e 为 0 时，重贴标签操作 和 将指针 u.current 指向 v 的后继结点的操作 都不会影响 u.e 的取值。")]),v._v(" "),t("p",[v._v("下面图 26-9 描述的是 "),t("code",[v._v("DISCHARGE(u)")]),v._v(" 算法 while 循环的几次执行。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-4.png",alt:"push-relabel-4"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-5.png",alt:"push-relabel-5"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-6.png",alt:"push-relabel-6"}})]),v._v(" "),t("p",[v._v("必须确保，当 "),t("code",[v._v("DISCHARGE(u)")]),v._v(" 算法调用 "),t("code",[v._v("PUSH")]),v._v(" 或 "),t("code",[v._v("RELABEL")]),v._v(" 操作时，该操作确实是当时适用的操作。下面的引理将证明这个性质。")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("引理 26.29")]),v._v("：如果 "),t("code",[v._v("DISCHARGE(u)")]),v._v(" 算法在第 7 行调用 "),t("code",[v._v("PUSH(u, v)")]),v._v(" 操作，则此时推送操作适用于边 (u, v)。如果 "),t("code",[v._v("DISCHARGE(u)")]),v._v(" 算法在第 4 行调用 "),t("code",[v._v("RELABEL(u)")]),v._v(" 操作，则此时重贴标签操作适用于结点 u。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-7.png",alt:"push-relabel-7"}})]),v._v(" "),t("h3",{attrs:{id:"前置重贴标签算法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置重贴标签算法实现"}},[v._v("#")]),v._v(" 前置重贴标签算法实现")]),v._v(" "),t("p",[v._v("在前置重贴标签算法中，维持一个链表 L，该链表由 V - {s, t} 中的所有结点构成。这里的关键性质是：链表 L 中的结点均按照"),t("strong",[v._v("许可网络")]),v._v("的"),t("strong",[v._v("拓扑排序")]),v._v("次序存放。（由前面的引理 26.26 可知，许可网络是一个有向无环图 DAG）")]),v._v(" "),t("p",[v._v("在下面的伪代码中，假定针对每个结点 u，邻接链表 u.N 都已经被创立。该算法同时还假定 u.next 指针指向链表 L 中紧随结点 u 的结点（结点 u 的后继结点），并且如果结点 u 是链表的最后一个结点，则 u.next = nil。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("RELABEL_TO_FRONT(G, s, t)\n1  INITIALIZE_PREFLOW(G, s)\n2  L = G.V - {s, t}, in any order\n3  for each vertex u \\in G.V - {s, t}\n4      u.current = u.N.head\n5  u = L.head\n6  while u != nil\n7      old_height = u.h\n8      DISCHARGE(u)\n9      if u.h > old_height\n10         move u to the front of list L\n11         u = u.next\n")])])]),t("p",[v._v("算法流程描述如下：")]),v._v(" "),t("ol",[t("li",[v._v("在 1 行，对网络的预流和结点高度进行初始化。此初始化过程调用与 通用推送-重贴标签算法用到的初始化过程 相同。")]),v._v(" "),t("li",[v._v("在 2 行，对链表 L 进行初始化，其中包含的是所有可能出现潜在溢出的结点，而结点之间的次序可以是任意的。\n"),t("ul",[t("li",[v._v("因为此时没有许可边，所以任意次序都是 Gfh 的一个拓扑排序，此后的循环过程中也会保持链表 L 中结点的次序为拓扑排序。")])])]),v._v(" "),t("li",[v._v("在 3～4 行，对每个结点 u 的 current 指针进行初始化，使该指针指向 u 的邻接链表 u.N 的首元素。")]),v._v(" "),t("li",[v._v("在 5 行，获取链表首元素 u，从 u 开始考察处理。")]),v._v(" "),t("li",[v._v("在 6～11 行的 while 循环中，对链表 L 进行遍历并逐个释放结点。\n"),t("ul",[t("li",[v._v("在 7 行，记录 "),t("code",[v._v("DISCHARGE")]),v._v(" 释放操作前 u 的高度。如果结点 u 在释放过程中执行了重贴标签操作，其高度会提升，从而方便第 9 行的判断。")]),v._v(" "),t("li",[v._v("在 8 行，对结点 u 进行释放操作。")]),v._v(" "),t("li",[v._v("在 9 行，通过高度变化来判断 u 在释放过程中 是否执行过重贴标签操作。")]),v._v(" "),t("li",[v._v("在 10 行，如果 u 执行过重贴标签操作，则将结点 u 移至链表 L 首部。")]),v._v(" "),t("li",[v._v("在 11 行，以链表 L 中结点 u（此时已被移动至 L 首部）的后继结点作为下一次 while 循环处理的结点。")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-8.png",alt:"push-relabel-8"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-9.png",alt:"push-relabel-9"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-10.png",alt:"push-relabel-10"}})]),v._v(" "),t("h3",{attrs:{id:"前置重贴标签算法分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置重贴标签算法分析"}},[v._v("#")]),v._v(" 前置重贴标签算法分析")]),v._v(" "),t("p",[v._v("可以证明，前置重贴标签算法在"),t("strong",[v._v("任何流网络")]),v._v(" G = (V, E) 上的运行时间为 "),t("code",[v._v("O(|V|^3)")]),v._v("。因为该算法是通用的推送-重贴标签算法的一种实现。")]),v._v(" "),t("p",[v._v("前面的推论 26.21 说明每个结点的重贴标签操作次数不超过 "),t("code",[v._v("O(|V|)")]),v._v("，因此所有结点的重贴标签操作总次数不超过 "),t("code",[v._v("O(|V|^2)")]),v._v("。而前面的引理 26.22 说明饱和推送操作的总次数为 "),t("code",[v._v("O(|V|·|E|)")]),v._v("。另外，《CLRS》联系 26.4-3 表明：通用的推送-重贴标签算法只用了总共 "),t("code",[v._v("O(|V|·|E|)")]),v._v(" 的时间来执行所有 "),t("code",[v._v("O(|V|^2)")]),v._v(" 个重贴标签操作。于是有如下定理：")]),v._v(" "),t("p",[v._v("《CLRS》"),t("strong",[v._v("定理 26.30")]),v._v("：前置重贴标签算法在任何流网络 G = (V, E) 上的运行时间为 "),t("code",[v._v("O(|V|^3)")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-11.png",alt:"push-relabel-11"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/max-flow-matching/push-relabel-12.png",alt:"push-relabel-12"}})]),v._v(" "),t("h2",{attrs:{id:"python-代码范例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#python-代码范例"}},[v._v("#")]),v._v(" Python 代码范例")]),v._v(" "),t("p",[v._v("Python 环境：Python 3.7")]),v._v(" "),t("h3",{attrs:{id:"relabel-to-front-前置重贴标签-最大流算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#relabel-to-front-前置重贴标签-最大流算法"}},[v._v("#")]),v._v(" Relabel-To-Front 前置重贴标签-最大流算法")]),v._v(" "),t("ul",[t("li",[v._v("Ford-Fulkerson 方法\n"),t("ul",[t("li",[v._v("Ford-Fulkerson 算法 O(V |f*|)")]),v._v(" "),t("li",[v._v("Edmonds-Karp 算法 O(V E^2)")])])]),v._v(" "),t("li",[v._v("Push-Relabel 推送-重贴标签方法\n"),t("ul",[t("li",[v._v("Push-Relabel 通用的推送-重贴标签算法 O(V^2 E)")]),v._v(" "),t("li",[v._v("Relabel-To-Front 前置重贴标签算法 O(V^3)")])])])]),v._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/max-flow-matching/push-relabel.py",target:"_blank",rel:"noopener noreferrer"}},[v._v("GitHub Code Link"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" 参考资料")]),v._v(" "),t("ul",[t("li",[v._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 26")])])])}),[],!1,null,null,null);_.default=r.exports}}]);