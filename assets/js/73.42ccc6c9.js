(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{525:function(v,_,t){"use strict";t.r(_);var r=t(28),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"algorithm-linear-programming"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-linear-programming"}},[v._v("#")]),v._v(" Algorithm - Linear Programming")]),v._v(" "),t("p",[v._v("By "),t("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[v._v("YuweiYin"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),t("ul",[t("li",[v._v("线性规划 Linear Programming\n"),t("ul",[t("li",[t("a",{attrs:{href:"./simplex"}},[v._v("单纯形算法")]),v._v(" Simplex Algorithm")])])])]),v._v(" "),t("h2",{attrs:{id:"线性规划-lp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性规划-lp"}},[v._v("#")]),v._v(" 线性规划 LP")]),v._v(" "),t("p",[v._v("在给定"),t("strong",[v._v("有限的资源")]),v._v("和"),t("strong",[v._v("竞争约束")]),v._v("情况下，很多问题都可以表述为最大化或最小化某个目标的"),t("strong",[v._v("最优化问题")]),v._v(" Optimization。")]),v._v(" "),t("p",[v._v("如果可以把目标描述为"),t("strong",[v._v("某些变量的一个线性函数")]),v._v("，而且可以将资源的约束指定为这些变量的"),t("strong",[v._v("等式或不等式")]),v._v("，那么可以得到一个"),t("strong",[v._v("线性规划问题")]),v._v(" (Linear-Programming Problem)：给定线性(等式/不等式)约束情况下的线性函数最优化问题。线性规划出现在许多实际应用中。")]),v._v(" "),t("h3",{attrs:{id:"一般线性规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一般线性规划"}},[v._v("#")]),v._v(" 一般线性规划")]),v._v(" "),t("p",[v._v("在一般线性规划问题中，目标是最优化一个满足一组线性不等式约束的线性函数。")]),v._v(" "),t("p",[v._v("已知一组实数 a1, a2, ..., an 和一组变量 x1, x2, ..., xn。给出定义在这些变量上的一个"),t("strong",[v._v("线性函数")]),v._v(" f：")]),v._v(" "),t("p",[v._v("$$ f(x_{1}, x_{2}, ..., x_{n}) = a_{1} x_{1} + a_{2} x_{2} + ... + a_{n} x_{n} = \\sum_{j=1}^{n} a_{j} x_{j} $$")]),v._v(" "),t("p",[v._v("如果 b 是一个实数而 f 是一个线性函数，并记 $ x = (x_{1}, x_{2}, ..., x_{n}) $，则等式 $ f(x) = b $ 是"),t("strong",[v._v("线性等式")]),v._v("，而不等式 $ f(x) <= b $ 和 $ f(x) >= b $ 是"),t("strong",[v._v("线性不等式")]),v._v("。线性等式或线性不等式可被统称为"),t("strong",[v._v("线性约束")]),v._v("。另外，在线性规划问题中，一般不允许严格不等式（即严格小于或严格大于），这意味着允许边界取值情况。")]),v._v(" "),t("p",[v._v("形式化地，一个"),t("strong",[v._v("线性规划问题")]),v._v("是一个线性函数最小化或最大化的问题，该线性函数服从一组有限个线性约束。")]),v._v(" "),t("p",[v._v("如果是要最小化目标线性函数，则称此线性规划为"),t("strong",[v._v("最小化线性规划")]),v._v("；如果要最大化目标线性函数，则称此线性规划为"),t("strong",[v._v("最大化线性规划")]),v._v("。此二者通常可以很容易地互相转换，比如 对目标线性函数取相反数。")]),v._v(" "),t("p",[v._v("虽然已有一些线性规划的多项式时间算法，但这里着重研究"),t("strong",[v._v("单纯形算法")]),v._v("。单纯形算法是最古老的线性规划算法，其最坏情况运行时间不是多项式阶的，但是它在实际应用中相当高效，因此得到广泛使用。")]),v._v(" "),t("h3",{attrs:{id:"线性规划综述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性规划综述"}},[v._v("#")]),v._v(" 线性规划综述")]),v._v(" "),t("p",[v._v("使用"),t("strong",[v._v("规范形式")]),v._v("来描述线性规划的性质和算法是很方便的："),t("strong",[v._v("标准型")]),v._v("、"),t("strong",[v._v("松弛型")]),v._v("。")]),v._v(" "),t("p",[v._v("非正式地，标准型 LP 是满足线性"),t("strong",[v._v("不等式")]),v._v("约束的线性函数最优化问题；而松弛型 LP 是满足线性"),t("strong",[v._v("等式")]),v._v("约束的线性函数最优化问题。通常用标准型来表示线性规划，但当描述单纯形算法时，使用松弛形式会比较方便。")]),v._v(" "),t("p",[v._v("如下讨论满足一组具有 m 个线性不等式约束的、具有 n 个变量的线性函数的最优化问题。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-1.png",alt:"lp-1"}})]),v._v(" "),t("p",[v._v("线性规划的最优解出现在可行域的一个顶点上并不是偶然。目标线性函数与可行域的边界的交集，要么是一个单独顶点，要么是一条线段。如果交集是一个顶点，那么只有一个最优解，就是该顶点。如果交集是一条线段，那么此线段上的每一点都有相同的目标值。特别地，此线段的两个端点都是最优解。由于线段的端点也是可行域的顶点，所以此情况下最优解也是在一个顶点上。")]),v._v(" "),t("p",[v._v("如果有三个变量，则每个约束对应于三维空间的一个"),t("strong",[v._v("半空间")]),v._v("。这些半空间的交集形成可行域（凸域/凸集）。目标函数取目标值的点集合 现在变成了一个平面（假设没有非退化的情况出现）。从图形直观上看，如果目标函数的系数都是非负的，而且如果原点是线性规划的一个可行解，那么当把这个平面沿目标函数的垂直方向移开原点时，就可以找到一系列的点，其目标值是递增的。")]),v._v(" "),t("p",[v._v("如同在二维空间一样， 因为"),t("strong",[v._v("可行域是凸的")]),v._v("，取得最优目标值的点集合"),t("strong",[v._v("必然包含可行域的一个顶点")]),v._v("。类似地，如果有 n 个变量，每个约束定义了 n 维空间中的一个半空间。则称这些半空间的交集形成的可行区域为"),t("strong",[v._v("单纯形")]),v._v(" (Simplex)。目标函数现在是一个"),t("strong",[v._v("超平面")]),v._v("，并且因为可行域的凸性，一个最优解仍在单纯形的一个顶点上取得。")]),v._v(" "),t("p",[t("strong",[v._v("单纯形算法")]),v._v("以一个线性规划作为输入，输出一个最优解(及其最优值)。它从单纯形的某个顶点开始，执行顺序迭代。在每次迭代中，沿着单纯形的"),t("strong",[v._v("一条边")]),v._v("从"),t("strong",[v._v("当前顶点")]),v._v("移动到一个 目标值不小于当前值的"),t("strong",[v._v("相邻顶点")]),v._v("（贪心策略）。当达到一个"),t("strong",[v._v("局部极大值")]),v._v("时，单纯形算法"),t("strong",[v._v("终止")]),v._v("。因为可行域是凸的，且目标函数是线性的的，所以该局部极大值就是约束条件下的全局最大值。")]),v._v(" "),t("h3",{attrs:{id:"线性规划的应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性规划的应用"}},[v._v("#")]),v._v(" 线性规划的应用")]),v._v(" "),t("p",[v._v("线性规划 LP 有大量的应用。运筹学中大量研究了线性规划的应用。")]),v._v(" "),t("p",[v._v("另外，很多图论问题与线性规划有着密切的关系。例如，可以用 Bellman-Ford 单源最短路径算法求解线性规划中的差分约束系统，可以用将 Max-Flow 最大流问题形式化为线性规划问题。")]),v._v(" "),t("h3",{attrs:{id:"线性规划算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性规划算法"}},[v._v("#")]),v._v(" 线性规划算法")]),v._v(" "),t("p",[t("strong",[v._v("单纯形算法")]),v._v("是经典的线性规划算法。当此算法被精心实现时，在实际中通常能够快速地解决一般的线性规划问题。然而对于某些刻意设计的输入，单纯形算法会需要指数时间（即在迭代中很缓慢地搜索，耗费很久才能到达局部最值）。")]),v._v(" "),t("p",[v._v("线性规划问题的第一个多项式时间算法时"),t("strong",[v._v("椭球算法")]),v._v("，但它在实际中运行缓慢。第二类多项式时间的算法称为"),t("strong",[v._v("内点法")]),v._v("。与单纯形算法（即沿着可行域的"),t("strong",[v._v("外部边缘移动")]),v._v("，并在每次迭代中维护一个对应单纯形顶点的可行解）相比，这类算法"),t("strong",[v._v("在可行区域的内部移动")]),v._v("。中间结点的解尽管是可行的，但未必是单纯形的顶点，但"),t("strong",[v._v("最终的解是一个顶点")]),v._v("，且是最优解。对于大规模的输入，内点算法的性能可与单纯形算法相当，有时甚至会更快。")]),v._v(" "),t("p",[v._v("如果在一个线性规划中加入额外的要求，即所有的变量都只能取整数值（即可行域是 原本的单纯形 与 离散的整数笛卡尔点集 的交集），那么问题就变成了"),t("strong",[v._v("整数线性规划")]),v._v("。找出整数线性规划的一个可行解是 NP hard 的。因为目前还没有已知的多项式时间算法能够解任意一个 NP hard 的问题，于是还没有已知的整数线性规划的多项式时间算法。相比而言，可以在多项式时间内求解一般的线性规划问题。")]),v._v(" "),t("h2",{attrs:{id:"标准型和松弛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标准型和松弛型"}},[v._v("#")]),v._v(" 标准型和松弛型")]),v._v(" "),t("p",[v._v("在"),t("strong",[v._v("标准型")]),v._v("中，所有的约束都是"),t("strong",[v._v("不等式")]),v._v("；而在"),t("strong",[v._v("松弛型")]),v._v("中，所有的约束都是"),t("strong",[v._v("等式")]),v._v("（除了要求变量非负之类的约束）。")]),v._v(" "),t("h3",{attrs:{id:"标准型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标准型"}},[v._v("#")]),v._v(" 标准型")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-2.png",alt:"lp-2"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-3.png",alt:"lp-3"}})]),v._v(" "),t("h3",{attrs:{id:"转换线性规划为标准型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换线性规划为标准型"}},[v._v("#")]),v._v(" 转换线性规划为标准型")]),v._v(" "),t("p",[v._v("已知一个线性函数满足若干线性条件，要求最小化或最大化它，总可以将这个线性规划转换为标准型。一个线性规划可能由于如下 4 个原因而不是标准型：")]),v._v(" "),t("ol",[t("li",[v._v("目标函数可能是最小化，而不是最大化。")]),v._v(" "),t("li",[v._v("可能有变量不具有非负约束。")]),v._v(" "),t("li",[v._v("可能有等式约束。")]),v._v(" "),t("li",[v._v("可能有大于等于的不等式约束。")])]),v._v(" "),t("p",[v._v("对应的转换方法：")]),v._v(" "),t("ol",[t("li",[v._v("为将一个最小化线性规划 L 转换成一个等价的最大化线性规划 L'，只需对"),t("strong",[v._v("目标函数")]),v._v("中的"),t("strong",[v._v("系数全部取相反数")]),v._v("即可。")]),v._v(" "),t("li",[v._v("假设某个变量 xj 不具有非负约束，那么把 xj 每次出现的地方都用 xj' - xj'' 来替换，并增加非负约束 xj' >= 0 和 xj'' >= 0。\n"),t("ul",[t("li",[v._v("因此，如果目标函数有一个项为 cj xj，则将之替换为 cj xj' - cj xj''。")]),v._v(" "),t("li",[v._v("如果约束 i 有一个项为 aij xj，则将之替换为为 aij xj' - aij xj''。")]),v._v(" "),t("li",[v._v("新的线性规划的任意可行解 $ \\hat x $ 对应于原来线性规划的一个可行解 $ \\bar x $。\n"),t("ul",[t("li",[v._v("其中 $ \\bar xj = \\hat xj' - \\hat xj'' $，而且具有相同的目标值。")])])]),v._v(" "),t("li",[v._v("同样地，原来 LP 的一个可行解 $ \\bar x $ 对应于新的 LP 的可行解 $ \\hat x $。\n"),t("ul",[t("li",[v._v("其中，若 $ \\bar xj >= 0 $，则 $ \\hat xj' = \\bar xj $ 且 $ \\hat xj'' = 0 $；")]),v._v(" "),t("li",[v._v("或者若 $ \\bar xj < 0 $，则 $ \\hat xj'' = - \\bar xj $ 且 $ \\hat xj' = 0 $。")])])])])]),v._v(" "),t("li",[v._v("将等式约束转换为不等式约束，则只需将原本的等式约束替换为两个不等式约束即可（= 等价于 <= 且 >=）。")]),v._v(" "),t("li",[v._v("将大于等于的不等式约束 左右两端乘以 -1，即可将之转换为小于等于的不等式约束。")])]),v._v(" "),t("h3",{attrs:{id:"转换线性规划为松弛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转换线性规划为松弛型"}},[v._v("#")]),v._v(" 转换线性规划为松弛型")]),v._v(" "),t("p",[v._v("为了利用单纯形算法高效地求解线性规划问题，更希望将其表示成某些约束是等式约束的形式。更准确地说，将它转换成只有"),t("strong",[v._v("变量的非负约束")]),v._v("是不等式约束，其余约束都是"),t("strong",[v._v("等式约束")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-4.png",alt:"lp-4"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-5.png",alt:"lp-5"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-6.png",alt:"lp-6"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-7.png",alt:"lp-7"}})]),v._v(" "),t("h2",{attrs:{id:"将问题表达为线性规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#将问题表达为线性规划"}},[v._v("#")]),v._v(" 将问题表达为线性规划")]),v._v(" "),t("p",[v._v("识别一个问题是否可以形式化为一个线性规划问题，就可以用线性规划的解法（如单纯形算法、椭球算法、内点算法等）去求解原问题。")]),v._v(" "),t("h3",{attrs:{id:"最短路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最短路径"}},[v._v("#")]),v._v(" 最短路径")]),v._v(" "),t("p",[v._v("可以把"),t("strong",[v._v("单源最短路径问题")]),v._v("形式化为一个线性规划。先讨论"),t("strong",[v._v("单对")]),v._v("最短路径问题，然后推广到更一般的单源最短路径问题。")]),v._v(" "),t("p",[v._v("在单对最短路径问题中，已知一个"),t("strong",[v._v("带(边)权有向图")]),v._v(" G = (V, E)，"),t("strong",[v._v("加权函数")]),v._v(" w: E -> R 把边映射为实数权值、一个"),t("strong",[v._v("源顶点 s")]),v._v(" (source) 和一个"),t("strong",[v._v("终点顶点 t")]),v._v(" (terminal)。目标是计算从 s 到 t 的一条"),t("strong",[v._v("最短路径的权值")]),v._v(" t.d (distance)。")]),v._v(" "),t("p",[v._v("为了把此问题表示成一个线性规划，需要确定变量和约束的一个集合 来定义什么情况下有从 s 到 t 的一条最短路径。而 Bellman-Ford 算法就可以完成此任务：当 BF 算法终止时，对每个顶点 v，它已计算了一个值 v.d，使得对每条边 (u, v) \\in E 有 v.d <= u.d + w(u, v)。源顶点初始得到一个值 s.d = 0 后不会再改变。")]),v._v(" "),t("p",[v._v("因此可以得到如下的线性规划，来计算从 s 到 t 的最短路径权值：")]),v._v(" "),t("ul",[t("li",[v._v("最大化：t.d")]),v._v(" "),t("li",[v._v("满足约束：\n"),t("ul",[t("li",[v._v("v.d <= u.d + w(u, v)  \\forall (u, v) \\in E")]),v._v(" "),t("li",[v._v("s.d == 0")])])])]),v._v(" "),t("p",[v._v("这个线性规划中有 "),t("code",[v._v("|V|")]),v._v(" 个变量 v.d，对于每个顶点 v \\in V 有一个相应变量。另外还有 "),t("code",[v._v("|E| + 1")]),v._v(" 个约束：每条边上有一个约束，外加源顶点有 s.d == 0 的额外约束。")]),v._v(" "),t("h3",{attrs:{id:"最大流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最大流"}},[v._v("#")]),v._v(" 最大流")]),v._v(" "),t("p",[v._v("回顾"),t("strong",[v._v("最大流问题")]),v._v("，已知一个"),t("strong",[v._v("有向图")]),v._v(" G = (V, E)，其中每条边 (u, v) \\in E 有一个"),t("strong",[v._v("非负的容量值")]),v._v(" c(u, v) >= 0，以及两个特殊的顶点："),t("strong",[v._v("源点 s")]),v._v(" (source) 和"),t("strong",[v._v("汇点 t")]),v._v(" (terminal)。流网络中的一个"),t("strong",[v._v("流")]),v._v(" (flow) 是一个"),t("strong",[v._v("非负的实值函数")]),v._v(" f: V x V -> R，它满足容量限制和流量守恒性质。"),t("strong",[v._v("最大流")]),v._v(" (Max-Flow) 是满足这些约束且最大化流量值的流，其中流量值是从源点 s 流出的总流量值 减去 进入源点 s 的总流量。因此，流满足线性约束并且一个流的值是一个线性函数。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-8.png",alt:"lp-8"}})]),v._v(" "),t("p",[v._v("重写的思路：对每条(实际存在的)边的流量，维持非负、容量守恒性质，总共 "),t("code",[v._v("O(|E|)")]),v._v("；对每个顶点，维持流量守恒性质，总共 "),t("code",[v._v("O(|V|)")]),v._v("。")]),v._v(" "),t("p",[v._v("另外，由于二分图/二部图的"),t("strong",[v._v("最大二分匹配")]),v._v("问题可以被转化为最大流问题来解决，因此它也能被转换为一个线性规划问题。")]),v._v(" "),t("h3",{attrs:{id:"最小费用流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最小费用流"}},[v._v("#")]),v._v(" 最小费用流")]),v._v(" "),t("p",[v._v("如果一个问题可以转换为线性规划，则可以线性规划的算法来解决此问题，这往往是一种较为通用的方法。但事实上，为一个问题设计一个高效的专用算法，在理论和实践上通常比 LP 更加高效。例如，用于单源最短路径问题的 Dijkstra 算法，用于最大流问题的推送-重贴标签 (push-relabel) 方法。")]),v._v(" "),t("p",[v._v("线性规划的真正能力来自其求解新问题的能力。当对一个新问题缺乏研究、不曾有专用的高效算法时，可以考虑先将之转换为线性规划，并用线性规划算法解决之。")]),v._v(" "),t("p",[v._v("例如，考虑最大流问题的推广——"),t("strong",[v._v("最小费用流问题")]),v._v("。假设每条边 (u, v) 除了有容量 c(u, v) 外，还有一个实数值的费用 a(u, v)。如果通过边 (u, v) 传送 (u, v).f 个单位的流，那么将产生费用 a(u, v) * (u, v).f。给定一个流目标 d，希望从 s 到 t 发送 d 个单位的流，同时使得流上产生的总费用最小。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-9.png",alt:"lp-9"}})]),v._v(" "),t("h3",{attrs:{id:"多商品流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多商品流"}},[v._v("#")]),v._v(" 多商品流")]),v._v(" "),t("p",[v._v("考虑另一个流问题。假设公司要生产多个商品，不同的商品每天需要被运送到不同城市的仓库，而运输图是共用同一个流网络（流网络各边的容量不变/固定）。")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-10.png",alt:"lp-10"}})]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-11.png",alt:"lp-11"}})]),v._v(" "),t("p",[v._v("另外，还可以将最小费用流问题与多商品流问题结合起来，形成 "),t("strong",[v._v("最小费用多商品流问题")]),v._v("：")]),v._v(" "),t("p",[t("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/linear-programming/lp-12.png",alt:"lp-12"}})]),v._v(" "),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[v._v("#")]),v._v(" 参考资料")]),v._v(" "),t("ul",[t("li",[v._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 29")])])])}),[],!1,null,null,null);_.default=a.exports}}]);