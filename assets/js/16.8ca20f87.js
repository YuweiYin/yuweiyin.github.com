(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{516:function(t,a,e){"use strict";e.r(a);var n=e(28),s=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"algorithm-data-structure-fibonacci-heap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-fibonacci-heap"}},[t._v("#")]),t._v(" Algorithm - Data Structure - Fibonacci Heap")]),t._v(" "),e("p",[t._v("By "),e("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"_1-简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-简介"}},[t._v("#")]),t._v(" 1. 简介")]),t._v(" "),e("p",[t._v("斐波那契堆 (Fibonacci Heap) 有两种用途：")]),t._v(" "),e("ol",[e("li",[t._v("它支持一系列操作，这些操作构成了所谓的"),e("strong",[t._v("可合并堆")]),t._v(" (mergeable heap)。")]),t._v(" "),e("li",[t._v("斐波那契堆的一些操作可以在常数摊还时间内完成，这使得这种数据结构非常适合于需要频繁调用这些操作的应用。\n"),e("ul",[e("li",[t._v("比如 "),e("code",[t._v("decrease_key")]),t._v(" 操作可以在常数摊还时间内完成，使得它成为某些迄今为止渐近最快的图问题算法的核心部分。")])])])]),t._v(" "),e("h3",{attrs:{id:"_1-1-可合并堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-可合并堆"}},[t._v("#")]),t._v(" 1.1. 可合并堆")]),t._v(" "),e("p",[e("strong",[t._v("可合并堆")]),t._v(" (mergeable heap) 是支持以下 5 种操作的一种数据结构（注意：这里默认为"),e("strong",[t._v("最小")]),t._v("可合并堆，可类似地构造最大可合并堆），其中每个元素都有关键字域 key：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("make_heap()")]),t._v(" "),e("ul",[e("li",[t._v("创建和返回一个新的不含任何元素的堆。")]),t._v(" "),e("li",[t._v("一般而言，创建成功则返回布尔值 True；创建失败则返回布尔值 False。")])])]),t._v(" "),e("li",[e("code",[t._v("insert(h, x)")]),t._v(" "),e("ul",[e("li",[t._v("将一个具有关键字 key 的元素 x 插入堆 h 中。")]),t._v(" "),e("li",[t._v("一般而言，插入成功则返回布尔值 True；插入失败则返回布尔值 False。")])])]),t._v(" "),e("li",[e("code",[t._v("minimum(h)")]),t._v(" "),e("ul",[e("li",[t._v("返回堆 h 中具有最小关键字的元素 (的指针)。")]),t._v(" "),e("li",[t._v("一般而言，查询失败 (比如堆 h 为空堆) 则返回 NIL 空指针。")])])]),t._v(" "),e("li",[e("code",[t._v("extract_min(h)")]),t._v(" "),e("ul",[e("li",[t._v("从堆 h 中删除具有最小关键字的元素，并返回它 (的指针)。")]),t._v(" "),e("li",[t._v("一般而言，操作失败 (比如堆 h 为空堆) 则返回 NIL 空指针。")])])]),t._v(" "),e("li",[e("code",[t._v("union(h1, h2)")]),t._v(" "),e("ul",[e("li",[t._v("创建并返回一个包含堆 h1 和堆 h2 中所有元素的新堆 (的指针)。")]),t._v(" "),e("li",[t._v("“旧”堆 h1 和 h2 通常会被销毁。")]),t._v(" "),e("li",[t._v("一般而言，合并失败则返回 NIL 空指针。")])])])]),t._v(" "),e("p",[t._v("除了上述 5 个可合并堆的基本操作外，斐波那契堆还支持如下 2 种操作：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("decrease_key(h, x, k)")]),t._v(" "),e("ul",[e("li",[t._v("将堆 h 中元素 x 的关键字赋予新值 k")]),t._v(" "),e("li",[t._v("注意：由于这里默认为最小堆，所以新值 k 不大于 x.key。")]),t._v(" "),e("li",[t._v("一般而言，操作成功则返回布尔值 True；操作失败则返回布尔值 False。")]),t._v(" "),e("li",[t._v("也可以通过关键字来定位元素，即 "),e("code",[t._v("decrease_key(h, old_k, new_k)")]),t._v("：通过关键字 "),e("code",[t._v("old_k")]),t._v(" 找到元素 x，并将 x.key 改为 "),e("code",[t._v("new_k")]),t._v("。")]),t._v(" "),e("li",[t._v("但是 search 搜索操作在堆结构中是低效的，所以往往传入的参数为元素对象 x。")])])]),t._v(" "),e("li",[e("code",[t._v("delete(h, x)")]),t._v(" "),e("ul",[e("li",[t._v("从堆 h 中删除元素 x。")]),t._v(" "),e("li",[t._v("一般而言，删除成功则返回布尔值 True；删除失败则返回布尔值 False。")]),t._v(" "),e("li",[t._v("也可以通过关键字来定位元素，即 delete(h, k)：通过关键字 k 找到元素 x，并将 x 删除。")]),t._v(" "),e("li",[t._v("但是 search 搜索操作在堆结构中是低效的，所以往往传入的参数为元素对象 x。")])])])]),t._v(" "),e("h3",{attrs:{id:"_1-2-斐波那契堆与二项堆堆对比"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-斐波那契堆与二项堆堆对比"}},[t._v("#")]),t._v(" 1.2. 斐波那契堆与二项堆堆对比")]),t._v(" "),e("p",[t._v("一般采用摊还分析来分析斐波那契堆的各操作运行时间，与二项堆/二叉堆 (Binary Heap) 的最坏情况对比如下（n 为操作时堆中的项数）：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("操作")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("二项堆 (最坏)")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("斐波那契堆 (摊还)")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("make_heap")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("insert")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(log n) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("minimum")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("extract_min")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(log n) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ O(log n) $")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("union")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(n) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("decrease_key")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(log n) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(1) $")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("delete")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ \\Theta(log n) $")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("$ O(log n) $")])])])]),t._v(" "),e("p",[t._v("可以看出，如果不考虑 union 合并操作需求，堆排序中常常使用的普通二项堆的操作性能相当好。除 union 操作外，二项堆的其它操作均可在最坏情况时间为 O(log n) 下完成。")]),t._v(" "),e("p",[t._v("但是，如果需要支持 union 操作，则二项堆的性能就退化到了 O(n)：通过把两个分别包含 待合并二项堆的数组 进行链接，然后重新建堆，从而实现合并操作。在最坏情况下需要 $ \\Theta(n) $ 时间。")]),t._v(" "),e("p",[t._v("另一方面，斐波那契堆对于操作 insert、union 和 "),e("code",[t._v("decrease_key")]),t._v(" 均比二项堆有更好的渐近时间界。而对于其它几种操作，二者有相同的渐近运行时间。")]),t._v(" "),e("p",[t._v("注意到，二项堆和斐波那契堆对于 search 操作的支持均比较低效：可能需要花费不少的一段时间才能找到具有给定关键字的元素。为此，涉及到给定元素的操作，如 "),e("code",[t._v("decrease_key(h, x, k)")]),t._v(" 和 "),e("code",[t._v("delete(h, x)")]),t._v(" 均需要一个指针指向这个元素，并且指针作为输入的一部分。")]),t._v(" "),e("p",[t._v("在应用中使用一个可合并堆时，通常在可合并堆的每个元素中存储一个句柄指向相关应用对象，同样在每个应用对象中也存储一个句柄指向可合并堆中相关元素。这些句柄的确切作用依赖于具体应用及它的实现。")]),t._v(" "),e("h3",{attrs:{id:"_1-3-斐波那契堆：理论-实际"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-斐波那契堆：理论-实际"}},[t._v("#")]),t._v(" 1.3. 斐波那契堆：理论 & 实际")]),t._v(" "),e("p",[t._v("理论上看来，当 "),e("code",[t._v("extract_min")]),t._v(" 和 "),e("code",[t._v("delete")]),t._v(" 操作的数目相比于其它操作小得多的时候，斐波那契堆尤其适用。这种情形出现在许多应用中。例如，一些图问题算法（如计算最小生成树 MST 和寻找单源最短路径）可能每条边调用一次 "),e("code",[t._v("decrease_key")]),t._v("（从而降低边的权值，达到“松弛”的作用）。对于有很多边的稠密图，每次调用 "),e("code",[t._v("decrease_key")]),t._v(" 需要 $ \\Theta(1) $ 的摊还时间，相比于二项堆最坏情况的 $ \\Theta(log n) $，累积起来是很大的改进。")]),t._v(" "),e("p",[t._v("然而从实际角度来看，除了某些需要管理大量数据的应用外，对于大多数应用，斐波那契堆的 (隐藏在渐近时间界中的)"),e("strong",[t._v("常数因子")]),t._v("和"),e("strong",[t._v("编程复杂性")]),t._v("使得它比普通二项堆（或 k 项堆）并不那么适用。因此，对斐波那契堆的研究往往出于理论兴趣。如果能开发出一个简单得多的数据结构，而且它的摊还时间界与斐波那契堆相同，那么它将非常实用。")]),t._v(" "),e("h2",{attrs:{id:"_1-4-斐波那契堆结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-斐波那契堆结构"}},[t._v("#")]),t._v(" 1.4. 斐波那契堆结构")]),t._v(" "),e("p",[t._v("斐波那契堆也是基于有根树的。通常把每一元素表示成树中的一个结点，每个结点具有一个关键字 key 属性。")]),t._v(" "),e("p",[t._v("一个斐波那契堆 H 时一系列具有"),e("strong",[t._v("最小堆序")]),t._v(" (min-heap ordered) 的有根树的集合（森林 forest）。也就是说，每棵树均为一个"),e("strong",[t._v("最小堆")]),t._v(" (min-heap)，均遵循"),e("strong",[t._v("最小堆性质")]),t._v(" (min-heap property)：每个结点的关键字"),e("strong",[t._v("小于等于其子结点")]),t._v("的关键字、大于等于其父结点的关键字。示意图如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/fibonacci-heap-1.png",alt:"fibonacci-heap-1"}})]),t._v(" "),e("p",[t._v("每个结点 x 包含一个指向它父结点的指针 x.p 和一个指向它的某一个（仅一个）孩子的指针 x.child。x 所有孩子被连接成一个"),e("strong",[t._v("循环双向链表")]),t._v("，称为 x 的"),e("strong",[t._v("孩子链表")]),t._v(" (child list)。孩子链表中的每个孩子 y 均有指针 y.left 和 y.right，分别指向 y 的左兄弟和右兄弟。如果 y 是仅有的一个孩子，则 y.left = y.right = y。孩子链表中"),e("strong",[t._v("各兄弟出现的次序是任意的")]),t._v("。")]),t._v(" "),e("p",[t._v("循环双向链表应用在斐波那契堆中有两个优点：")]),t._v(" "),e("ol",[e("li",[t._v("可以在 O(1) 时间内从循环双向链表的任何位置插入一个结点或删除一个结点，因为 insert 和 delete 传入的参数是元素 x 而不是关键字 k，所以直接修改 x 相关结点的指针域即可。")]),t._v(" "),e("li",[t._v("给定两个循环双向链表，可以用 O(1) 时间把二者链接起来形成一个新的循环双向链表。这有利于 union 合并操作的高效执行。")])]),t._v(" "),e("p",[t._v("除上述指针域外，每个结点还有两个属性：")]),t._v(" "),e("ol",[e("li",[t._v("把结点 x 的孩子链表中的孩子数目存储在 x.degree 度数属性中。")]),t._v(" "),e("li",[t._v("布尔值属性 x.mark 指示结点 x 自从上一次成为另一个孩子的结点后，是否失去过孩子。")])]),t._v(" "),e("p",[t._v("新产生的结点是未被标记的，即 x.mark = False。当结点 x 成为另一个结点的孩子时，它成为未被标记的结点（因为此时 x 还没有失去孩子）。")]),t._v(" "),e("p",[t._v("斐波那契堆 H 的指针 H.min 指向 H 中具有最小关键字的树的根结点（由于是最小堆，所以这也是整个 H 中的最小关键字结点），该根结点被称为斐波那契堆的"),e("strong",[t._v("最小结点")]),t._v(" (minimum ndoe)。")]),t._v(" "),e("ul",[e("li",[t._v("如果不止一个根结点具有最小关键字，那么这些根结点中的任何一个都有可能成为最小结点。")]),t._v(" "),e("li",[t._v("如果一个斐波那契堆 H 是空的，那么 H.min 为 NIL 空指针。")])]),t._v(" "),e("p",[t._v("在斐波那契堆中，所有树的根也都用其 left 和 right 指针链接成一个循环双向链表，该双链表称为斐波那契堆的"),e("strong",[t._v("根链表")]),t._v(" (root list)。因此，指针 H.min 指向根链表中关键字最小的那个结点（或者几个极小关键字中的某一个）。根链表中的树次序可以是任意的。")]),t._v(" "),e("p",[t._v("除了 H.min 外，斐波那契堆 H 还有另一个属性：H.n 表示 H 中当前含有的结点总数目。")]),t._v(" "),e("h3",{attrs:{id:"_1-5-势函数分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-势函数分析"}},[t._v("#")]),t._v(" 1.5. 势函数分析")]),t._v(" "),e("p",[t._v("一般采用"),e("strong",[t._v("摊还分析")]),t._v(" (Amortized Analysis) 中的"),e("strong",[t._v("势能法")]),t._v(" (Potential Method) 来分析斐波那契堆操作的性能。")]),t._v(" "),e("p",[t._v("对于一个给定的斐波那契堆 H，用 t(H) 来表示 H 中根链表中树的数目，用 m(H) 来表示 H 中已被标记（x.mark == True）的结点数目。然后定义斐波那契堆 H 的"),e("strong",[t._v("势函数")]),t._v(" $ \\Phi(H) $ 如下：")]),t._v(" "),e("p",[t._v("$$ \\Phi(H) = t(H) + 2 m(H) $$")]),t._v(" "),e("p",[t._v("例如，前面示例图的斐波那契堆的势为 5 + 2 * 3 = 11。一系列斐波那契堆的势等于各个斐波那契堆势的和。假定势的一个单位可以支付常数数目的工作，该常数要足够大，能够支付斐波那契堆实用过程中 可能遇到的任何特定的常数时间工作量。")]),t._v(" "),e("p",[t._v("假定斐波那契堆应用开始时，没有建立堆，因此"),e("strong",[t._v("势的初始值为 0")]),t._v("。而且根据前述势函数，势在随后的"),e("strong",[t._v("任何时间内均不为负")]),t._v("。在势能法中，对于某一操作系列来说，总的摊还代价的上界就是其总的实际代价的上界。")]),t._v(" "),e("h3",{attrs:{id:"_1-6-最大度数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-最大度数"}},[t._v("#")]),t._v(" 1.6. 最大度数")]),t._v(" "),e("p",[t._v("在之后的分析中，对于摊还分析均假定：在一个 n 个结点的斐波那契堆中任何结点的"),e("strong",[t._v("最大度数")]),t._v("都有上界 D(n)。可以证明：如果仅仅是支持可合并堆的操作，那么 $ D(n) <= \\floor(log n) $。当支持 "),e("code",[t._v("decrease_key")]),t._v(" 和 "),e("code",[t._v("delete")]),t._v(" 操作时，也要求 D(n) = O(log n )。")]),t._v(" "),e("h2",{attrs:{id:"_2-可合并堆操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-可合并堆操作"}},[t._v("#")]),t._v(" 2. 可合并堆操作")]),t._v(" "),e("p",[t._v("核心思想：斐波那契堆上的一些可合并堆操作要尽可能长地"),e("strong",[t._v("延后执行")]),t._v("。不同的操作可以进行性能平衡。")]),t._v(" "),e("p",[t._v("例如，用将一个结点"),e("strong",[t._v("加入根链表")]),t._v("的方式来插入一个结点，这样仅需耗费常数时间。如果从空的斐波那契堆开始 插入 k 个结点，斐波那契堆将由一个正好包含 k 个结点的根链表组成。")]),t._v(" "),e("p",[t._v("如果在斐波那契堆 H 上执行一个 "),e("code",[t._v("extract_min")]),t._v(" 操作，在移除 H.min 指向的结点后，将不得不遍历根链表中剩下的 k-1 个结点来找出新的最小结点，这里便存在摊还的性能平衡问题。只要在执行 extract_min 操作中遍历整个根链表，并且把结点合并到最小堆序树中以减小根链表的规模。")]),t._v(" "),e("p",[t._v("后面可以看到，不论根链表在执行 "),e("code",[t._v("extract_min")]),t._v(" 操作之前是什么样子，执行完该操作之后，根链表中的每个结点要求有一个 与根链表中其它结点均不同的度数 degree，这使得根链表的规模最大是 D(n) + 1。")]),t._v(" "),e("h3",{attrs:{id:"_2-1-创建一个新的斐波那契堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-创建一个新的斐波那契堆"}},[t._v("#")]),t._v(" 2.1. 创建一个新的斐波那契堆")]),t._v(" "),e("p",[t._v("make_fib_heap 过程分配并返回一个斐波那契堆对象 H，其中 H.n = 0 和 H.min = NIL，H 中不存在树。因为 t(H) = 0 和 m(H) = 0，空斐波那契堆的势为 $ \\Phi(H) = 0 $。因此 make_fib_heap 的摊还代价等于它的实际代价 O(1)。")]),t._v(" "),e("h2",{attrs:{id:"算法流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法流程"}},[t._v("#")]),t._v(" 算法流程")]),t._v(" "),e("p",[t._v("以如下键值对列表 (以插入的方式) 构建第一个斐波那契堆 "),e("code",[t._v("fib_heap")])]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 键值对列表")]),t._v("\nkv_list "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("301")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("400")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("800")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("700")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("900")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("300")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("600")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1200")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1100")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("p",[t._v("以如下键值对列表 (以插入的方式) 构建第二个斐波那契堆 "),e("code",[t._v("fib_heap_2")])]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[t._v("kv_list_2 "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1600")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("17")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1700")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("18")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1800")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),e("p",[t._v("一开始，这两个堆的所有结点都是根结点，都在根链表里。")]),t._v(" "),e("p",[t._v("首先对 "),e("code",[t._v("fib_heap")]),t._v(" 进行抽取最小结点的测试，示意图如下：")]),t._v(" "),e("ul",[e("li",[t._v("注：\n"),e("ul",[e("li",[t._v("从第一次 "),e("code",[t._v("extract_min")]),t._v(" 结束后的斐波那契堆开始作图。")]),t._v(" "),e("li",[t._v("H.min 指针指向堆的最小根。")]),t._v(" "),e("li",[t._v("根链表是循环双向链表，简略成横向的无向边连接。")]),t._v(" "),e("li",[t._v("从某个父结点到其子结点：\n"),e("ul",[e("li",[t._v("向下的有向箭头表示此结点的 child 结点，至多有一个 child 结点；")]),t._v(" "),e("li",[t._v("父子结点间无向的边连接 实则只有孩子结点的 parent 指针往上指。")]),t._v(" "),e("li",[t._v("孩子链表的 left、right 指针均在图中省略。")])])])])])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/fibonacci-heap-2.png",alt:"fibonacci-heap-2"}})]),t._v(" "),e("p",[t._v("抽取到一定程度（此时 key=7 为最小根结点）后，把两个堆合并起来，然后执行 "),e("code",[t._v("decrease_key")]),t._v(" 和 "),e("code",[t._v("delete")]),t._v(" 操作，示意图如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/fibonacci-heap-3.png",alt:"fibonacci-heap-3"}})]),t._v(" "),e("h2",{attrs:{id:"代码范例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),e("h3",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),e("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/fibonacci-heap.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 19")])])])}),[],!1,null,null,null);a.default=s.exports}}]);