(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{304:function(t,a,r){"use strict";r.r(a);var i=r(28),e=Object(i.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"algorithm-string-suffix"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-string-suffix"}},[t._v("#")]),t._v(" Algorithm - String - Suffix")]),t._v(" "),r("p",[t._v("By "),r("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"_1-后缀树-suffix-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-后缀树-suffix-tree"}},[t._v("#")]),t._v(" 1. 后缀树 Suffix Tree")]),t._v(" "),r("p",[t._v("通常来说，后缀树的建立只需要单个单词(字符串)，这与"),r("a",{attrs:{href:"./string-trie"}},[t._v("字典树")]),t._v("的输入为单词列表 有所区别。")]),t._v(" "),r("p",[t._v("后缀树建立时，先将输入的单词(字符串)拆分为各个长度的后缀，然后将每个后缀作为单独的串、构建压缩的 Trie 字典树。")]),t._v(" "),r("ul",[r("li",[t._v("相关资料链接\n"),r("ul",[r("li",[t._v("https://www.cnblogs.com/gaochundong/p/string_matching.html")]),t._v(" "),r("li",[t._v("https://www.cnblogs.com/gaochundong/p/suffix_tree.html")]),t._v(" "),r("li",[t._v("https://wenku.baidu.com/view/afe0ff7302d8ce2f0066f5335a8102d276a2618b.html")])])])]),t._v(" "),r("h3",{attrs:{id:"_1-1-后缀树的应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-后缀树的应用"}},[t._v("#")]),t._v(" 1.1. 后缀树的应用")]),t._v(" "),r("ol",[r("li",[t._v("判断字符串 s1 是否为另外一个字符串 s2 的子串：如果 s1 在字符串 s2 中，那么 s1 必定是 s2 中某个后缀串的前缀。")]),t._v(" "),r("li",[t._v("计算字符串 s1 在字符串 s2 中重复出现的次数：只需计算 s1 是 (以 s2 构建的)后缀树 的多少个后缀串的前缀。")]),t._v(" "),r("li",[t._v("计算最长重复子串：找到深度最深(子字符串最长)的非叶结点。")]),t._v(" "),r("li",[t._v("计算最长公共前缀")]),t._v(" "),r("li",[t._v("获得多个字符串的最长公共子串：使用多个字符结束符，每个字符串各一个，然后分别拆分各个字符串构建(压缩的)广义后缀树 (Generalized Suffix Tree)。找到深度最深(子字符串最长)的非叶结点 v，且以结点 v 为根的子树含有全部终结符。（如果是显式构造终结字符叶结点，则一个叶结点不会同时拥有多个终结字符）。")]),t._v(" "),r("li",[t._v("获得某个字符串 s 的最长回文子串：等价于寻找 s 与 reverse(s) 的最长公共子串。")])]),t._v(" "),r("h3",{attrs:{id:"_1-2-后缀树设计"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-后缀树设计"}},[t._v("#")]),t._v(" 1.2. 后缀树设计")]),t._v(" "),r("p",[t._v("以单词 banana 为例建立后缀树，先在 banana 末尾追加文本结束符号，这里用 @ 表示。于是它有如下后缀：")]),t._v(" "),r("ul",[r("li",[t._v("banana@")]),t._v(" "),r("li",[t._v("anana@")]),t._v(" "),r("li",[t._v("nana@")]),t._v(" "),r("li",[t._v("ana@")]),t._v(" "),r("li",[t._v("na@")]),t._v(" "),r("li",[t._v("a@")]),t._v(" "),r("li",[t._v("@")])]),t._v(" "),r("p",[t._v("用这 7 个后缀串构建普通的字典树 Tire 如下（字符存储于边）：")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/trie-1.png",alt:"trie-1"}})]),t._v(" "),r("p",[t._v("其对应的压缩字典树如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/trie-2.png",alt:"trie-2"}})]),t._v(" "),r("p",[t._v("如果用下标 i 表示从 banana 的第 i 下标字符出发到文本结束符号 的后缀串，则可以进一步压缩如下：")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/trie-3.png",alt:"trie-3"}})]),t._v(" "),r("ul",[r("li",[t._v("后缀树的线性构造算法\n"),r("ul",[r("li",[t._v("Ukkonen 算法 (又称为 Ukk 算法)\n"),r("ul",[r("li",[t._v("在 1995 年，Esko Ukkonen 发表了论文《On-line construction of suffix trees》，描述了在 "),r("strong",[t._v("线性时间")]),t._v(" $ \\Theta(n) $ 内构建后缀树的方法。")]),t._v(" "),r("li",[t._v("https://www.cnblogs.com/gaochundong/p/suffix_tree.html")]),t._v(" "),r("li",[t._v("https://blog.csdn.net/ljsspace/article/details/6596509")])])]),t._v(" "),r("li",[t._v("McCreight 算法 (又称为 Mcc 算法)\n"),r("ul",[r("li",[t._v("https://blog.csdn.net/ljsspace/article/details/6581850")])])])])])]),t._v(" "),r("p",[t._v("Suffix Tree 与 Trie 的不同在于，边（Edge）不再只代表单个字符，而是通过一对整数 [from, to] 来表示。其中 from 和 to 所指向的是 Text 中的位置，这样每个边可以表示任意的长度，而且仅需两个指针，耗费 O(1) 的空间。")]),t._v(" "),r("p",[t._v("如果是广义后缀树，有一个用于构建广义后缀树的串列表，那么每条边可以用三元组 [index, from, to] 来表示，其中 index 是串在串列表中的下标，这样通过这个三元组就可以得到子串值。")]),t._v(" "),r("h2",{attrs:{id:"_2-后缀数组-suffix-array"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-后缀数组-suffix-array"}},[t._v("#")]),t._v(" 2. 后缀数组 Suffix Array")]),t._v(" "),r("ul",[r("li",[t._v("https://www.cnblogs.com/wyboooo/p/9854468.html")])]),t._v(" "),r("p",[t._v("在字符串处理当中，后缀树和后缀数组都是非常有力的工具。其实后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也不太逊色，并且，它比后缀树所占用的空间小很多。")]),t._v(" "),r("ul",[r("li",[t._v("构造后缀数组\n"),r("ul",[r("li",[t._v("暴力构建后缀数组的方法复杂度是O(n^2 log n)")]),t._v(" "),r("li",[t._v("倍增算法（Doubling Algorithm）快速构造后缀数组，其利用了后缀子串之间的联系可将时间复杂度降至O(m log n)，其中 m 为模式串的长度，n 为目标串的长度；另外基数排序算法的时间复杂度为O(N)；")]),t._v(" "),r("li",[t._v("Difference Cover mod 3 (DC3) 算法 (Linear Work Suffix Array Construction) 可在 O(3n)时间内构建后缀数组；")]),t._v(" "),r("li",[t._v("Ukkonen 算法 (Online Construction of Suffix-Trees) 可在 O(n) 的时间内构建一棵后缀树，然后再用 O(n) 的时间内将后缀树转换为后缀数组，这是理论上最快的后缀数组构造法。")])])])]),t._v(" "),r("h2",{attrs:{id:"_3-后缀自动机-sam"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-后缀自动机-sam"}},[t._v("#")]),t._v(" 3. 后缀自动机 SAM")]),t._v(" "),r("h2",{attrs:{id:"代码范例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),r("h3",{attrs:{id:"python"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),r("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),r("h3",{attrs:{id:"suffix"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#suffix"}},[t._v("#")]),t._v(" Suffix")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/string-suffix.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")])])}),[],!1,null,null,null);a.default=e.exports}}]);