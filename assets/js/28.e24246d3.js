(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{298:function(t,e,a){"use strict";a.r(e);var r=a(28),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"algorithm-data-structure-van-emde-boas-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-van-emde-boas-tree"}},[t._v("#")]),t._v(" Algorithm - Data Structure - van Emde Boas Tree")]),t._v(" "),a("p",[t._v("Create Date: 2020.05.19")]),t._v(" "),a("p",[t._v("Last Update Date: 2020.05.19")]),t._v(" "),a("p",[t._v("By "),a("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[t._v("van Emde Boas Tree (此后简称 vEB)")]),t._v(" "),a("p",[t._v("使用了 Divide and Conquer 分治法思想")]),t._v(" "),a("h2",{attrs:{id:"veb-分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#veb-分析"}},[t._v("#")]),t._v(" vEB 分析")]),t._v(" "),a("p",[t._v("关键字 key 取自全域 U = {0, 1, ..., u-1} 这样一个整数集合，且 vEB 树中的 key 不重复。")]),t._v(" "),a("p",[t._v("这里假定 u 是 2 的正整数幂次，比如 2^64 或 2^32。如果 u = 2^64，则 log_{2} log_{2} u = 6，这相比于数据量 n 而言（n 最多可以达到 u 个）可以视作常数级别。")]),t._v(" "),a("p",[t._v("进一步而言，如果 u = n^{O(1)} 或者 u = n^{(log n)^O(1)}，则 log log u = O(log log n)。这也说明了该渐进时间复杂度是很好的。")]),t._v(" "),a("p",[t._v("目标是以 O(log log u) 的时间完成如下操作：")]),t._v(" "),a("ul",[a("li",[t._v("插入 insert(key, val)")]),t._v(" "),a("li",[t._v("删除 delete(key)")]),t._v(" "),a("li",[t._v("后继 successor(key) / 前驱 predecessor(key)")])]),t._v(" "),a("h3",{attrs:{id:"如何得到-o-log-log-u"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何得到-o-log-log-u"}},[t._v("#")]),t._v(" 如何得到 O(log log u) ?")]),t._v(" "),a("p",[t._v("直觉 1：O(log n) 往往是指二叉搜索树的树高，如果能够对此树高进行二分查找，则可以达到 O(log log n)。")]),t._v(" "),a("p",[t._v("直觉 2：根据时间复杂度分析的主方法，式子 T(k) = T(k/2) + O(1)，意味着将数据规模为 k 的过程拆解为规模为 k/2 的过程 加上一个时间复杂度为 O(1) 的过程。这个式子可以推出 T(k) = O(log k)。那么将 k 替换为 log u，则 T(log u) = T((log u)/2) + O(1) 可以推出 T(log u) = O(log log u)。")]),t._v(" "),a("p",[t._v("但是 T(log u) 不够直观。由主方法可知，式子 "),a("code",[t._v("T(k) = T(\\sqrt(u)) + O(1)")]),t._v(" 就可以推出 T(k) = O(log log k)。此式子意味着要有一种算法，能够把数据规模为 k 的过程拆解为规模为 "),a("code",[t._v("\\sqrt(k)")]),t._v(" 的过程 加上一个时间复杂度为 O(1) 的过程。这就正是 vEB 数据结构的设计目标。")]),t._v(" "),a("h3",{attrs:{id:"bit-vector-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bit-vector-tree"}},[t._v("#")]),t._v(" bit vector + Tree")]),t._v(" "),a("p",[t._v("如果使用一个长度为 u 的 bit vector 位向量来记录某个 key 是否在 vEB 中（0-absence, 1-present）。那么插入和删除仅需 O(1) 时间便可完成：插入即为某位置 1、删除即为某位清 0。但是查找前驱或后继的操作需要 O(u) 的时间才能完成。")]),t._v(" "),a("p",[t._v("考虑直接在此长度为 u 的 bit vector 位向量上建立二叉树，则树高为 O(log u)，不是目标的 O(log log u)。下文先对此情况进行分析，然后再改进此方案。")]),t._v(" "),a("p",[t._v("先将此长度为 u 的位向量按固定长度 l 进行 clustering 分组，再在各个分组上建二叉树。比如 u = 2^4 = 16，而 "),a("code",[t._v("l = \\sqrt(u) = 4")]),t._v("，则会将位向量分为长度为 4 的 4 组。随后在各个分组内建立二叉树，叶结点为分组内的 0 或者 1。从下往上，使用 逻辑或 运算得到父结点的值。树的高度为 "),a("code",[t._v("log_{2} l = log_{2} \\sqrt(u) = 2")])]),t._v(" "),a("p",[t._v("例如，位向量为 "),a("code",[t._v("[0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1]")])]),t._v(" "),a("p",[t._v("则高度为 1（叶结点高度为 0）的结点为 "),a("code",[t._v("[1, 0, 0, 0, 1, 1, 0, 1]")])]),t._v(" "),a("p",[t._v("高度为 2 的结点为 "),a("code",[t._v("[1, 0, 1, 1]")])]),t._v(" "),a("p",[t._v("若某个非叶结点的值为 1，就表明以此内部结点为根的子树的叶结点存在 1；否则表明不存在 1、全为 0。起到了总结的作用，因此将高度为 log_{2} l = 2 的这层结点 "),a("code",[t._v("[1, 0, 1, 1]")]),t._v(" 称为 summary vector。")]),t._v(" "),a("p",[t._v("当从位向量的某个位置查找其前驱/后继时，先查看此位向量所在的结点的 bit vector 如果没找到，则往上查找，查看相邻结点的 summary vector，若为 1，则在相邻结点往下找，否则往上找。（下图为《CLRS》中的示意图，前述位向量为 MIT 6.046J 的例子。）")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/vEB-1.png",alt:"vEB-1"}})]),t._v(" "),a("p",[t._v("从上可知，由于是二叉树是每两个结点进行“合并”，所以树高只能是 O(log_{2} u)，但如果是 "),a("code",[t._v("\\sqrt(u)")]),t._v(" 个合并，即上例中的 4 个一组共同做逻辑或运算得到 1 个结果，则可以大幅缩减树高。")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/vEB-2.png",alt:"vEB-2"}})]),t._v(" "),a("p",[t._v("这样改进后，每个树结点只需存储自己的分组的 bit vector 和相应的 summary vector。搜索前驱/后继只需要对两个长度为 "),a("code",[t._v("\\sqrt(u)")]),t._v(" 位的 bit vector 以及一个长度也为 "),a("code",[t._v("\\sqrt(u)")]),t._v(" 的 summary vector 数组进行搜索，所以每个操作耗费 "),a("code",[t._v("O(\\sqrt(u))")]),t._v(" 时间。")]),t._v(" "),a("p",[t._v("此时仍未达到 O(log log u) 的目标。不过使用结点"),a("strong",[t._v("度")]),t._v("为 "),a("code",[t._v("\\sqrt(u)")]),t._v(" 的树是产生 vEB 树的"),a("strong",[t._v("关键思想")]),t._v("。回顾前面关于时间复杂度的主方法分析，此改进方案正是做到了式子 "),a("code",[t._v("T(k) = T(\\sqrt(k)) + O(1)")]),t._v("！一次的规模缩小无法获得最优性能，那么多次缩小、让式子递归下去就可以了，最终能达到 T(k) = O(log log k)！")]),t._v(" "),a("p",[t._v("递归是针对于每个 "),a("code",[t._v("T(\\sqrt(k))")]),t._v(" 的："),a("code",[t._v("T(\\sqrt(k)) = T(\\sqrt(\\sqrt(k))) + O(1)")]),t._v("，即 每个分组(对应一个结点)也要被继续以根号长度被拆分，不断递归直到基本情况。")]),t._v(" "),a("p",[t._v("另外，在此改进版本中，插入操作仍然只需要 O(1) 时间，因为只需要将相应的位置以及 summary 改为 1。但删除操作稍微 tricky 些，因为 bit vector 是通过逻辑或运算得到的 summary，所以某一位改为 0 不一定表示 summary 要改为 0。（只有在此分组的 bit vector 全零时 summary 才会是 0）")]),t._v(" "),a("p",[t._v("确定 key=x 的簇号 i 和簇内偏移 j（以 "),a("code",[t._v("\\sqrt(u)")]),t._v(" 为簇长度）：由 "),a("code",[t._v("x = i * \\sqrt(u) + j")]),t._v(" 知， "),a("code",[t._v("i = int(x / \\sqrt(u))")]),t._v(" 和 "),a("code",[t._v("j = x % \\sqrt(u)")])]),t._v(" "),a("h3",{attrs:{id:"递归结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归结构"}},[t._v("#")]),t._v(" 递归结构")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/info_technology/algorithm/data_structure/vEB-3.png",alt:"vEB-3"}})]),t._v(" "),a("h2",{attrs:{id:"veb-应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#veb-应用"}},[t._v("#")]),t._v(" vEB 应用")]),t._v(" "),a("p",[a("strong",[t._v("网络路由器")]),t._v(" Network Router 常使用 vEB 数据结构来存储 Routing Table "),a("strong",[t._v("路由表")]),t._v("。路由表记录了各个区间(网段)的 IP 地址应该被转发往哪个路由器端口。用 vEB 中的整数 key 来表达各 IP 地址区间的边界，key 对应结点的 val 值对象 表达此 IP 区间的各种处理方式。")]),t._v(" "),a("p",[t._v("则 Query 就是：给定一个确切的 IP 地址，希望找到它属于哪个区间，从而执行相应的操作。")]),t._v(" "),a("p",[t._v("转换到 vEB 的任务，就是将新 Query 里的 IP 地址转成整数 key，迅速（O(log log u) 时间）找出此 key 的前驱/后继，便能确定该 IP 所在的区间，以及应该执行的路由操作（根据结点内的 val 值对象）。")]),t._v(" "),a("p",[t._v("虽然"),a("strong",[t._v("区间查询任务")]),t._v("也可以考虑 "),a("a",{attrs:{href:"./segment-tree"}},[t._v("线段树")]),t._v(" (Segment Tree, ST)、"),a("a",{attrs:{href:"./binary-indexed-tree"}},[t._v("树状数组")]),t._v(" Fenwick Tree (Binary Indexed Tree, BIT)、"),a("a",{attrs:{href:"./range-min-max-query"}},[t._v("区间最值查询")]),t._v(" Sparse Table (Range Minimum/Maximum Query, RMQ) 等数据结构，但针对路由这个任务，IP 地址数量庞大、网段数目也可能特别多（IPv4 有 2^32 个 IP 地址、IPv6 有 2^128 个 IP 地址），并且需要转发速度很快，因此线段树和树状数组的 O(log n) 时间复杂度可能还是偏慢了。至于 Sparse Table RMQ，虽然查询的时间复杂度是 O(1)，但是一旦路由表项变化、增减就需要重建，这远达不到路由表的动态需求。")]),t._v(" "),a("h2",{attrs:{id:"设计-细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[t._v("#")]),t._v(" 设计 & 细节")]),t._v(" "),a("p",[t._v("以计算区间最小值为例，展开下文叙述。")]),t._v(" "),a("h3",{attrs:{id:"建立-veb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#建立-veb"}},[t._v("#")]),t._v(" 建立 vEB")]),t._v(" "),a("p",[t._v("以 array 中的每个元素为 key，调用 insert(key) 插入，逐步建立 BST。时间复杂度 O(n log n)")]),t._v(" "),a("p",[t._v("以 "),a("code",[t._v("array = [15, 10, 20, 8, 12, 17, 25]")]),t._v(" 为例，建立 BST 如下：")]),t._v(" "),a("p",[t._v("图中结点内部的值即为 key，左侧的数字即为中序遍历（升序排列）数组的下标。")]),t._v(" "),a("p",[t._v("以 kv_array 中的每个元素为 [key, value] 数组，构建树结点。树结点设计如下：")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 键，按键构造 BST 树，并进行搜索/增添/删除")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 值，树结点存储的值，可以为任意对象")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 左孩子")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 右孩子")]),t._v("\n        self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 父结点。便于删除、以及其它逐层向上的调整操作")]),t._v("\n")])])]),a("h3",{attrs:{id:"搜索-search-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搜索-search-key"}},[t._v("#")]),t._v(" 搜索 search(key)")]),t._v(" "),a("h3",{attrs:{id:"插入-insert-key-val"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入-insert-key-val"}},[t._v("#")]),t._v(" 插入 insert(key, val)")]),t._v(" "),a("h3",{attrs:{id:"删除-delete-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除-delete-key"}},[t._v("#")]),t._v(" 删除 delete(key)")]),t._v(" "),a("h3",{attrs:{id:"实现细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现细节"}},[t._v("#")]),t._v(" 实现细节")]),t._v(" "),a("h2",{attrs:{id:"代码范例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),a("h3",{attrs:{id:"python"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),a("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),a("div",{staticClass:"language-python extra-class"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[t._v("\n")])])]),a("h2",{attrs:{id:"参考资料"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),a("ul",[a("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 20 van Emde Boas Tree")]),t._v(" "),a("li",[t._v("MIT 6.046J Design and Analysis of Algorithms, Spring 2015\n"),a("ul",[a("li",[a("a",{attrs:{href:"https://www.youtube.com/watch?v=hmReJCupbNU",target:"_blank",rel:"noopener noreferrer"}},[t._v("4. Divide & Conquer: van Emde Boas Trees"),a("OutboundLink")],1)])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);