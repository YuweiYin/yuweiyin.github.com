(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{507:function(t,a,e){"use strict";e.r(a);var r=e(28),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"algorithm-data-structure-adelson-velsky-landis-tree"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-data-structure-adelson-velsky-landis-tree"}},[t._v("#")]),t._v(" Algorithm - Data Structure - Adelson-Velsky-Landis Tree")]),t._v(" "),e("p",[t._v("By "),e("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),e("p",[t._v("AVL 树 (Adelson-Velsky-Landis Tree)，是最早发明的自平衡二叉查找树 (Self-Balanced Binary Search Tree)，它于 1962 年被发表于论文《An algorithm for the organization of information》。此数据结构名称为其三位发明者的名字缩写。")]),t._v(" "),e("p",[e("a",{attrs:{href:"./binary-search-tree"}},[t._v("二叉搜索树")]),t._v(" (Binary Sort/Search Tree, BST) 在处理 search、insert 和 delete 操作时，遍历的路径长度至多为树高，因此如果树的"),e("strong",[t._v("平衡性")]),t._v("得到保证，则树高为 O(log n)，从而使得这三种操作的时间复杂度均为 O(log n)。")]),t._v(" "),e("p",[t._v("最坏情况是 BST 树极度不平衡，退化成了一条链。在这种情况下，前述三个操作的时间复杂度为 O(n)。")]),t._v(" "),e("p",[t._v("但原始的 BST 本身不具备保证平衡性的操作，树是否平衡完全看增删结点的顺序，AVL 树即为 BST 的改进，"),e("strong",[t._v("保证了树的平衡性")]),t._v("，从而保证不会出现 BST 的最坏情况。")]),t._v(" "),e("ul",[e("li",[t._v("AVL 保证树平衡性的核心思想如下：\n"),e("ul",[e("li",[t._v("维持每个结点的左右子树高度差距不超过 1。（因此每个树结点需要维护自己的"),e("strong",[t._v("树高属性")]),t._v("）")]),t._v(" "),e("li",[t._v("在增删树结点、改动树结构时，检测"),e("strong",[t._v("平衡因子")]),t._v("。如果破坏了树平衡性，那就“纵向”调整树结构，直至平衡。")]),t._v(" "),e("li",[t._v("这种“纵向”调整具体的实现是“"),e("strong",[t._v("左旋")]),t._v("”和“"),e("strong",[t._v("右旋")]),t._v("”操作，")]),t._v(" "),e("li",[t._v("前述的调整路径长度至多为"),e("strong",[t._v("树高")]),t._v("，所以增删结点操作的整体时间复杂度仍为 O(log n)，仅仅是增加了一些常数因子。")])])])]),t._v(" "),e("h3",{attrs:{id:"avl-树的应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#avl-树的应用"}},[t._v("#")]),t._v(" AVL 树的应用")]),t._v(" "),e("p",[t._v("AVL 树由其稳定高效，被广泛使用。")]),t._v(" "),e("p",[t._v("它可以用于实现优先队列 Priority Queue。（另外，堆 Heap 也可以实现优先队列。）")]),t._v(" "),e("p",[t._v("Solaris 操作系统会使用 AVL 树结构来管理页表中已访问过的页面，即缓存机制，以便迅速地再次访问（搜索/查找）。另外，其它操作系统，如 Linux 和 Windows，也都使用类似 AVL 的数据结构完成此功能。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/avl-solaris-segment-data-structure.png",alt:"avl-solaris-segment-data-structure"}})]),t._v(" "),e("h2",{attrs:{id:"设计-细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[t._v("#")]),t._v(" 设计 & 细节")]),t._v(" "),e("h3",{attrs:{id:"建立-avl-树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#建立-avl-树"}},[t._v("#")]),t._v(" 建立 AVL 树")]),t._v(" "),e("p",[t._v("以 kv_array 中的每个元素为 [key, value] 数组，构建树结点。树结点设计如下：")]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TreeNode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("key "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" key       "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 键，按键构造 BST/AVL 树，并进行搜索/增添/删除")]),t._v("\n        self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("val "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val       "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 值，树结点存储的值，可以为任意对象")]),t._v("\n        self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("height "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 初始时树高为 1")]),t._v("\n        self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("left "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("     "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 左孩子指针")]),t._v("\n        self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("right "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 右孩子指针")]),t._v("\n        self"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("parent "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 父结点指针")]),t._v("\n")])])]),e("p",[t._v("AVL 树的建立就是循环调用 insert(key) 插入，逐步建立 AVL 树。时间复杂度 O(n log n)")]),t._v(" "),e("h3",{attrs:{id:"搜索-search-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#搜索-search-key"}},[t._v("#")]),t._v(" 搜索 search(key)")]),t._v(" "),e("ul",[e("li",[t._v("search 操作与 BST 的 search 没有区别：\n"),e("ul",[e("li",[t._v("如果当前结点为空，则返回 None，表示查询不到目标结点")]),t._v(" "),e("li",[t._v("如果当前结点的 key 值等于目标 key 值，则查询到，返回结点")]),t._v(" "),e("li",[t._v("如果当前结点的 key 值小于目标 key 值，则进入左子树，递归搜索")]),t._v(" "),e("li",[t._v("如果当前结点的 key 值大于目标 key 值，则进入右子树，递归搜索")])])]),t._v(" "),e("li",[e("strong",[t._v("查询不会影响树结构")]),t._v("，所以不会调用关于树平衡性的辅助操作。")])]),t._v(" "),e("h3",{attrs:{id:"辅助操作：平衡性检测-balanced-factor-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：平衡性检测-balanced-factor-node"}},[t._v("#")]),t._v(" 辅助操作：平衡性检测 balanced_factor(node)")]),t._v(" "),e("p",[t._v("判断 node 结点是否平衡，即计算其左右子树的平衡因子 (Balanced Factor) 差距。")]),t._v(" "),e("p",[t._v("如果差距不大于 1，则平衡，否则不平衡，需要通过旋转操作来调整至平衡。")]),t._v(" "),e("p",[t._v("这里返回 node 左子树高度减去 node 右子树高度的值，作为 node 的平衡因子。")]),t._v(" "),e("h3",{attrs:{id:"辅助操作：左旋-left-rotate-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：左旋-left-rotate-node"}},[t._v("#")]),t._v(" 辅助操作：左旋 "),e("code",[t._v("left_rotate(node)")])]),t._v(" "),e("ul",[e("li",[t._v("对 node 结点 x 而言，将 x 左旋，意味着：\n"),e("ul",[e("li",[t._v("让 x 的右孩子 y (x.right) 成为 x 的父结点，且 x 等于 y.left。")]),t._v(" "),e("li",[t._v("而 y 结点原本的左孩子变为新 x 的右孩子")]),t._v(" "),e("li",[t._v("注意维护三个指针，以及 height 属性")])])])]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/tree-rotate-1.png",alt:"tree-rotate-1"}})]),t._v(" "),e("h3",{attrs:{id:"辅助操作：右旋-right-rotate-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：右旋-right-rotate-node"}},[t._v("#")]),t._v(" 辅助操作：右旋 right_rotate(node)")]),t._v(" "),e("ul",[e("li",[t._v("对 node 结点 x 而言，将 x 右旋，意味着：\n"),e("ul",[e("li",[t._v("让 x 的左孩子 y (x.left) 成为 x 的父结点，且 x 等于 y.right。")]),t._v(" "),e("li",[t._v("而 y 结点原本的右孩子变为新 x 的左孩子")]),t._v(" "),e("li",[t._v("注意维护三个指针，以及 height 属性")])])])]),t._v(" "),e("h3",{attrs:{id:"辅助操作：平衡性维护-maintain-balance-node"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#辅助操作：平衡性维护-maintain-balance-node"}},[t._v("#")]),t._v(" 辅助操作：平衡性维护 maintain_balance(node)")]),t._v(" "),e("ul",[e("li",[t._v("从 node 结点开始，逐级向上进行 height 修改，以及平衡性调整")]),t._v(" "),e("li",[t._v('两种情况下会调用：1. 插入结点后；2."确实地"删除结点后。')]),t._v(" "),e("li",[t._v("时间复杂度 O(log n) 与树高有关")]),t._v(" "),e("li",[e("strong",[t._v("逐层向上调整")]),t._v("，根据平衡因子 分四种情况，用旋转操作来调整平衡")])]),t._v(" "),e("p",[t._v("不平衡出现时，有如下四种情况：")]),t._v(" "),e("ul",[e("li",[t._v("case 1："),e("strong",[t._v("LL 左左结构")]),t._v(" - node 的平衡因子 bf=2 且其左孩子的平衡因子 bf=1\n"),e("ul",[e("li",[t._v("把 node 右旋一次即可")])])]),t._v(" "),e("li",[t._v("case 2："),e("strong",[t._v("LR 左右结构")]),t._v(" - node 的平衡因子 bf=2 且其左孩子的平衡因子 bf=-1\n"),e("ul",[e("li",[t._v("先把 node 的左孩子左旋一次，整体成为左左结构，再把 node 右旋一次即可")])])]),t._v(" "),e("li",[t._v("case 3："),e("strong",[t._v("RL 右左结构")]),t._v(" - node 的平衡因子 bf=-2 且其左孩子的平衡因子 bf=1\n"),e("ul",[e("li",[t._v("先把 node 的右孩子右旋一次，整体成为右右结构，再把 node 左旋一次即可")])])]),t._v(" "),e("li",[t._v("case 4："),e("strong",[t._v("RR 右右结构")]),t._v(" - node 的平衡因子 bf=-2 且其左孩子的平衡因子 bf=-1\n"),e("ul",[e("li",[t._v("把 node 左旋一次即可")])])])]),t._v(" "),e("p",[t._v("注意：如果旋转时影响了整个的 BST/AVL 树根，则需要更换树根")]),t._v(" "),e("p",[t._v("另外，还要维护每个结点的 height 属性。")]),t._v(" "),e("h3",{attrs:{id:"插入-insert-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插入-insert-key"}},[t._v("#")]),t._v(" 插入 insert(key)")]),t._v(" "),e("p",[t._v("以 "),e("code",[t._v("kv_array = [[1, 100], [2, 200], [3, 300], [7, 700], [8, 800], [9, 900], [4, 400]]")]),t._v(" 为例，对于 kv_array 中的每个列表元素，其中的首元素为 key，次元素为 value。key 必须要是具备全序关系，而 value 可以为任何对象。")]),t._v(" "),e("p",[e("strong",[t._v("以插入方式逐步建立 AVL")]),t._v("，如下图所示：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/avl-1.png",alt:"avl-1"}})]),t._v(" "),e("p",[t._v("插入新结点后，要调用 "),e("code",[t._v("maintain_balance")]),t._v(" 辅助操作，逐步向上根据平衡性来调整树结构。")]),t._v(" "),e("h3",{attrs:{id:"删除-delete-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除-delete-key"}},[t._v("#")]),t._v(" 删除 delete(key)")]),t._v(" "),e("p",[t._v("AVL 树的删除 delete 操作与普通 BST 的删除操作类似，但是有区别：")]),t._v(" "),e("ul",[e("li",[t._v("在删除一个既有左孩子又有右孩子的中间结点时，需要考虑当前结点的平衡因子\n"),e("ul",[e("li",[t._v("由于删除前的 AVL 树中，所有结点都是满足平衡性的，因此每个结点的平衡因子只可能是 0 或 1 或 -1。")]),t._v(" "),e("li",[t._v("如果平衡因子为 0 或 -1，表示右孩子比左孩子更高，则与普通 BST 做法相同：\n"),e("ul",[e("li",[t._v("先找出右孩子中的最小元素（右子树中一路向左），替换当前结点的值")]),t._v(" "),e("li",[t._v("然后递归地在右子树中删除该结点")])])]),t._v(" "),e("li",[t._v("如果平衡因子为 1，表示左孩子比右孩子更高，则从左子树中删除元素：\n"),e("ul",[e("li",[t._v("先找出左孩子中的最大元素（左子树中一路向右），替换当前结点的值")]),t._v(" "),e("li",[t._v("然后递归地在左子树中删除该结点")])])])])]),t._v(" "),e("li",[t._v("在“确实地”删除了结点后，调用 maintain_balance 辅助操作，检查被删除结点的"),e("strong",[t._v("所有祖先结点")]),t._v("的平衡性。\n"),e("ul",[e("li",[t._v("前述替换并不会影响当前结点的平衡性，故不用逐步往上检查平衡性。")]),t._v(" "),e("li",[t._v("每次 delete 操作时，至多有一个被“确实”删除的结点。")]),t._v(" "),e("li",[t._v("所谓的“确实地”删除有三种情况：\n"),e("ul",[e("li",[t._v("当前结点仅有左孩子")]),t._v(" "),e("li",[t._v("当前结点仅有右孩子")]),t._v(" "),e("li",[t._v("当前结点没有孩子（为叶结点）")])])])])])]),t._v(" "),e("p",[t._v("例如：在前述已经建立好的 AVL 树中，删除 key=9 的结点：")]),t._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/data-structure/avl-2.png",alt:"avl-2"}})]),t._v(" "),e("p",[t._v("其它 BST 中的基本操作，如找 最大值、最小值、前驱、后继、判断一棵树是否为 BST 等，都不在此赘述。")]),t._v(" "),e("h2",{attrs:{id:"avl-树高分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#avl-树高分析"}},[t._v("#")]),t._v(" AVL 树高分析")]),t._v(" "),e("p",[t._v("以 "),e("code",[t._v("N_{h}")]),t._v(" 表示高度为 h 的子树里的元素个数。")]),t._v(" "),e("p",[t._v("边界情况：当 h 为常数量级 O(1) 时："),e("code",[t._v("N_{O(1)} = O(1)")])]),t._v(" "),e("p",[t._v("考虑高度为 h 的树的 root 结点及其左右子树，可拆分为："),e("code",[t._v("N_{h} = 1 + N_{h-1} + N_{h-2}")])]),t._v(" "),e("p",[t._v("上式的计算方式与 Fibonacci 数的计算类似，有 "),e("code",[t._v("N_{h} > F_{h} = \\Phi^{h} / \\sqrt{5}")]),t._v("，其中 "),e("code",[t._v("\\Phi")]),t._v(" 为黄金比例，约为 1.618。")]),t._v(" "),e("p",[t._v("于是有 h 约等于 "),e("code",[t._v("1.440 log_{\\Phi} n")]),t._v("，故 AVL 树高的量级保证为 O(log n)。")]),t._v(" "),e("h2",{attrs:{id:"代码范例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),e("h3",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),e("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/data-structure/avl-tree.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[t._v("MIT 6.006 Introduction to Algorithms, Fall 2011\n"),e("ul",[e("li",[e("a",{attrs:{href:"https://www.youtube.com/watch?v=FNeL18KsWPc",target:"_blank",rel:"noopener noreferrer"}},[t._v("Erik Demaine - AVL Trees, AVL Sort"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.youtube.com/watch?v=IWzYoXKaRIc",target:"_blank",rel:"noopener noreferrer"}},[t._v("Victor Costan - R6. AVL Trees"),e("OutboundLink")],1)])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);