(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{474:function(t,a,i){"use strict";i.r(a);var n=i(28),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,i=t._self._c||a;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"algorithm-string-matching"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-string-matching"}},[t._v("#")]),t._v(" Algorithm - String Matching")]),t._v(" "),i("p",[t._v("By "),i("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),i("OutboundLink")],1)]),t._v(" "),i("h2",{attrs:{id:"目录"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),i("ul",[i("li",[t._v("字符串匹配 String Matching\n"),i("ul",[i("li",[t._v("朴素字符串匹配算法 Naive String Matching")]),t._v(" "),i("li",[t._v("Rabin-Karp 字符串匹配算法")]),t._v(" "),i("li",[t._v("Finite Automaton 有限自动机-字符串匹配算法")]),t._v(" "),i("li",[t._v("Knuth-Morris-Pratt - KMP 字符串匹配算法")])])])]),t._v(" "),i("h2",{attrs:{id:"字符串匹配"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配"}},[t._v("#")]),t._v(" 字符串匹配")]),t._v(" "),i("p",[t._v("在编辑文本程序过程中，经常需要在文本中找到某个"),i("strong",[t._v("模式")]),t._v(" (pattern) 的所有出现位置。典型情况是，一段正在被编辑的文本构成一个文件，而所要寻找的模式是用户正在输入的特定的关键字。有效地解决这个问题的一类算法被称为"),i("strong",[t._v("字符串匹配算法")]),t._v("，该类算法能够极大地提高编辑文本程序时的响应效率。字符串匹配算法也被应用在其它很多方面，例如在网络搜索引擎中的信息搜索，以及 DNA 序列中搜寻特定的一段序列（与使用动态规划求解 DNA 最长子序列问题有所不同，模式字符串是"),i("strong",[t._v("下标连续的一段字符串")]),t._v("，而子序列只要求下标为严格增序）。")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/string-matching-1.png",alt:"string-matching-1"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/string-matching-2.png",alt:"string-matching-2"}})]),t._v(" "),i("h3",{attrs:{id:"符号和术语"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#符号和术语"}},[t._v("#")]),t._v(" 符号和术语")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/string-matching-3.png",alt:"string-matching-3"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/string-matching-4.png",alt:"string-matching-4"}})]),t._v(" "),i("h2",{attrs:{id:"朴素字符串匹配算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#朴素字符串匹配算法"}},[t._v("#")]),t._v(" 朴素字符串匹配算法")]),t._v(" "),i("p",[t._v("朴素字符串匹配算法是通过一个循环找到所有的有效偏移。该循环对 n-m+1 个可能的 s 值进行检测，看是否满足条件 P[1..m] == T[s+1..s+m]。")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('NAIVE_STRING_MATCHER(T, P)\n1  n = T.length\n2  m = P.length\n3  for s = 0 to n-m\n4      if P[1..m] == T[s+1..s+m]\n5          print "Pattern occur with shift" s\n')])])]),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/string-matching-5.png",alt:"string-matching-5"}})]),t._v(" "),i("h2",{attrs:{id:"rabin-karp-算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#rabin-karp-算法"}},[t._v("#")]),t._v(" Rabin-Karp 算法")]),t._v(" "),i("p",[t._v("在实际应用中，Rabin 和 Karp 所提出的字符串匹配算法能够较好地运行，并且还可以从中归纳出相关问题的其它算法，比如二维模式匹配。Rabin-Karp 算法的预处理时间是 $ \\Theta(m) $，并且在最坏情况下，它的运行时间为 $ \\Theta((n-m+1)m) $。基于一些假设，在平均情况下，它的运行时间还是比较好的。")]),t._v(" "),i("p",[t._v("该算法运用了一些初等数论的概念，比如两个数相对于第三个数模等价。并且此算法与哈希散列有相似之处。")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/rabin-karp-1.png",alt:"rabin-karp-1"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/rabin-karp-2.png",alt:"rabin-karp-2"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/rabin-karp-3.png",alt:"rabin-karp-3"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/rabin-karp-4.png",alt:"rabin-karp-4"}})]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('RABIN_KARP_MATCHER(T, P, d, q)\n1  n = T.length\n2  m = P.length\n3  h = d^{m-1} mod q\n4  p = 0\n5  t_0 = 0\n6  for i = 1 to m    // preprocessing\n7      p = (d * p + P[i]) mod q\n8      t_0 = (d * t_0 + T[i]) mod q\n9  for s = 0 to n-m  // matching\n10     if p == t_s\n11         if P[1..m] == T[s+1..s+m]\n12             print "Pattern occur with shift" s\n13     if s < n-m\n14         t_{s+1} = (d * (t_s - T[s+1] * h) + T[s+m+1]) mod q\n')])])]),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/rabin-karp-5.png",alt:"rabin-karp-5"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/rabin-karp-6.png",alt:"rabin-karp-6"}})]),t._v(" "),i("h2",{attrs:{id:"利用有限自动机进行字符串匹配"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#利用有限自动机进行字符串匹配"}},[t._v("#")]),t._v(" 利用有限自动机进行字符串匹配")]),t._v(" "),i("p",[t._v("很多字符串匹配算法都要建立一个有限自动机（比如 AC 自动机、后缀自动机 SAM、回文自动机 PAM 等），它是一个处理信息的简单机器，通过对文本字符串 T 进行扫描，找出模式 P 的所有出现位置。")]),t._v(" "),i("p",[t._v("这些字符串匹配的自动机通常都非常有效：它们只对每个文本字符"),i("strong",[t._v("检查一次")]),t._v("，并且检查每个文本字符时所用的时间为常数。因此，在模式预处理完成并建立好自动机后 进行匹配所需要的时间为 $ \\Theta(m) $。但是如果字母表 $ \\Gamma $ 很大，建立自动机所需的时间也可能很多，预处理时间为 $ O(m | \\Gamma |) $。而后面介绍的 KMP 算法可以将预处理时间缩短为 $ \\Theta(m) $。")]),t._v(" "),i("p",[t._v("下面先定义"),i("strong",[t._v("有限自动机")]),t._v(" (finite automaton)。然后，考察一种特殊的字符串匹配自动机，并展示如何用它找出一个模式在文本中出现的位置，最后，将说明对一个给定的输入模式，如何构造相应的字符串匹配自动机。")]),t._v(" "),i("h3",{attrs:{id:"有限自动机"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#有限自动机"}},[t._v("#")]),t._v(" 有限自动机")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-1.png",alt:"finite-automaton-1"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-2.png",alt:"finite-automaton-2"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-3.png",alt:"finite-automaton-3"}})]),t._v(" "),i("h3",{attrs:{id:"字符串匹配自动机"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#字符串匹配自动机"}},[t._v("#")]),t._v(" 字符串匹配自动机")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-4.png",alt:"finite-automaton-4"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-5.png",alt:"finite-automaton-5"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-6.png",alt:"finite-automaton-6"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-7.png",alt:"finite-automaton-7"}})]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('FINITE_AUTOMATON_MATCHER(T, delta, m)\n1  n = T.length\n2  q = 0\n3  for i = 1 to n\n4      q = delta(q, T[i])\n5      if q == m\n6          print "Pattern occur with shift" i - m\n')])])]),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-8.png",alt:"finite-automaton-8"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-9.png",alt:"finite-automaton-9"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-10.png",alt:"finite-automaton-10"}})]),t._v(" "),i("h3",{attrs:{id:"计算转移函数"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#计算转移函数"}},[t._v("#")]),t._v(" 计算转移函数")]),t._v(" "),i("p",[t._v("下面的过程根据一个给定模式串 P[1..m] 来计算转移函数 $ \\delta $。")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("COMPUTE_TRANSITION_FUNCTION(P, \\Gamma)\n1  m = P.length\n2  for q = 0 to m\n3      for each character a \\in \\Gamma\n4          k = min(m + 1, q + 2)\n5          repeat\n6              k = k - 1\n7          until P[1..k] is suffix of (P[1..q] join [a])\n8          \\delta(q, a) = k\n9  return \\delta\n")])])]),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/finite-automaton-11.png",alt:"finite-automaton-11"}})]),t._v(" "),i("h2",{attrs:{id:"knuth-morris-pratt-算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#knuth-morris-pratt-算法"}},[t._v("#")]),t._v(" Knuth-Morris-Pratt 算法")]),t._v(" "),i("p",[t._v("Knuth-Morris-Pratt (KMP) 算法 是 Knuth、Morris 和 Pratt 三人设计的线性时间字符串匹配算法。这个算法无需像前述有限自动机那样计算转移函数 $ \\delta $。KMP 算法的匹配时间也是 $ \\Theta(n) $，只用到辅助函数 $ \\pi $，并且可以在 $ \\Theta(m) $ 时间内根据模式串进行预处理，辅助函数的值存储于数组 $ \\pi[1..m] $ 中（后面用 p 代替符号 $ \\pi $）。数组 p 使得匹配过程中可以按需要“即时”有效地(在摊还意义上)计算转移函数 $ \\delta $。")]),t._v(" "),i("p",[t._v("KMP 的核心思想：当前匹配过程中，如果遇到了不匹配的字符，不是更换起点、从模式串首部重新匹配，而是根据之前已经匹配到的信息，回退到某个恰当的位置 继续进行匹配。")]),t._v(" "),i("h3",{attrs:{id:"关于模式的前缀函数"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#关于模式的前缀函数"}},[t._v("#")]),t._v(" 关于模式的前缀函数")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/kmp-1.png",alt:"kmp-1"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/kmp-2.png",alt:"kmp-2"}})]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/kmp-3.png",alt:"kmp-3"}})]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v('KMP_MATCHER(T, P)\n1  n = T.length\n2  m = P.length\n3  p = COMPUTE_PREFIX_FUNCTION(P)\n4  q = 0\n5  for i = 1 to n\n6      while q > 0 and P[q+1] != T[i]\n7          q = p[q]\n8      if P[q+1] == T[i]\n9          q = q + 1\n10     if q == m\n11         print "Pattern occur with shift" i - m\n12     q = p[q]\n')])])]),i("div",{staticClass:"language- extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[t._v("COMPUTE_PREFIX_FUNCTION(P)\n1  m = P.length\n2  let p[1..m] be a new array\n3  p[1] = 0\n4  k = 0\n5  for q = 2 to m\n6      while k > 0 and P[k+1] != P[q]\n7          k = p[k]\n8      if P[k+1] == P[q]\n9          k = k + 1\n10     p[q] = k\n11 return p\n")])])]),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/kmp-4.png",alt:"kmp-4"}})]),t._v(" "),i("p",[t._v("关于前缀函数计算 "),i("code",[t._v("COMPUTE_PREFIX_FUNCTION")]),t._v(" 和 KMP 算法 "),i("code",[t._v("KMP_MATCHER")]),t._v(" 的正确性，可以参考《CLRS》Chapter 32.4。")]),t._v(" "),i("p",[i("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/string-matching/kmp-5.png",alt:"kmp-5"}})]),t._v(" "),i("h2",{attrs:{id:"代码范例"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),i("h3",{attrs:{id:"python"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),i("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/other-topics/string-matching/string-algorithm.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),i("OutboundLink")],1)]),t._v(" "),i("h2",{attrs:{id:"参考资料"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),i("ul",[i("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 32")])])])}),[],!1,null,null,null);a.default=r.exports}}]);