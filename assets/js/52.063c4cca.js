(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{477:function(t,a,n){"use strict";n.r(a);var s=n(28),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"algorithm-graph-theory-all-pairs-shortest-path"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-graph-theory-all-pairs-shortest-path"}},[t._v("#")]),t._v(" Algorithm - Graph Theory - All Pairs Shortest Path")]),t._v(" "),n("p",[t._v("By "),n("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"简介"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),n("p",[t._v("全源最短路径 All Pairs Shortest Path")]),t._v(" "),n("p",[t._v("最短路径和矩阵乘法")]),t._v(" "),n("h2",{attrs:{id:"全源最短路径"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全源最短路径"}},[t._v("#")]),t._v(" 全源最短路径")]),t._v(" "),n("p",[t._v("全源最短路径是考虑如何找到一个图中所有结点之间的(加权)最短路径。")]),t._v(" "),n("p",[t._v("给定一个带(边)权重的有向图 G = (V, E)，其权重函数为 w: E -> R，该函数将边映射到实数值权重上。目标是找到对于所有的结点对 u, v \\in V，一条从结点 u 到结点 v 的加权最短路径。")]),t._v(" "),n("p",[t._v("计算结果通常以表格(二维数组)形式输出：第 u 行第 v 列给出的是结点 u 到结点 v 的最短路径权重值。")]),t._v(" "),n("p",[t._v("可以对每个结点单独运行"),n("strong",[t._v("单源最短路径算法")]),t._v("，例如 Dijkstra 算法或 Bellman-Ford 算法。")]),t._v(" "),n("ul",[n("li",[t._v("对于 Dijkstra 算法\n"),n("ul",[n("li",[t._v("如果使用"),n("strong",[t._v("线性数组")]),t._v("来实现"),n("strong",[t._v("最小优先队列")]),t._v(" Q，则 "),n("code",[t._v("|V|")]),t._v(" 次运行的总时间是 "),n("code",[t._v("O(|V|^3 + |V|·|E|)")]),t._v("，即 "),n("code",[t._v("O(|V|^3)")]),t._v("。")]),t._v(" "),n("li",[t._v("如果使用"),n("strong",[t._v("二叉堆")]),t._v("实现 Q，则 "),n("code",[t._v("|V|")]),t._v(" 次运行的总时间是 "),n("code",[t._v("O(|V|·|E| log |V|)")]),t._v("，这在"),n("strong",[t._v("稀疏图")]),t._v("的情况下是个较大的改进。")]),t._v(" "),n("li",[t._v("如果使用"),n("strong",[t._v("斐波那契堆")]),t._v("实现 Q，则 "),n("code",[t._v("|V|")]),t._v(" 次运行的总时间是 "),n("code",[t._v("O(|V|·|E| + |V|^2 log |V|)")]),t._v("。这对大型稀疏图来说是个很好的算法。")])])])]),t._v(" "),n("p",[t._v("但是如果图中含有权重为负值的边，就不能使用 Dijkstra 算法。此时如果运行 Bellman-Ford 算法，"),n("code",[t._v("|V|")]),t._v(" 次运行的总时间是 "),n("code",[t._v("O(|V|^2·|E|)")]),t._v("，在稠密图（"),n("code",[t._v("|E|")]),t._v(" 接近 "),n("code",[t._v("|V|^2")]),t._v("）的情况下，此运行时间为 "),n("code",[t._v("O(|V|^4)")]),t._v("。")]),t._v(" "),n("p",[t._v("假定用邻接矩阵来表达图结构，将结点编号为 1, 2, ..., "),n("code",[t._v("|V|")]),t._v("，则算法的输入是一个 n x n 的矩阵 W，该矩阵代表的是一个有 n 个结点的有向图 G = (V, E) 的边的权重。即 W = (wij)，其中：")]),t._v(" "),n("ul",[n("li",[t._v("若 i == j，则 wij = 0")]),t._v(" "),n("li",[t._v("若 i != j 且 (i, j) \\in E，则 wij 等于有向边 (i, j) 的权重值 w(i, j)")]),t._v(" "),n("li",[t._v("若 i != j 且 (i, j) \\notin E，则 wij = inf 无穷")])]),t._v(" "),n("p",[t._v("算法输出的表格是一个 n x n 的矩阵 D = (dij)，其中 dij 代表的是从结点 i 到结点 j 的一条最短路径的权重值。若用 d(i, j) 来代表从结点 i 到结点 j 的最短路径权重，则在算法结束时有 dij = d(i, j)。")]),t._v(" "),n("p",[t._v("为了获取最优解，还需要计算出"),n("strong",[t._v("前驱结点矩阵")]),t._v(" P = (pij)，其中 pij 在 i == j 或 从 i 到 j 不存在路径时为 nil 空，在其他情况下给出的是从结点 i 到结点 j 的某条最短路径上 结点 j 的前驱结点。有矩阵 P 的第 i 行所诱导的"),n("strong",[t._v("前驱子图")]),t._v(" 是一棵根结点为 i 的"),n("strong",[t._v("最短路径树")]),t._v("。")]),t._v(" "),n("p",[t._v("如果 Gpi 是一棵以结点 i 为根结点的最短路径树，则下面的过程将打印出从结点 i 到结点 j 的一条最短路径。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('PRINT_ALL_PAIRS_SHORTEST_PATH(P, i, j)\n1  if i == j\n2      print i\n3  elseif pij == nil\n4      print "no path from" i "to" j "exists"\n5  else\n6      PRINT_ALL_PAIRS_SHORTEST_PATH(P, i, pij)\n7      print j\n')])])]),n("h2",{attrs:{id:"全源最短路径和矩阵乘法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全源最短路径和矩阵乘法"}},[t._v("#")]),t._v(" 全源最短路径和矩阵乘法")]),t._v(" "),n("p",[t._v("本节介绍有向图 G = (V, E) 上所有结点对的最短路径问题的一种动态规划算法。在动态规划的每个大循环里，将调用一个与矩阵乘法非常相似的操作，因此该算法看上去就像是重复的矩阵乘法。下面先给出一个 "),n("code",[t._v("\\Theat(|V|^4)")]),t._v(" 的算法，然后再将该算法改进到 "),n("code",[t._v("\\Theat(|V|^3 log |V|)")]),t._v("。")]),t._v(" "),n("ul",[n("li",[t._v("动态规划算法的通常设计步骤：\n"),n("ol",[n("li",[t._v("分析最优解的结构（最优子结构性质、重叠子问题性质）")]),t._v(" "),n("li",[t._v("设计递归解决方案")]),t._v(" "),n("li",[t._v("计算最优值（自底向上的循环解法 or 带备忘的自顶向下递归解法）")]),t._v(" "),n("li",[t._v("根据第 3 步的表格信息 构造最优解")])])])]),t._v(" "),n("h3",{attrs:{id:"_1-最短路径的结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-最短路径的结构"}},[t._v("#")]),t._v(" 1. 最短路径的结构")]),t._v(" "),n("p",[t._v("在单源最短路径中，已证明一条最短路径的所有子路径都是最短路径，即具有最优子结构性质。假定用邻接矩阵来表示输入图，即 W = (wij)。考虑从结点 i 到结点 j 到一条最短路径 p，假定 p 至多包含 m 条边，并假定图中没有负权环，且 m 为有限值。")]),t._v(" "),n("p",[t._v("如果 i == j，则路径 p 的权重为 0 且不包含任何边。如果结点 i 和结点 j 不是同一个结点，则将路径 p 分解为 "),n("code",[t._v("i ~> k->j")]),t._v("，其中 i 到 k 的路径 p' 至多包含 m-1 条边。由 "),n("strong",[t._v("引理 24.1")]),t._v("（最短路径的子路径也是最短路径）可知，p' 是从结点 i 到 k 的一条最短路径，因此 d(i, j) = d(i, k) + wkj。")]),t._v(" "),n("h3",{attrs:{id:"_2-设计递归解决方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-设计递归解决方案"}},[t._v("#")]),t._v(" 2. 设计递归解决方案")]),t._v(" "),n("p",[t._v("设 lij^{m} 为从结点 i 到结点 j 的至多包含 m 条边的任意路径中的最小权重。当 m == 0 时，从结点 i 到结点 j 之间存在一条没有变得最短路径 当且仅当 i == j。因此有：")]),t._v(" "),n("ul",[n("li",[t._v("如果 i == j，则 lij^{0} = 0")]),t._v(" "),n("li",[t._v("如果 i != j，则 lij^{0} = inf 无穷")])]),t._v(" "),n("p",[t._v("对于 m >= 1，需要计算的 lij^{m} 是 lij^{m-1} 的最小值 和 从 i 到 j 最多由 m 条边组成的任意路径的最小权重。通过对 j 的所有可能的前驱结点 k 进行检查来获得该值。因此递归式定义如下：")]),t._v(" "),n("p",[t._v("$$ lij^{m} = min( lij^{m-1}, min( lik^{m-1} + w(k, j) ) ) $$")]),t._v(" "),n("p",[t._v("因为对于所有的 j 有 w(j, j) = 0，所以上式简化为：对所有 1 <= k <= n，计算 $ lij^{m} = min( lik^{m-1} + w(k, j) ) $")]),t._v(" "),n("p",[t._v("如果图 G 不包含负权环，则对于每一对结点 i 和 j，如果 d(i, j) < inf，表示从 i 到 j 之间存在一条最短路径。由于该路径是简单路径，其包含的边最多为 n-1 条。从结点 i 到结点 j 的、由多于 n-1 条边构成的路径的权重 不可能比从 i 到 j 的最短路径权重更小。因此，真正的最短路径权重可以由此公式给出：$ d(i, j) = lij^{n-1} = lij^{n} = lij^{n+1} = ... $")]),t._v(" "),n("h3",{attrs:{id:"_3-自底向上的循环解法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-自底向上的循环解法"}},[t._v("#")]),t._v(" 3. 自底向上的循环解法")]),t._v(" "),n("p",[t._v("根据输入矩阵 W = (wij)，可以计算出矩阵序列 L^{1}, L^{2}, ..., L^{n-1}，其中对于 m = 1, 2, ..., n-1，有 L^{m} = (lij^{m})。最后的矩阵 L^{n-1} 包含的是最短路径的实际权重。注意，对于所有的结点 i 和 j，L^{1} = (wij)，因此 L^{1} = W。")]),t._v(" "),n("p",[t._v("该算法的核心如下面的伪代码所示。该伪代码程序可以在给定 W 和 L^{m-1} 的情况下，计算出 L^{m}。也就是说，该伪代码将最近计算出的最短路径扩展了一条边。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("EXTEND_SHORTEST_PATHS(L, W)\n1  n = L.rows\n2  let L' = (l_ij') be a new n x n matrix\n3  for i = 1 to n\n4      for j = 1 to n \n5          l_ij' = inf\n6          for k = 1 to n\n7              l_ij' = min(l_ij', l_ik + w_kj)\n8  return L'\n")])])]),n("p",[t._v("该过程计算在算法结束时返回的矩阵 L' = (lij')。计算该矩阵的方式是对于所有的 i 和 j 来计算第 2 步给出的递归公式。使用 L 作为 L^{m-1}，而 L' 作为 L^{m}。该算法的运行时间为 "),n("code",[t._v("\\Theta(n^3)")]),t._v("。")]),t._v(" "),n("p",[t._v("这与矩阵乘法的过程很类似，$ cij = \\sum_{k=1}^{n} aik · bkj $")]),t._v(" "),n("div",{staticClass:"language-python extra-class"},[n("pre",{pre:!0,attrs:{class:"language-python"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 朴素的矩阵乘积运算")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 时间复杂度 \\Theta(n^3)")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("_naive_mm")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("len")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("matrix_a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res_matrix "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" j "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" k "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("range")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n                res_matrix"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("matrix_a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("k"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" self"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("matrix_b"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("k"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" res_matrix\n")])])]),n("p",[t._v("回到全源最短路径问题，通过对最短路径一条边一条边地扩展来计算最短路径权重，设 A·B 表示由算法 "),n("code",[t._v("EXTEND_SHORTEST_PATHS(A, B)")]),t._v(" 所返回的矩阵“乘积”，可以计算出下面由 n-1 个矩阵所构成的矩阵序列：")]),t._v(" "),n("ul",[n("li",[t._v("L^{1} = L^{0} · W = W")]),t._v(" "),n("li",[t._v("L^{2} = L^{1} · W = W^2")]),t._v(" "),n("li",[t._v("L^{3} = L^{2} · W = W^3")]),t._v(" "),n("li",[t._v("...")]),t._v(" "),n("li",[t._v("L^{n-1} = L^{n-2} · W = W^{n-1}")])]),t._v(" "),n("p",[t._v("前面已经阐述了，矩阵 L^{n-1} = W^{n-1} 包含的是最短路径权重，下面的伪代码程序可以在 "),n("code",[t._v("\\Theta(n^4)")]),t._v(" 运行时间内计算出该矩阵序列。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("SLOW_ALL_PAIRS_SHORTEST_PATHS(W)\n1  n = W.rows\n2  L^{1} = W\n3  for m = 2 to n-1\n4      let L^{m} be a new n x n matrix\n5      L^{m} = EXTEND_SHORTEST_PATHS(L^{m-1}, W)\n6  return L^{n-1}\n")])])]),n("p",[n("img",{attrs:{src:"/img/info-technology/algorithm/graph-theory/shortest-path/all-pairs-sp-mm-1.png",alt:"all-pairs-sp-mm-1"}})]),t._v(" "),n("h3",{attrs:{id:"改进算法的运行时间"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#改进算法的运行时间"}},[t._v("#")]),t._v(" 改进算法的运行时间")]),t._v(" "),n("p",[t._v("注意到，目标并不是要计算出所有的 L^{m} 矩阵，感兴趣的仅仅是 L^{n-1}。而且根据前面的分析，在没有负权环的情况下，对所有的 m >= n-1，均有 L^{m} = L^{n-1}。正如传统的矩阵乘法是相关的，由 "),n("code",[t._v("EXTEND_SHORTEST_PATHS")]),t._v(" 过程所定义的矩阵乘法也是相关的，因此可以利用"),n("strong",[t._v("矩阵快速幂")]),t._v("的思想，设计如下的"),n("strong",[t._v("重复平方")]),t._v("计算方法，记 $ log_{2} (n-1) $ 的上取整值为 t：")]),t._v(" "),n("ul",[n("li",[t._v("L^{1} = W")]),t._v(" "),n("li",[t._v("L^{2} = W^2 = W · W")]),t._v(" "),n("li",[t._v("L^{4} = W^4 = W^2 · W^2")]),t._v(" "),n("li",[t._v("L^{8} = W^8 = W^4 · W^4")]),t._v(" "),n("li",[t._v("...")]),t._v(" "),n("li",[t._v("L^{2^t} = W^{2^t} = W^{2^{t-1}} · W^{2^{t-1}}")])]),t._v(" "),n("p",[t._v("由于 2^t >= n-1，所以最后的乘积 L^{2^t} 等于 L^{n-1}。下面的伪代码过程使用重复平方技术来计算上述矩阵序列")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("FASTER_ALL_PAIRS_SHORTEST_PATHS(W)\n1  n = W.rows\n2  L^{1} = W\n3  m = 1\n4  while m < n-1\n5      let L^{2m} be a new n x n matrix\n6      L^{2m} = EXTEND_SHORTEST_PATHS(L^{m}, L^{m})\n7      m = 2m\n8  return L^{m}\n")])])]),n("p",[n("code",[t._v("FASTER_ALL_PAIRS_SHORTEST_PATHS")]),t._v(" 过程的总运行时间为 "),n("code",[t._v("\\Theta(n^3 log n)")]),t._v("。由于该代码非常紧凑，也没有包含任何精巧的数据结构，因此隐藏在渐近符号中的常数因子较小，且算法实现难度很小。")]),t._v(" "),n("h2",{attrs:{id:"python-代码范例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python-代码范例"}},[t._v("#")]),t._v(" Python 代码范例")]),t._v(" "),n("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),n("h3",{attrs:{id:"全源最短路径和矩阵乘法-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全源最短路径和矩阵乘法-2"}},[t._v("#")]),t._v(" 全源最短路径和矩阵乘法")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/graph-theory/shortest-path/all-pairs-sp-mm.py",target:"_blank",rel:"noopener noreferrer"}},[t._v("GitHub Code Link"),n("OutboundLink")],1)]),t._v(" "),n("h2",{attrs:{id:"参考资料"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),n("ul",[n("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 25")])])])}),[],!1,null,null,null);a.default=_.exports}}]);