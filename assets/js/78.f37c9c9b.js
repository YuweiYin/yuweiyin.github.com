(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{513:function(t,a,s){"use strict";s.r(a);var n=s(28),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"algorithm-number-theoretic-algorithm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-number-theoretic-algorithm"}},[t._v("#")]),t._v(" Algorithm - Number-Theoretic Algorithm")]),t._v(" "),s("p",[t._v("By "),s("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("YuweiYin"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),s("ul",[s("li",[t._v("数论算法 Number-Theoretic Algorithm\n"),s("ul",[s("li",[t._v("欧几里得算法 Euclidean Algorithm")]),t._v(" "),s("li",[t._v("扩展的欧几里得算法 Extended Euclidean Algorithm")])])])]),t._v(" "),s("h2",{attrs:{id:"数论算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数论算法"}},[t._v("#")]),t._v(" 数论算法")]),t._v(" "),s("p",[t._v("数论曾经被视为一种优美但没什么实际用途的纯数学学科。如今，数论算法已经得到了广泛的使用。这很大程度上要归功于人们发明了"),s("strong",[t._v("基于大素数的加密方法")]),t._v("。快速计算大素数的算法使得高效加密成为可能，而目前其安全性的保证则依赖于缺少高效地"),s("strong",[t._v("将大合数分解为大素数之积")]),t._v("（或求解相关问题，如计算"),s("strong",[t._v("离散对数")]),t._v("）方法的现状。")]),t._v(" "),s("p",[s("strong",[t._v("量子计算")]),t._v("与量子通信是目前的前沿研究。在量子计算机中，有一种 Shor's Algorithm "),s("strong",[t._v("秀尔算法")]),t._v("用于因子分解，可以很快地计算因子分解问题（而这个问题在目前流行的计算模型中 需要耗费指数渐近时间）。")]),t._v(" "),s("p",[t._v("在数论算法中，处理的对象是大整数。而且一般不像排序算法那样，是对大量整数的处理。因此，数论算法通常利用输入所需的"),s("strong",[t._v("位数")]),t._v("来度量输入的大小，而不仅仅是输入中整数的数目。给定 k 个整数输入 $ a_{1}, ..., a_{k} $，如果算法可以在关于 $ log_{2} (a_1), ..., log_{2} (a_k) $ 的多项式时间完成（即算法在关于"),s("strong",[t._v("整数的二进制形式的位数")]),t._v("的多项式时间内完成），则称算法称为"),s("strong",[t._v("多项式时间算法")]),t._v("。")]),t._v(" "),s("p",[t._v("另外，由于当输入整数很大时，基本运算（乘法、除法、模运算等）也会变得较为耗时，因此数论算法通常使用所需的"),s("strong",[t._v("位运算")]),t._v("数目作为基准来衡量算法的时间代价。例如，将两个 k (二进制)位整数用常规方法相乘 需要 $ \\Theta(k^2) $ 次位运算。同样地，用朴素的方法计算一个 k (二进制)位整数除以另一个较短整数的商或求余数 也需要耗时 $ \\Theta(k^2) $。")]),t._v(" "),s("p",[t._v("如今，人们已有了更快的数值计算方法。例如，一个简单的分支算法可以在两个 k (二进制)位整数相乘的问题上达到 $ \\Theta(k^{log_{2} 3}) $ 的运行时间。而已知的最快算法则只需要 $ \\Theta(k log_{2} {k} log_{2} log_{2} {k}) $。然而，在实际问题中，简单直接的 $ \\Theta(k^2) $ 算法往往效果最好。")]),t._v(" "),s("h2",{attrs:{id:"基础数论概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础数论概念"}},[t._v("#")]),t._v(" 基础数论概念")]),t._v(" "),s("p",[t._v("这里简单回顾基础数论中关于整数集 Z = {..., -2, -1, 0, 1, 2, ...} 和自然数集 N = {0, 1, 2, ...} 的一些概念。")]),t._v(" "),s("h3",{attrs:{id:"整除性与约数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整除性与约数"}},[t._v("#")]),t._v(" 整除性与约数")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-1.png",alt:"number-theory-1"}})]),t._v(" "),s("h3",{attrs:{id:"素数与合数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#素数与合数"}},[t._v("#")]),t._v(" 素数与合数")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-2.png",alt:"number-theory-2"}})]),t._v(" "),s("h3",{attrs:{id:"除法定理、余数和等模"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#除法定理、余数和等模"}},[t._v("#")]),t._v(" 除法定理、余数和等模")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-3.png",alt:"number-theory-3"}})]),t._v(" "),s("h3",{attrs:{id:"公约数与最大公约数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#公约数与最大公约数"}},[t._v("#")]),t._v(" 公约数与最大公约数")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-4.png",alt:"number-theory-4"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-5.png",alt:"number-theory-5"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-6.png",alt:"number-theory-6"}})]),t._v(" "),s("h3",{attrs:{id:"互质数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#互质数"}},[t._v("#")]),t._v(" 互质数")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-7.png",alt:"number-theory-7"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-8.png",alt:"number-theory-8"}})]),t._v(" "),s("h3",{attrs:{id:"唯一因子分解定理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#唯一因子分解定理"}},[t._v("#")]),t._v(" 唯一因子分解定理")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-9.png",alt:"number-theory-9"}})]),t._v(" "),s("h3",{attrs:{id:"其它相关性质"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它相关性质"}},[t._v("#")]),t._v(" 其它相关性质")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-10.png",alt:"number-theory-10"}})]),t._v(" "),s("h3",{attrs:{id:"素数的数量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#素数的数量"}},[t._v("#")]),t._v(" 素数的数量")]),t._v(" "),s("p",[t._v("可以用反证法，证明素数的个数有无穷多个")]),t._v(" "),s("h3",{attrs:{id:"素数的分布"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#素数的分布"}},[t._v("#")]),t._v(" 素数的分布")]),t._v(" "),s("p",[t._v("关于素数的分布，数论领域有许多研究，其中很著名的就有黎曼猜想，关于 Riemman Zeta function")]),t._v(" "),s("h2",{attrs:{id:"最大公约数-gcd"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最大公约数-gcd"}},[t._v("#")]),t._v(" 最大公约数 GCD")]),t._v(" "),s("p",[s("strong",[t._v("欧几里得算法")]),t._v(" Euclidean Algorithm 可以高效地计算两个整数的最大公约数 (Greatest Common Divisor, GCD)。在对其运行时间进行分析的过程中，可以发现它与"),s("strong",[t._v("斐波那契数列")]),t._v("存在一些联系，由此可知欧几里得算法最坏情况下的输入。")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-11.png",alt:"number-theory-11"}})]),t._v(" "),s("h3",{attrs:{id:"欧几里得算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#欧几里得算法"}},[t._v("#")]),t._v(" 欧几里得算法")]),t._v(" "),s("p",[t._v("欧几里得（约公元前 300 年）的《几何原本》描述了下列 gcd 算法，实际上这一算法出现的时间可能还要早些。可以直接利用前述定理 31.9 得到 GCD 递归程序，其输入 a 和 b 都是"),s("strong",[t._v("任意非负整数")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("EUCLID(a, b)\n1  if b == 0\n2      return a\n3  else\n4      return EUCLID(b, a mod b)\n")])])]),s("p",[t._v("计算过程举例：EUCLID(30, 21) = EUCLID(21, 9) = EUCLID(9, 3) = EUCLID(3, 0) = 3")]),t._v(" "),s("p",[t._v("另外，如果在输入时 a < b，那么首次递归后就会交换二者的位置。")]),t._v(" "),s("p",[t._v("前述 "),s("code",[t._v("EUCLID")]),t._v(" 过程是尾递归，可以改成如下迭代形式：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("EUCLID(a, b)\n1  while b != 0\n2      (a, b) = (b, a mod b)\n3  return a\n")])])]),s("h3",{attrs:{id:"欧几里得算法的运行时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#欧几里得算法的运行时间"}},[t._v("#")]),t._v(" 欧几里得算法的运行时间")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-12.png",alt:"number-theory-12"}})]),t._v(" "),s("p",[t._v("斐波那契数列：$ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... $")]),t._v(" "),s("p",[t._v("EUCLID(89, 55) = EUCLID(55, 34) = EUCLID(34, 21) = EUCLID(21, 13) = EUCLID(13, 8) = EUCLID(8, 5) = EUCLID(5, 3) = EUCLID(3, 1) = EUCLID(1, 0) = 1")]),t._v(" "),s("p",[t._v("$ gcd(F_{k+1}, F_{k}) = gcd(F_{k}, F_{k-1}) $")]),t._v(" "),s("h3",{attrs:{id:"欧几里得算法的扩展形式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#欧几里得算法的扩展形式"}},[t._v("#")]),t._v(" 欧几里得算法的扩展形式")]),t._v(" "),s("p",[t._v("欧几里得算法不仅能计算最大公约数，利用其计算过程的系数，可以得出**(模)乘法的逆元**。此系数是满足下述条件的整系数 x 和 y：$ d = gcd(a, b) = ax + by $。这里 x 与 y 可能为 0 或负数。")]),t._v(" "),s("p",[t._v("下述伪代码描述的过程 "),s("code",[t._v("EXTENDED_EUCLID")]),t._v(" 的输入为一对非负整数，并返回一个满足前述条件三元组 (d, x, y)：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("EXTENDED_EUCLID(a, b)\n1  if b == 0\n2      return (a, 1, 0)\n3  else\n4      (d', x', y') = EXTENDED_EUCLID(b, a mod b)\n5      (d, x, y) = (d', y' x' - \\floor(a / b) * y')\n6      return (d, x, y)\n")])])]),s("p",[s("img",{attrs:{src:"/img/info-technology/algorithm/other-topics/number-theoretic-algorithm/number-theory-13.png",alt:"number-theory-13"}})]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("EXTENDED_EUCLID(a, b)")]),t._v(" 返回 (d, x, y)，表示 a 和 b 的最大公约数是 d，即有 gcd(a, b) = d = ax + by")]),t._v(" "),s("p",[t._v("如果返回的 d 为 1，则表示 a 和 b 互素，且由于 1 = ax + by，可以得到如下结果：")]),t._v(" "),s("ul",[s("li",[t._v("1 = (ax + by) mod b，故有 1 = (ax) mod b，这意味着在 mod b 的情况下，a 与 x 互为乘法逆元\n"),s("ul",[s("li",[t._v("同理，在 mod y 的情况下，也有 a 与 x 互为乘法逆元")])])]),t._v(" "),s("li",[t._v("1 = (ax + by) mod a，故有 1 = (by) mod a，这意味着在 mod a 的情况下，b 与 y 互为乘法逆元\n"),s("ul",[s("li",[t._v("同理，在 mod x 的情况下，也有 b 与 y 互为乘法逆元")])])]),t._v(" "),s("li",[t._v("不过由于计算前往往不知道 x 和 y 值，所以一般是为了得到在 mod b 的情况下，a 的乘法逆元（以及在 mod a 的情况下，b 的乘法逆元）")])]),t._v(" "),s("p",[t._v("因此运用 "),s("code",[t._v("EXTENDED_EUCLID")]),t._v(" 可以高效地计算出 最大公约数 和 (模)乘法逆元。")]),t._v(" "),s("h2",{attrs:{id:"代码范例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[t._v("#")]),t._v(" 代码范例")]),t._v(" "),s("h3",{attrs:{id:"python"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[t._v("#")]),t._v(" Python")]),t._v(" "),s("p",[t._v("Python 环境：Python 3.7")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#!/usr/bin/env python")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -*- coding:utf-8 -*-")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v('"""=================================================\n@Project : algorithm/other-topics/number-theoretic-algorithm\n@File    : number-theory.py\n@Author  : YuweiYin\n@Date    : 2020-06-09\n=================================================="""')]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" sys\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" time\n\n"),s("span",{pre:!0,attrs:{class:"token triple-quoted-string string"}},[t._v('"""\n- 数论算法 Number-Theoretic Algorithm\n    - 欧几里得算法 Euclidean Algorithm\n    - 扩展的欧几里得算法 Extended Euclidean Algorithm\n\n参考资料：\nIntroduction to Algorithm (aka CLRS) Third Edition - Chapter 31\n"""')]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NumberTheoreticAlgorithm")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__init__")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pass")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# (递归的)欧几里得算法 - 求最大公约数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 返回最大公约数 gcd(a, b)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果 gcd(a, b) == 1，则表示 a 与 b 互素")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 时间复杂度：O(log b)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最坏情况：a 和 b 是相邻的斐波那契数。此时，如果较大数是第 k 个斐波那契数，那么将递归 k 次")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("recursive_euclid")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# return a if b == 0 else self.recursive_euclid(b, a % b)")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("recursive_euclid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# (迭代的)欧几里得算法 - 求最大公约数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 时间复杂度：O(log b)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token decorator annotation punctuation"}},[t._v("@staticmethod")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("iterative_euclid")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" b\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# (递归的)扩展欧几里得算法 - 求最大公约数 & (模)乘法逆元")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 时间复杂度：O(log b)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 返回 (d, x, y) 满足 gcd(a, b) = d = ax + by")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 因此如果最终 d == 1，那么在 mod b 或 mod y 的情况下，a 与 x 互为(模)乘法逆元")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 同理如果最终 d == 1，那么在 mod a 或 mod x 的情况下，b 与 y 互为(模)乘法逆元")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 然而如果最终 d >= 1，那么在 mod b 或 mod y 的情况下，a/d 与 x 互为(模)乘法逆元")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 同理如果最终 d >= 1，那么在 mod a 或 mod x 的情况下，b/d 与 y 互为(模)乘法逆元")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("recursive_extended_euclid")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" self"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("recursive_extended_euclid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    nta "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NumberTheoreticAlgorithm"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 计算最大公约数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'\\nGCD - (Extended) Euclidean Algorithm:'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("99")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("78")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 同《CLRS》Chapter 31 中的图 31-1")]),t._v("\n\n    start "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("process_time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res_1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nta"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("recursive_euclid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res_2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nta"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("iterative_euclid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    res_3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nta"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("recursive_extended_euclid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    end "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("process_time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 输出结果")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# gcd(99, 78) = 3 = -11 * 99 + 14 * 78")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res_1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res_2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("res_3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Running Time: %.5f ms'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("end "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" start"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" __name__ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__main__"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    sys"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("h2",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),s("ul",[s("li",[t._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 31")])])])}),[],!1,null,null,null);a.default=r.exports}}]);