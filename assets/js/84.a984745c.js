(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{350:function(_,v,e){"use strict";e.r(v);var t=e(28),i=Object(t.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"algorithm-sort-heap-sort"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-sort-heap-sort"}},[_._v("#")]),_._v(" Algorithm - Sort - Heap Sort")]),_._v(" "),e("p",[_._v("By "),e("a",{attrs:{href:"https://yuweiyin.github.io/",target:"_blank",rel:"noopener noreferrer"}},[_._v("YuweiYin"),e("OutboundLink")],1)]),_._v(" "),e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[_._v("#")]),_._v(" 简介")]),_._v(" "),e("p",[_._v("堆排序算法 (Heap Sort)")]),_._v(" "),e("p",[_._v("(二叉)堆是一个数组，它可以被看成一个近似的完全二叉树：除了最后一层外，是完美二叉树（完全充满的二叉树），最后一层的结点全部靠左（但可能有奇数个）。树上的每一个结点对应数组中的一个元素。")]),_._v(" "),e("p",[_._v("表示堆的数组 A 包括两个属性：A.length 给出数组元素的个数，A.heap_size 表示有多少个堆元素存储在该数组中。取值范围 0 <= A.heap_size <= A.length。即：虽然数组 A[0..A.length-1] 可能都存有数据，但只有 A[0..A.heap_size-1] 中存放的是堆的有效元素。")]),_._v(" "),e("p",[e("img",{attrs:{src:"/img/info-technology/algorithm/sort/heap-sort-1.png",alt:"heap-sort-1"}})]),_._v(" "),e("p",[_._v("树的根结点是数组首元素 A[0]，给定一个结点的下标 i，很容易计算得到它的父结点、左孩子和右孩子的下标：")]),_._v(" "),e("ul",[e("li",[_._v("计算父结点下标 "),e("code",[_._v("parent(i) = int(i / 2)")])]),_._v(" "),e("li",[_._v("计算左孩子下标 "),e("code",[_._v("left(i) = 2i")])]),_._v(" "),e("li",[_._v("计算右孩子下标"),e("code",[_._v("right(i) = 2i + 1")])])]),_._v(" "),e("p",[_._v("当然，实际运算时要用移位操作代替乘除法。")]),_._v(" "),e("p",[_._v("二叉堆可以分为两种形式：最大堆和最小堆。")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("最大堆性质")]),_._v("：在最大堆中，除了根以外的所有结点 i 都要满足 "),e("code",[_._v("A[parent(i)] >= A[i]")]),_._v("。所以保证根结点最大")]),_._v(" "),e("li",[e("strong",[_._v("最小堆性质")]),_._v("：在最小堆中，除了根以外的所有结点 i 都要满足 "),e("code",[_._v("A[parent(i)] <= A[i]")]),_._v("。所以保证根结点最小")])]),_._v(" "),e("p",[_._v("key 升序 heap-sort 使用最大堆，降序使用最小堆。")]),_._v(" "),e("p",[_._v("如果把堆看成一棵二叉树，定义一个堆中的结点的"),e("strong",[_._v("高度")]),_._v("为该结点到叶结点最长简单路径的长度（边的数目）。故叶结点高度为 0。")]),_._v(" "),e("p",[_._v("由于堆是一棵近似的完全二叉树，那么包含 n 个元素的堆的高度是 O (log n)。堆上的基本操作的运行时间至多与树的高度成正比，即时间复杂度为 O(log n)。")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("build_max_heap")]),_._v("：构建最大堆。时间复杂度为 O(n)")]),_._v(" "),e("li",[e("code",[_._v("max_heapify")]),_._v("：维护最大堆性质。时间复杂度为 O(log n)")]),_._v(" "),e("li",[e("code",[_._v("heap_sort")]),_._v("：对一个数组进行原址排序。时间复杂度为 O(n log n)")]),_._v(" "),e("li",[e("code",[_._v("max_heap_insert")]),_._v("、"),e("code",[_._v("max_extract_max")]),_._v("、"),e("code",[_._v("max_increase_key")]),_._v(" 和 "),e("code",[_._v("max_maximum")]),_._v("：利用堆实现一个优先队列。各操作的时间复杂度均为 O(log n)")])]),_._v(" "),e("h2",{attrs:{id:"场景描述及分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#场景描述及分析"}},[_._v("#")]),_._v(" 场景描述及分析")]),_._v(" "),e("ul",[e("li",[_._v("堆排序\n"),e("ul",[e("li",[_._v("空间复杂度(辅助存储)：O(1)")]),_._v(" "),e("li",[_._v("时间复杂度-平均/最好/最坏 O(n log n)")]),_._v(" "),e("li",[_._v("算法稳定性：不稳定")]),_._v(" "),e("li",[_._v("堆排序与(直接)插入排序的相同点在于空间原址性，只需要额外 O(1) 的辅助存储空间。")]),_._v(" "),e("li",[_._v("堆排序与(二路)归并排序的相同点在于时间复杂度均为 O(n log n)。")]),_._v(" "),e("li",[_._v("但堆排序是不稳定的，这跟(直接)插入排序和(二路)归并排序不同。")])])])]),_._v(" "),e("p",[_._v("堆排序是个优秀的算法，但是在实际应用中，快速排序 Quick Sort 的性能一般会优于堆排序。")]),_._v(" "),e("p",[_._v("堆数据结构仍有许多应用，其中一个常见的应用就是"),e("strong",[_._v("优先队列")]),_._v("的实现。可以用"),e("strong",[_._v("最大堆")]),_._v("实现"),e("strong",[_._v("最大优先队列")]),_._v("、用"),e("strong",[_._v("最小堆")]),_._v("实现"),e("strong",[_._v("最小优先队列")]),_._v("。")]),_._v(" "),e("p",[e("strong",[_._v("优先队列")]),_._v(" (Priority Queue) 是一种用来维护一组元素构成的集合 S 的数据结构，其中的每一个元素都有一个相关的值，称为"),e("strong",[_._v("关键字")]),_._v(" (key)。")]),_._v(" "),e("p",[_._v("一个最大优先队列支持以下操作：")]),_._v(" "),e("ul",[e("li",[_._v("insert(S, x): 把元素 x 插入集合 S 中。这一操作等价于 S = S 并 {x}")]),_._v(" "),e("li",[_._v("maximum(S): 返回 S 中具有最大关键字 key 的元素。")]),_._v(" "),e("li",[_._v("extract_max(S): 去掉并返回 S 中的具有最大关键字 key 的元素。")]),_._v(" "),e("li",[_._v("increase_key(S, x, k): 将元素 x 的关键字值增加到 k，这里假设 k 的值不小于 x 的原关键字值。")])]),_._v(" "),e("p",[_._v("最大优先队列的应用有很多，其中一个就是在"),e("strong",[_._v("共享计算机系统的作业调度")]),_._v("。最大优先队列记录将要执行的各个作业以及它们之间的"),e("strong",[_._v("相对优先级")]),_._v("（或者他们的绝对优先级）。当一个作业完成或者被中断后，调度器调用 extract_max 从所有等待的作业中，"),e("strong",[_._v("选出具有最高优先级的作业")]),_._v("来执行。在任何时候，调度器可以调用 insert 把一个新作业加入到队列中来。")]),_._v(" "),e("p",[_._v("相应地，最小优先队列支持的操作包括 insert、minimum、extract_min 和 decrease_key。最小优先队列可以被用于"),e("strong",[_._v("基于事件驱动的模拟器")]),_._v("。队列中保存要模拟的时间，每个事件都有一个"),e("strong",[_._v("发生时间")]),_._v("作为其关键字 key。事件必须"),e("strong",[_._v("按照发生的时间顺序")]),_._v("进行模拟，因为某一事件的模拟结果可能会触发对其它事件的模拟。在每一步，模拟程序调用 extract_min 来选择下一个要模拟的事件。当一个新事件产生时，模拟器通过调用 insert 将其插入最小优先队列中。")]),_._v(" "),e("p",[_._v("每个元素除了有关键字 key，还应有一个"),e("strong",[_._v("句柄")]),_._v(" (handle) 作为资源标志符。本文实现中 Element 类中的 val 属性就可以存储句柄。")]),_._v(" "),e("h2",{attrs:{id:"设计-细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计-细节"}},[_._v("#")]),_._v(" 设计 & 细节")]),_._v(" "),e("h3",{attrs:{id:"算法流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#算法流程"}},[_._v("#")]),_._v(" 算法流程")]),_._v(" "),e("h3",{attrs:{id:"实现细节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现细节"}},[_._v("#")]),_._v(" 实现细节")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("__init__")])]),_._v(" "),e("li",[e("code",[_._v("do_sort")])]),_._v(" "),e("li",[e("code",[_._v("_heap_sort")])]),_._v(" "),e("li",[e("code",[_._v("build_max_heap")])]),_._v(" "),e("li",[e("code",[_._v("build_min_heap")])]),_._v(" "),e("li",[e("code",[_._v("_max_heapify")])]),_._v(" "),e("li",[e("code",[_._v("_min_heapify")])]),_._v(" "),e("li",[e("code",[_._v("get_maximum")])]),_._v(" "),e("li",[e("code",[_._v("extract_max")])]),_._v(" "),e("li",[e("code",[_._v("increase_key")])]),_._v(" "),e("li",[e("code",[_._v("max_heap_insert")])]),_._v(" "),e("li",[e("code",[_._v("get_minimum")])]),_._v(" "),e("li",[e("code",[_._v("extract_min")])]),_._v(" "),e("li",[e("code",[_._v("decrease_key")])]),_._v(" "),e("li",[e("code",[_._v("min_heap_insert")])]),_._v(" "),e("li",[e("code",[_._v("heap_insert")])]),_._v(" "),e("li",[e("code",[_._v("_parent")])]),_._v(" "),e("li",[e("code",[_._v("_left")])]),_._v(" "),e("li",[e("code",[_._v("_right")])]),_._v(" "),e("li",[e("code",[_._v("_max_exchange")])]),_._v(" "),e("li",[e("code",[_._v("_min_exchange")])]),_._v(" "),e("li",[e("code",[_._v("get_ele_list")])]),_._v(" "),e("li",[e("code",[_._v("get_key_list")])]),_._v(" "),e("li",[e("code",[_._v("get_val_list")])]),_._v(" "),e("li",[e("code",[_._v("get_min_ele_list")])]),_._v(" "),e("li",[e("code",[_._v("get_min_key_list")])]),_._v(" "),e("li",[e("code",[_._v("get_min_val_list")])]),_._v(" "),e("li",[e("code",[_._v("update_ele_list")])])]),_._v(" "),e("h2",{attrs:{id:"代码范例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码范例"}},[_._v("#")]),_._v(" 代码范例")]),_._v(" "),e("h3",{attrs:{id:"python"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#python"}},[_._v("#")]),_._v(" Python")]),_._v(" "),e("p",[_._v("Python 环境：Python 3.7")]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("注")]),_._v("：\n"),e("ul",[e("li",[_._v("排序算法的基类 Sort 和元素结构体类 Element 写法与 "),e("a",{attrs:{href:"./sort-base-class"}},[_._v("此文章")]),_._v(" 完全相同，故不在下方赘述。")]),_._v(" "),e("li",[_._v("如果要运行此代码，则还需先将 Sort 类和 Element 类置于本代码中。")]),_._v(" "),e("li",[_._v("Element 类完全可以根据程序需求来自定义，但是需要给出该类中的 key 和 value 属性名。")])])])]),_._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/YuweiYin/Code_Play/blob/master/Algorithm-Essence/sort/heap-sort.py",target:"_blank",rel:"noopener noreferrer"}},[_._v("GitHub Code Link"),e("OutboundLink")],1)]),_._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[_._v("#")]),_._v(" 参考资料")]),_._v(" "),e("ul",[e("li",[_._v("Introduction to Algorithm (aka CLRS) Third Edition - Chapter 6")])])])}),[],!1,null,null,null);v.default=i.exports}}]);